<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Marcus&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="nop">
<meta property="og:type" content="website">
<meta property="og:title" content="Marcus&#39;s Blog">
<meta property="og:url" content="https://monstergeo.github.io/btest/page/2/">
<meta property="og:site_name" content="Marcus&#39;s Blog">
<meta property="og:description" content="nop">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Marcus">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Marcus's Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Marcus&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Hello</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://monstergeo.github.io/btest"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-链表" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/02/12/%E9%93%BE%E8%A1%A8/" class="article-date">
  <time class="dt-published" datetime="2025-02-11T19:45:04.000Z" itemprop="datePublished">2025-02-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/02/12/%E9%93%BE%E8%A1%A8/">链表</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>这节我们讲讲链表，书籍是Weiss的《数据结构与算法分析》</p>
<h1 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h1><p>一个好的程序之一是每个模块都应该尽量的小而美，换句话说，每个模块是一个逻辑单位并执行某个特定的任务，它将通过调用其他模块而使本身变得很小。模块化有一些优点，比如调试小程序总比调试大程序容易得多；第二，多个人对一个模块化程序编程要简单一些；第三，一个写得好的模块化程序把某些以来关系只局限在某个例程中，修改调试会很方便。</p>
<p>抽象数据类型（ADT:abstract data type）是一些操作的集合，我们可以理解为数学上的抽象。例如将等式1+2&#x3D;3改写为用未知量替代的方程x+y&#x3D;z。也就是写成一些比较通用的形式。一般来说，在ADT中定义我们是不涉及如何实现操作的集合，所以这可以看作是模块化设计的扩充。因为我们正在设计一些通用程序。</p>
<p>对表、集合、图和他们的操作可以看作是抽象数据类型，就像整数、实数和布尔值是数据类型一样，它们各自有各自相关的操作。而抽象数据类型也有它们自己相关的操作，对集合ADT，我们可以有交、并、测量大小以及取余（取补集）的操作。或者，我们也可以只有两种操作：并和查找。这两种操作也在集合上定义了一种不同的ADT。</p>
<p>现在我们有一种简单的思想，重复的模块运用十分的讨厌，为此我们只将这些操作编写一遍，而在程序中如何部分需要在该ADT上运行其中一种函数的时候，我们就通过调用适当的函数来解决问题。如果有一些其他的细节，我们可以简单的修改该模块实现。本章我们将讨论几种最基本的数据结构：</p>
<h1 id="表-ADT"><a href="#表-ADT" class="headerlink" title="表 ADT"></a>表 ADT</h1><p>现在，我们将处理一般形如$A_1,A_2,\cdots, A_n$的表，我们说这个表的大小为$n$。而$n&#x3D;0$的情况下，也就是大小为0的表我们称为空表。</p>
<p>除空表以外，我们对$ 1&lt; i &lt; n$中的元素$A_{i+1}$称为是$A_i$的后继元，而$A_{i-1}$称为$A_{i}$的前驱元。表中的第一个元素是$A_1$，最后一个元素是$A_n$。对于这两个元素，前者不定义前驱元，后者不定义后继元，因为这是没有意义的。为了简单的讨论，我们现在只假设表中的元素是整数。</p>
<p>跟这些定义相关的是我们要在表ADT上就行的操作的集合，例如 <strong>PrintList</strong>和<strong>MakeEmpty</strong>。第一个是打印表的元素，第二个是创造一个空表。接着我们定义<strong>Find</strong> 表示返回特定关键字首次出现的位置。而<strong>Insert</strong>和<strong>Delete</strong>表示插入元素在指定位置和删除某个关键字。接着，我们记 <strong>FindKth</strong>返回某个元素的位置，例如FindKth($A_3$)返回3。若34,12,52,16,12是一个表，则Find(52)返回3；Insert(X,3)则把表变为34,12,X,52,16,12。而Delet(52)则把表变成34,12,X,16,12。</p>
<h2 id="表的简单数组实现"><a href="#表的简单数组实现" class="headerlink" title="表的简单数组实现"></a>表的简单数组实现</h2><p>对表的所有操作都可以通过数组来实现，虽然数组是动态指定的，但我们还是得对表的最大值进行估计。</p>
<p>数组的实现使得 <strong>PrintList</strong>和 <strong>Find</strong>是呈线性时间运行的，而 <strong>FindKth</strong>花费常数时间。但是插入和删除则花费更多的时间。比如插入，我们在位置0插入一个值，则首先需要将数组后移一个位置空出空间，而删除第一个元素需要将表中的元素全部向前移动一个单位，所以这两种最坏的情况都是O(N)的。所以在数组上建表其实是一种比较浪费资源的事情。</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>为了避免插入和删除的线性开销，我们需要允许表可以不连续储存。否则表的部分或者全部都需要整体移动。现在给出一个链表（ <strong>linked list</strong>）的一般想法：</p>
<center>

<p><img style="border-radius: 0.3125em;
                box-shadow: 0 2px 4px 0 rgba(34,36,38,.12), 0 2px 10px 0 rgba(34,36,38,.08);
                border: 10px solid transparent;
                margin-bottom: 20px"
        src="https://i.upmath.me/svg/%5Ctikzset%7Bevery%20picture%2F.style%3D%7Bline%20width%3D0.75pt%7D%7D%20%25set%20default%20line%20width%20to%200.75pt%20%20%20%20%20%20%20%20%0A%0A%5Cbegin%7Btikzpicture%7D%5Bx%3D0.75pt%2Cy%3D0.75pt%2Cyscale%3D-1%2Cxscale%3D1%5D%0A%25uncomment%20if%20require%3A%20%5Cpath%20(0%2C300)%3B%20%25set%20diagram%20left%20start%20at%200%2C%20and%20has%20height%20of%20300%0A%0A%25Shape%3A%20Rectangle%20%5Bid%3Adp8685412453588284%5D%20%0A%5Cdraw%20%20%20(83%2C93)%20--%20(133.33%2C93)%20--%20(133.33%2C118.67)%20--%20(83%2C118.67)%20--%20cycle%20%3B%0A%25Straight%20Lines%20%5Bid%3Ada2924787203268844%5D%20%0A%5Cdraw%20%20%20%20(115%2C93)%20--%20(115%2C120.67)%20%3B%0A%0A%25Shape%3A%20Rectangle%20%5Bid%3Adp23953376359227185%5D%20%0A%5Cdraw%20%20%20(173%2C93)%20--%20(223.33%2C93)%20--%20(223.33%2C118.67)%20--%20(173%2C118.67)%20--%20cycle%20%3B%0A%25Straight%20Lines%20%5Bid%3Ada19475134989952791%5D%20%0A%5Cdraw%20%20%20%20(205%2C93)%20--%20(205%2C120.67)%20%3B%0A%0A%25Shape%3A%20Rectangle%20%5Bid%3Adp4299481344913403%5D%20%0A%5Cdraw%20%20%20(259%2C93.19)%20--%20(309.33%2C93.19)%20--%20(309.33%2C118.68)%20--%20(259%2C118.68)%20--%20cycle%20%3B%0A%25Straight%20Lines%20%5Bid%3Ada6439366692998871%5D%20%0A%5Cdraw%20%20%20%20(291%2C93.19)%20--%20(291%2C120.67)%20%3B%0A%0A%25Shape%3A%20Rectangle%20%5Bid%3Adp43933548186680627%5D%20%0A%5Cdraw%20%20%20(346%2C93)%20--%20(396.33%2C93)%20--%20(396.33%2C118.67)%20--%20(346%2C118.67)%20--%20cycle%20%3B%0A%25Straight%20Lines%20%5Bid%3Ada9607504964332989%5D%20%0A%5Cdraw%20%20%20%20(378%2C93)%20--%20(378%2C120.67)%20%3B%0A%0A%25Shape%3A%20Rectangle%20%5Bid%3Adp9171375634741383%5D%20%0A%5Cdraw%20%20%20(437%2C93)%20--%20(487.33%2C93)%20--%20(487.33%2C118.67)%20--%20(437%2C118.67)%20--%20cycle%20%3B%0A%25Straight%20Lines%20%5Bid%3Ada09955567487572092%5D%20%0A%5Cdraw%20%20%20%20(469%2C93)%20--%20(469%2C120.67)%20%3B%0A%0A%25Straight%20Lines%20%5Bid%3Ada8225271136365326%5D%20%0A%5Cdraw%20%20%20%20(134%2C106)%20--%20(168.39%2C106)%20%3B%0A%5Cdraw%20%5Bshift%3D%7B(170.39%2C106)%7D%2C%20rotate%20%3D%20180%5D%20%5Bcolor%3D%7Brgb%2C%20255%3Ared%2C%200%3B%20green%2C%200%3B%20blue%2C%200%20%7D%20%20%5D%5Bline%20width%3D0.75%5D%20%20%20%20(10.93%2C-3.29)%20..%20controls%20(6.95%2C-1.4)%20and%20(3.31%2C-0.3)%20..%20(0%2C0)%20..%20controls%20(3.31%2C0.3)%20and%20(6.95%2C1.4)%20..%20(10.93%2C3.29)%20%20%20%3B%0A%25Straight%20Lines%20%5Bid%3Ada03167607141309481%5D%20%0A%5Cdraw%20%20%20%20(224%2C107)%20--%20(258.39%2C107)%20%3B%0A%5Cdraw%20%5Bshift%3D%7B(260.39%2C107)%7D%2C%20rotate%20%3D%20180%5D%20%5Bcolor%3D%7Brgb%2C%20255%3Ared%2C%200%3B%20green%2C%200%3B%20blue%2C%200%20%7D%20%20%5D%5Bline%20width%3D0.75%5D%20%20%20%20(10.93%2C-3.29)%20..%20controls%20(6.95%2C-1.4)%20and%20(3.31%2C-0.3)%20..%20(0%2C0)%20..%20controls%20(3.31%2C0.3)%20and%20(6.95%2C1.4)%20..%20(10.93%2C3.29)%20%20%20%3B%0A%25Straight%20Lines%20%5Bid%3Ada9576619970510003%5D%20%0A%5Cdraw%20%20%20%20(310%2C106)%20--%20(344.39%2C106)%20%3B%0A%5Cdraw%20%5Bshift%3D%7B(346.39%2C106)%7D%2C%20rotate%20%3D%20180%5D%20%5Bcolor%3D%7Brgb%2C%20255%3Ared%2C%200%3B%20green%2C%200%3B%20blue%2C%200%20%7D%20%20%5D%5Bline%20width%3D0.75%5D%20%20%20%20(10.93%2C-3.29)%20..%20controls%20(6.95%2C-1.4)%20and%20(3.31%2C-0.3)%20..%20(0%2C0)%20..%20controls%20(3.31%2C0.3)%20and%20(6.95%2C1.4)%20..%20(10.93%2C3.29)%20%20%20%3B%0A%25Straight%20Lines%20%5Bid%3Ada963313497337551%5D%20%0A%5Cdraw%20%20%20%20(398%2C106)%20--%20(432.39%2C106)%20%3B%0A%5Cdraw%20%5Bshift%3D%7B(434.39%2C106)%7D%2C%20rotate%20%3D%20180%5D%20%5Bcolor%3D%7Brgb%2C%20255%3Ared%2C%200%3B%20green%2C%200%3B%20blue%2C%200%20%7D%20%20%5D%5Bline%20width%3D0.75%5D%20%20%20%20(10.93%2C-3.29)%20..%20controls%20(6.95%2C-1.4)%20and%20(3.31%2C-0.3)%20..%20(0%2C0)%20..%20controls%20(3.31%2C0.3)%20and%20(6.95%2C1.4)%20..%20(10.93%2C3.29)%20%20%20%3B%0A%0A%25%20Text%20Node%0A%5Cdraw%20(89%2C100.4)%20node%20%5Banchor%3Dnorth%20west%5D%5Binner%20sep%3D0.75pt%5D%20%20%20%20%7B%24A_%7B1%7D%24%7D%3B%0A%25%20Text%20Node%0A%5Cdraw%20(180%2C100.4)%20node%20%5Banchor%3Dnorth%20west%5D%5Binner%20sep%3D0.75pt%5D%20%20%20%20%7B%24A_%7B2%7D%24%7D%3B%0A%25%20Text%20Node%0A%5Cdraw%20(267%2C98.4)%20node%20%5Banchor%3Dnorth%20west%5D%5Binner%20sep%3D0.75pt%5D%20%20%20%20%7B%24A_%7B3%7D%24%7D%3B%0A%25%20Text%20Node%0A%5Cdraw%20(354%2C96.4)%20node%20%5Banchor%3Dnorth%20west%5D%5Binner%20sep%3D0.75pt%5D%20%20%20%20%7B%24A_%7B4%7D%24%7D%3B%0A%25%20Text%20Node%0A%5Cdraw%20(439%2C96.4)%20node%20%5Banchor%3Dnorth%20west%5D%5Binner%20sep%3D0.75pt%5D%20%20%20%20%7B%24A_%7B5%7D%24%7D%3B%0A%0A%0A%5Cend%7Btikzpicture%7D
" width="60%"></p>
</center>

<p>链表由一系列不必在内存中相连的结构组成，每个结构均含有表元素和指向包含改元素后继元的结构的指针。我们称为Next指针，最后一个单元的Next指向 NULL。</p>
<center>

<p><img style="border-radius: 0.3125em;
                box-shadow: 0 2px 4px 0 rgba(34,36,38,.12), 0 2px 10px 0 rgba(34,36,38,.08);
                border: 10px solid transparent;
                margin-bottom: 20px"
        src="https://i.upmath.me/svg/%5Ctikzset%7Bevery%20picture%2F.style%3D%7Bline%20width%3D0.75pt%7D%7D%20%25set%20default%20line%20width%20to%200.75pt%20%20%20%20%20%20%20%20%0A%0A%5Cbegin%7Btikzpicture%7D%5Bx%3D0.75pt%2Cy%3D0.75pt%2Cyscale%3D-1%2Cxscale%3D1%5D%0A%25uncomment%20if%20require%3A%20%5Cpath%20(0%2C300)%3B%20%25set%20diagram%20left%20start%20at%200%2C%20and%20has%20height%20of%20300%0A%0A%25Shape%3A%20Rectangle%20%5Bid%3Adp8685412453588284%5D%20%0A%5Cdraw%20%20%20(83%2C93)%20--%20(133.33%2C93)%20--%20(133.33%2C118.67)%20--%20(83%2C118.67)%20--%20cycle%20%3B%0A%25Straight%20Lines%20%5Bid%3Ada2924787203268844%5D%20%0A%5Cdraw%20%20%20%20(115%2C93)%20--%20(115%2C120.67)%20%3B%0A%0A%25Shape%3A%20Rectangle%20%5Bid%3Adp23953376359227185%5D%20%0A%5Cdraw%20%20%20(173%2C93)%20--%20(223.33%2C93)%20--%20(223.33%2C118.67)%20--%20(173%2C118.67)%20--%20cycle%20%3B%0A%25Straight%20Lines%20%5Bid%3Ada19475134989952791%5D%20%0A%5Cdraw%20%20%20%20(205%2C93)%20--%20(205%2C120.67)%20%3B%0A%0A%25Shape%3A%20Rectangle%20%5Bid%3Adp4299481344913403%5D%20%0A%5Cdraw%20%20%20(259%2C93.19)%20--%20(309.33%2C93.19)%20--%20(309.33%2C118.68)%20--%20(259%2C118.68)%20--%20cycle%20%3B%0A%25Straight%20Lines%20%5Bid%3Ada6439366692998871%5D%20%0A%5Cdraw%20%20%20%20(291%2C93.19)%20--%20(291%2C120.67)%20%3B%0A%0A%25Shape%3A%20Rectangle%20%5Bid%3Adp43933548186680627%5D%20%0A%5Cdraw%20%20%20(346%2C93)%20--%20(396.33%2C93)%20--%20(396.33%2C118.67)%20--%20(346%2C118.67)%20--%20cycle%20%3B%0A%25Straight%20Lines%20%5Bid%3Ada9607504964332989%5D%20%0A%5Cdraw%20%20%20%20(378%2C93)%20--%20(378%2C120.67)%20%3B%0A%0A%25Shape%3A%20Rectangle%20%5Bid%3Adp9171375634741383%5D%20%0A%5Cdraw%20%20%20(437%2C93)%20--%20(487.33%2C93)%20--%20(487.33%2C118.67)%20--%20(437%2C118.67)%20--%20cycle%20%3B%0A%25Straight%20Lines%20%5Bid%3Ada09955567487572092%5D%20%0A%5Cdraw%20%20%20%20(469%2C93)%20--%20(469%2C120.67)%20%3B%0A%0A%0A%25%20Text%20Node%0A%5Cdraw%20(89%2C100.4)%20node%20%5Banchor%3Dnorth%20west%5D%5Binner%20sep%3D0.75pt%5D%20%20%20%20%7B%24A_%7B1%7D%24%7D%3B%0A%25%20Text%20Node%0A%5Cdraw%20(180%2C100.4)%20node%20%5Banchor%3Dnorth%20west%5D%5Binner%20sep%3D0.75pt%5D%20%20%20%20%7B%24A_%7B2%7D%24%7D%3B%0A%25%20Text%20Node%0A%5Cdraw%20(267%2C98.4)%20node%20%5Banchor%3Dnorth%20west%5D%5Binner%20sep%3D0.75pt%5D%20%20%20%20%7B%24A_%7B3%7D%24%7D%3B%0A%25%20Text%20Node%0A%5Cdraw%20(354%2C96.4)%20node%20%5Banchor%3Dnorth%20west%5D%5Binner%20sep%3D0.75pt%5D%20%20%20%20%7B%24A_%7B4%7D%24%7D%3B%0A%25%20Text%20Node%0A%5Cdraw%20(439%2C96.4)%20node%20%5Banchor%3Dnorth%20west%5D%5Binner%20sep%3D0.75pt%5D%20%20%20%20%7B%24A_%7B5%7D%24%7D%3B%0A%25%20Text%20Node%0A%5Cdraw%20(117%2C103)%20node%20%5Banchor%3Dnorth%20west%5D%5Binner%20sep%3D0.75pt%5D%20%20%5Bfont%3D%5Ctiny%5D%20%5Balign%3Dleft%5D%20%7B800%7D%3B%0A%25%20Text%20Node%0A%5Cdraw%20(100%2C128)%20node%20%5Banchor%3Dnorth%20west%5D%5Binner%20sep%3D0.75pt%5D%20%20%5Bfont%3D%5Ctiny%5D%20%5Balign%3Dleft%5D%20%7B1000%7D%3B%0A%25%20Text%20Node%0A%5Cdraw%20(208%2C104)%20node%20%5Banchor%3Dnorth%20west%5D%5Binner%20sep%3D0.75pt%5D%20%20%5Bfont%3D%5Ctiny%5D%20%5Balign%3Dleft%5D%20%7B712%7D%3B%0A%25%20Text%20Node%0A%5Cdraw%20(191%2C130)%20node%20%5Banchor%3Dnorth%20west%5D%5Binner%20sep%3D0.75pt%5D%20%20%5Bfont%3D%5Ctiny%5D%20%5Balign%3Dleft%5D%20%7B800%7D%3B%0A%25%20Text%20Node%0A%5Cdraw%20(281%2C126)%20node%20%5Banchor%3Dnorth%20west%5D%5Binner%20sep%3D0.75pt%5D%20%20%5Bfont%3D%5Ctiny%5D%20%5Balign%3Dleft%5D%20%7B712%7D%3B%0A%25%20Text%20Node%0A%5Cdraw%20(292%2C104.93)%20node%20%5Banchor%3Dnorth%20west%5D%5Binner%20sep%3D0.75pt%5D%20%20%5Bfont%3D%5Ctiny%5D%20%5Balign%3Dleft%5D%20%7B992%7D%3B%0A%25%20Text%20Node%0A%5Cdraw%20(367%2C127)%20node%20%5Banchor%3Dnorth%20west%5D%5Binner%20sep%3D0.75pt%5D%20%20%5Bfont%3D%5Ctiny%5D%20%5Balign%3Dleft%5D%20%7B992%7D%3B%0A%25%20Text%20Node%0A%5Cdraw%20(379%2C103)%20node%20%5Banchor%3Dnorth%20west%5D%5Binner%20sep%3D0.75pt%5D%20%20%5Bfont%3D%5Ctiny%5D%20%5Balign%3Dleft%5D%20%7B692%7D%3B%0A%25%20Text%20Node%0A%5Cdraw%20(455%2C128)%20node%20%5Banchor%3Dnorth%20west%5D%5Binner%20sep%3D0.75pt%5D%20%20%5Bfont%3D%5Ctiny%5D%20%5Balign%3Dleft%5D%20%7B692%7D%3B%0A%25%20Text%20Node%0A%5Cdraw%20(476%2C103)%20node%20%5Banchor%3Dnorth%20west%5D%5Binner%20sep%3D0.75pt%5D%20%20%5Bfont%3D%5Ctiny%5D%20%5Balign%3Dleft%5D%20%7B0%7D%3B%0A%0A%0A%5Cend%7Btikzpicture%7D
" width="60%"></p>
</center>

<p>若P声明为指向一个结构的指针，那么P中的值就是主存中的一个位置，通过该位置就可以找到一个结构，该结构可以通过P -&gt; FieldName访问。其中FieldName是我们想要考察的域的名字。例如上图，这个表有5个结构，恰好内存中分配的地址是1000,800,712,992,692.第一个结构的指针含有800，它提供了第二个指针的位置。其余每个结构也也有一个指针用于类似的目的，而指针只是一个数，在后面我们用箭头画出指针即可，因为这样更直观。</p>
<p>删除命令可以通过修改一个指针实现，例如下图：</p>
<center>

<p><img style="border-radius: 0.3125em;
                box-shadow: 0 2px 4px 0 rgba(34,36,38,.12), 0 2px 10px 0 rgba(34,36,38,.08);
                border: 10px solid transparent;
                margin-bottom: 20px"
        src="https://i.upmath.me/svg/%5Ctikzset%7Bevery%20picture%2F.style%3D%7Bline%20width%3D0.75pt%7D%7D%20%25set%20default%20line%20width%20to%200.75pt%20%20%20%20%20%20%20%20%0A%0A%5Cbegin%7Btikzpicture%7D%5Bx%3D0.75pt%2Cy%3D0.75pt%2Cyscale%3D-1%2Cxscale%3D1%5D%0A%25uncomment%20if%20require%3A%20%5Cpath%20(0%2C300)%3B%20%25set%20diagram%20left%20start%20at%200%2C%20and%20has%20height%20of%20300%0A%0A%25Shape%3A%20Rectangle%20%5Bid%3Adp8685412453588284%5D%20%0A%5Cdraw%20%20%20(83%2C93)%20--%20(133.33%2C93)%20--%20(133.33%2C118.67)%20--%20(83%2C118.67)%20--%20cycle%20%3B%0A%25Straight%20Lines%20%5Bid%3Ada2924787203268844%5D%20%0A%5Cdraw%20%20%20%20(115%2C93)%20--%20(115%2C120.67)%20%3B%0A%0A%25Shape%3A%20Rectangle%20%5Bid%3Adp23953376359227185%5D%20%0A%5Cdraw%20%20%20(173%2C93)%20--%20(223.33%2C93)%20--%20(223.33%2C118.67)%20--%20(173%2C118.67)%20--%20cycle%20%3B%0A%25Straight%20Lines%20%5Bid%3Ada19475134989952791%5D%20%0A%5Cdraw%20%20%20%20(205%2C93)%20--%20(205%2C120.67)%20%3B%0A%0A%25Shape%3A%20Rectangle%20%5Bid%3Adp4299481344913403%5D%20%0A%5Cdraw%20%20%20(259%2C93.19)%20--%20(309.33%2C93.19)%20--%20(309.33%2C118.68)%20--%20(259%2C118.68)%20--%20cycle%20%3B%0A%25Straight%20Lines%20%5Bid%3Ada6439366692998871%5D%20%0A%5Cdraw%20%20%20%20(291%2C93.19)%20--%20(291%2C120.67)%20%3B%0A%0A%25Shape%3A%20Rectangle%20%5Bid%3Adp43933548186680627%5D%20%0A%5Cdraw%20%20%20(346%2C93)%20--%20(396.33%2C93)%20--%20(396.33%2C118.67)%20--%20(346%2C118.67)%20--%20cycle%20%3B%0A%25Straight%20Lines%20%5Bid%3Ada9607504964332989%5D%20%0A%5Cdraw%20%20%20%20(378%2C93)%20--%20(378%2C120.67)%20%3B%0A%0A%25Shape%3A%20Rectangle%20%5Bid%3Adp9171375634741383%5D%20%0A%5Cdraw%20%20%20(437%2C93)%20--%20(487.33%2C93)%20--%20(487.33%2C118.67)%20--%20(437%2C118.67)%20--%20cycle%20%3B%0A%25Straight%20Lines%20%5Bid%3Ada09955567487572092%5D%20%0A%5Cdraw%20%20%20%20(469%2C93)%20--%20(469%2C120.67)%20%3B%0A%0A%25Straight%20Lines%20%5Bid%3Ada8225271136365326%5D%20%0A%5Cdraw%20%20%20%20(134%2C106)%20--%20(168.39%2C106)%20%3B%0A%5Cdraw%20%5Bshift%3D%7B(170.39%2C106)%7D%2C%20rotate%20%3D%20180%5D%20%5Bcolor%3D%7Brgb%2C%20255%3Ared%2C%200%3B%20green%2C%200%3B%20blue%2C%200%20%7D%20%20%5D%5Bline%20width%3D0.75%5D%20%20%20%20(10.93%2C-3.29)%20..%20controls%20(6.95%2C-1.4)%20and%20(3.31%2C-0.3)%20..%20(0%2C0)%20..%20controls%20(3.31%2C0.3)%20and%20(6.95%2C1.4)%20..%20(10.93%2C3.29)%20%20%20%3B%0A%25Straight%20Lines%20%5Bid%3Ada03167607141309481%5D%20%0A%5Cdraw%20%20%5Bdash%20pattern%3D%7Bon%200.84pt%20off%202.51pt%7D%5D%20%20(224%2C107)%20--%20(258.39%2C107)%20%3B%0A%5Cdraw%20%5Bshift%3D%7B(260.39%2C107)%7D%2C%20rotate%20%3D%20180%5D%20%5Bcolor%3D%7Brgb%2C%20255%3Ared%2C%200%3B%20green%2C%200%3B%20blue%2C%200%20%7D%20%20%5D%5Bline%20width%3D0.75%5D%20%20%20%20(10.93%2C-3.29)%20..%20controls%20(6.95%2C-1.4)%20and%20(3.31%2C-0.3)%20..%20(0%2C0)%20..%20controls%20(3.31%2C0.3)%20and%20(6.95%2C1.4)%20..%20(10.93%2C3.29)%20%20%20%3B%0A%25Straight%20Lines%20%5Bid%3Ada9576619970510003%5D%20%0A%5Cdraw%20%20%20%20(310%2C106)%20--%20(344.39%2C106)%20%3B%0A%5Cdraw%20%5Bshift%3D%7B(346.39%2C106)%7D%2C%20rotate%20%3D%20180%5D%20%5Bcolor%3D%7Brgb%2C%20255%3Ared%2C%200%3B%20green%2C%200%3B%20blue%2C%200%20%7D%20%20%5D%5Bline%20width%3D0.75%5D%20%20%20%20(10.93%2C-3.29)%20..%20controls%20(6.95%2C-1.4)%20and%20(3.31%2C-0.3)%20..%20(0%2C0)%20..%20controls%20(3.31%2C0.3)%20and%20(6.95%2C1.4)%20..%20(10.93%2C3.29)%20%20%20%3B%0A%25Straight%20Lines%20%5Bid%3Ada963313497337551%5D%20%0A%5Cdraw%20%20%20%20(398%2C106)%20--%20(432.39%2C106)%20%3B%0A%5Cdraw%20%5Bshift%3D%7B(434.39%2C106)%7D%2C%20rotate%20%3D%20180%5D%20%5Bcolor%3D%7Brgb%2C%20255%3Ared%2C%200%3B%20green%2C%200%3B%20blue%2C%200%20%7D%20%20%5D%5Bline%20width%3D0.75%5D%20%20%20%20(10.93%2C-3.29)%20..%20controls%20(6.95%2C-1.4)%20and%20(3.31%2C-0.3)%20..%20(0%2C0)%20..%20controls%20(3.31%2C0.3)%20and%20(6.95%2C1.4)%20..%20(10.93%2C3.29)%20%20%20%3B%0A%25Curve%20Lines%20%5Bid%3Ada5940988043363349%5D%20%0A%5Cdraw%20%20%20%20(232%2C86)%20..%20controls%20(271.6%2C56.3)%20and%20(292.96%2C56.19)%20..%20(338.99%2C87.24)%20%3B%0A%5Cdraw%20%5Bshift%3D%7B(340.39%2C88.19)%7D%2C%20rotate%20%3D%20214.25%5D%20%5Bcolor%3D%7Brgb%2C%20255%3Ared%2C%200%3B%20green%2C%200%3B%20blue%2C%200%20%7D%20%20%5D%5Bline%20width%3D0.75%5D%20%20%20%20(10.93%2C-3.29)%20..%20controls%20(6.95%2C-1.4)%20and%20(3.31%2C-0.3)%20..%20(0%2C0)%20..%20controls%20(3.31%2C0.3)%20and%20(6.95%2C1.4)%20..%20(10.93%2C3.29)%20%20%20%3B%0A%0A%25%20Text%20Node%0A%5Cdraw%20(89%2C100.4)%20node%20%5Banchor%3Dnorth%20west%5D%5Binner%20sep%3D0.75pt%5D%20%20%20%20%7B%24A_%7B1%7D%24%7D%3B%0A%25%20Text%20Node%0A%5Cdraw%20(180%2C100.4)%20node%20%5Banchor%3Dnorth%20west%5D%5Binner%20sep%3D0.75pt%5D%20%20%20%20%7B%24A_%7B2%7D%24%7D%3B%0A%25%20Text%20Node%0A%5Cdraw%20(267%2C98.4)%20node%20%5Banchor%3Dnorth%20west%5D%5Binner%20sep%3D0.75pt%5D%20%20%20%20%7B%24A_%7B3%7D%24%7D%3B%0A%25%20Text%20Node%0A%5Cdraw%20(354%2C96.4)%20node%20%5Banchor%3Dnorth%20west%5D%5Binner%20sep%3D0.75pt%5D%20%20%20%20%7B%24A_%7B4%7D%24%7D%3B%0A%25%20Text%20Node%0A%5Cdraw%20(439%2C96.4)%20node%20%5Banchor%3Dnorth%20west%5D%5Binner%20sep%3D0.75pt%5D%20%20%20%20%7B%24A_%7B5%7D%24%7D%3B%0A%0A%0A%5Cend%7Btikzpicture%7D," width="60%"></p>
</center>

<p>而插入命令需要通过一次 malloc 调用动态的从系统得到一个新单元，如何执行两次指针调整，一般想法如下图给出：</p>
<center>

<p><img style="border-radius: 0.3125em;
                box-shadow: 0 2px 4px 0 rgba(34,36,38,.12), 0 2px 10px 0 rgba(34,36,38,.08);
                border: 10px solid transparent;
                margin-bottom: 20px"
        src="https://i.upmath.me/svg/%5Ctikzset%7Bevery%20picture%2F.style%3D%7Bline%20width%3D0.75pt%7D%7D%20%25set%20default%20line%20width%20to%200.75pt%20%20%20%20%20%20%20%20%0A%0A%5Cbegin%7Btikzpicture%7D%5Bx%3D0.75pt%2Cy%3D0.75pt%2Cyscale%3D-1%2Cxscale%3D1%5D%0A%25uncomment%20if%20require%3A%20%5Cpath%20(0%2C300)%3B%20%25set%20diagram%20left%20start%20at%200%2C%20and%20has%20height%20of%20300%0A%0A%25Shape%3A%20Rectangle%20%5Bid%3Adp8685412453588284%5D%20%0A%5Cdraw%20%20%20(83%2C93)%20--%20(133.33%2C93)%20--%20(133.33%2C118.67)%20--%20(83%2C118.67)%20--%20cycle%20%3B%0A%25Straight%20Lines%20%5Bid%3Ada2924787203268844%5D%20%0A%5Cdraw%20%20%20%20(115%2C93)%20--%20(115%2C120.67)%20%3B%0A%0A%25Shape%3A%20Rectangle%20%5Bid%3Adp23953376359227185%5D%20%0A%5Cdraw%20%20%20(173%2C93)%20--%20(223.33%2C93)%20--%20(223.33%2C118.67)%20--%20(173%2C118.67)%20--%20cycle%20%3B%0A%25Straight%20Lines%20%5Bid%3Ada19475134989952791%5D%20%0A%5Cdraw%20%20%20%20(205%2C93)%20--%20(205%2C120.67)%20%3B%0A%0A%25Shape%3A%20Rectangle%20%5Bid%3Adp4299481344913403%5D%20%0A%5Cdraw%20%20%20(335%2C92.19)%20--%20(385.33%2C92.19)%20--%20(385.33%2C117.68)%20--%20(335%2C117.68)%20--%20cycle%20%3B%0A%25Straight%20Lines%20%5Bid%3Ada6439366692998871%5D%20%0A%5Cdraw%20%20%20%20(367%2C92.19)%20--%20(367%2C119.67)%20%3B%0A%0A%25Shape%3A%20Rectangle%20%5Bid%3Adp43933548186680627%5D%20%0A%5Cdraw%20%20%20(422%2C92)%20--%20(472.33%2C92)%20--%20(472.33%2C117.67)%20--%20(422%2C117.67)%20--%20cycle%20%3B%0A%25Straight%20Lines%20%5Bid%3Ada9607504964332989%5D%20%0A%5Cdraw%20%20%20%20(454%2C92)%20--%20(454%2C119.67)%20%3B%0A%0A%25Shape%3A%20Rectangle%20%5Bid%3Adp9171375634741383%5D%20%0A%5Cdraw%20%20%20(513%2C92)%20--%20(563.33%2C92)%20--%20(563.33%2C117.67)%20--%20(513%2C117.67)%20--%20cycle%20%3B%0A%25Straight%20Lines%20%5Bid%3Ada09955567487572092%5D%20%0A%5Cdraw%20%20%20%20(545%2C92)%20--%20(545%2C119.67)%20%3B%0A%0A%25Straight%20Lines%20%5Bid%3Ada8225271136365326%5D%20%0A%5Cdraw%20%20%20%20(134%2C106)%20--%20(168.39%2C106)%20%3B%0A%5Cdraw%20%5Bshift%3D%7B(170.39%2C106)%7D%2C%20rotate%20%3D%20180%5D%20%5Bcolor%3D%7Brgb%2C%20255%3Ared%2C%200%3B%20green%2C%200%3B%20blue%2C%200%20%7D%20%20%5D%5Bline%20width%3D0.75%5D%20%20%20%20(10.93%2C-3.29)%20..%20controls%20(6.95%2C-1.4)%20and%20(3.31%2C-0.3)%20..%20(0%2C0)%20..%20controls%20(3.31%2C0.3)%20and%20(6.95%2C1.4)%20..%20(10.93%2C3.29)%20%20%20%3B%0A%25Straight%20Lines%20%5Bid%3Ada03167607141309481%5D%20%0A%5Cdraw%20%20%5Bdash%20pattern%3D%7Bon%200.84pt%20off%202.51pt%7D%5D%20%20(224%2C107)%20--%20(321.39%2C106.2)%20%3B%0A%5Cdraw%20%5Bshift%3D%7B(323.39%2C106.19)%7D%2C%20rotate%20%3D%20179.53%5D%20%5Bcolor%3D%7Brgb%2C%20255%3Ared%2C%200%3B%20green%2C%200%3B%20blue%2C%200%20%7D%20%20%5D%5Bline%20width%3D0.75%5D%20%20%20%20(10.93%2C-3.29)%20..%20controls%20(6.95%2C-1.4)%20and%20(3.31%2C-0.3)%20..%20(0%2C0)%20..%20controls%20(3.31%2C0.3)%20and%20(6.95%2C1.4)%20..%20(10.93%2C3.29)%20%20%20%3B%0A%25Straight%20Lines%20%5Bid%3Ada9576619970510003%5D%20%0A%5Cdraw%20%20%20%20(386%2C105)%20--%20(420.39%2C105)%20%3B%0A%5Cdraw%20%5Bshift%3D%7B(422.39%2C105)%7D%2C%20rotate%20%3D%20180%5D%20%5Bcolor%3D%7Brgb%2C%20255%3Ared%2C%200%3B%20green%2C%200%3B%20blue%2C%200%20%7D%20%20%5D%5Bline%20width%3D0.75%5D%20%20%20%20(10.93%2C-3.29)%20..%20controls%20(6.95%2C-1.4)%20and%20(3.31%2C-0.3)%20..%20(0%2C0)%20..%20controls%20(3.31%2C0.3)%20and%20(6.95%2C1.4)%20..%20(10.93%2C3.29)%20%20%20%3B%0A%25Straight%20Lines%20%5Bid%3Ada963313497337551%5D%20%0A%5Cdraw%20%20%20%20(474%2C105)%20--%20(508.39%2C105)%20%3B%0A%5Cdraw%20%5Bshift%3D%7B(510.39%2C105)%7D%2C%20rotate%20%3D%20180%5D%20%5Bcolor%3D%7Brgb%2C%20255%3Ared%2C%200%3B%20green%2C%200%3B%20blue%2C%200%20%7D%20%20%5D%5Bline%20width%3D0.75%5D%20%20%20%20(10.93%2C-3.29)%20..%20controls%20(6.95%2C-1.4)%20and%20(3.31%2C-0.3)%20..%20(0%2C0)%20..%20controls%20(3.31%2C0.3)%20and%20(6.95%2C1.4)%20..%20(10.93%2C3.29)%20%20%20%3B%0A%25Shape%3A%20Rectangle%20%5Bid%3Adp09844710560424663%5D%20%0A%5Cdraw%20%20%20(240%2C153)%20--%20(300.39%2C153)%20--%20(300.39%2C182.19)%20--%20(240%2C182.19)%20--%20cycle%20%3B%0A%25Straight%20Lines%20%5Bid%3Ada5427351175215294%5D%20%0A%5Cdraw%20%20%20%20(284%2C154)%20--%20(284%2C180.19)%20%3B%0A%25Straight%20Lines%20%5Bid%3Ada07461142976815816%5D%20%0A%5Cdraw%20%20%20%20(224%2C107)%20--%20(237.69%2C143.32)%20%3B%0A%5Cdraw%20%5Bshift%3D%7B(238.39%2C145.19)%7D%2C%20rotate%20%3D%20249.35%5D%20%5Bcolor%3D%7Brgb%2C%20255%3Ared%2C%200%3B%20green%2C%200%3B%20blue%2C%200%20%7D%20%20%5D%5Bline%20width%3D0.75%5D%20%20%20%20(10.93%2C-3.29)%20..%20controls%20(6.95%2C-1.4)%20and%20(3.31%2C-0.3)%20..%20(0%2C0)%20..%20controls%20(3.31%2C0.3)%20and%20(6.95%2C1.4)%20..%20(10.93%2C3.29)%20%20%20%3B%0A%25Straight%20Lines%20%5Bid%3Ada2206194336005527%5D%20%0A%5Cdraw%20%20%20%20(296%2C165)%20--%20(326.3%2C118.86)%20%3B%0A%5Cdraw%20%5Bshift%3D%7B(327.39%2C117.19)%7D%2C%20rotate%20%3D%20123.29%5D%20%5Bcolor%3D%7Brgb%2C%20255%3Ared%2C%200%3B%20green%2C%200%3B%20blue%2C%200%20%7D%20%20%5D%5Bline%20width%3D0.75%5D%20%20%20%20(10.93%2C-3.29)%20..%20controls%20(6.95%2C-1.4)%20and%20(3.31%2C-0.3)%20..%20(0%2C0)%20..%20controls%20(3.31%2C0.3)%20and%20(6.95%2C1.4)%20..%20(10.93%2C3.29)%20%20%20%3B%0A%0A%25%20Text%20Node%0A%5Cdraw%20(89%2C100.4)%20node%20%5Banchor%3Dnorth%20west%5D%5Binner%20sep%3D0.75pt%5D%20%20%20%20%7B%24A_%7B1%7D%24%7D%3B%0A%25%20Text%20Node%0A%5Cdraw%20(180%2C100.4)%20node%20%5Banchor%3Dnorth%20west%5D%5Binner%20sep%3D0.75pt%5D%20%20%20%20%7B%24A_%7B2%7D%24%7D%3B%0A%25%20Text%20Node%0A%5Cdraw%20(337%2C95.59)%20node%20%5Banchor%3Dnorth%20west%5D%5Binner%20sep%3D0.75pt%5D%20%20%20%20%7B%24A_%7B3%7D%24%7D%3B%0A%25%20Text%20Node%0A%5Cdraw%20(430%2C95.4)%20node%20%5Banchor%3Dnorth%20west%5D%5Binner%20sep%3D0.75pt%5D%20%20%20%20%7B%24A_%7B4%7D%24%7D%3B%0A%25%20Text%20Node%0A%5Cdraw%20(515%2C95.4)%20node%20%5Banchor%3Dnorth%20west%5D%5Binner%20sep%3D0.75pt%5D%20%20%20%20%7B%24A_%7B5%7D%24%7D%3B%0A%25%20Text%20Node%0A%5Cdraw%20(252%2C160.4)%20node%20%5Banchor%3Dnorth%20west%5D%5Binner%20sep%3D0.75pt%5D%20%20%20%20%7B%24X%24%7D%3B%0A%0A%0A%5Cend%7Btikzpicture%7D" width="60%"></p>
</center>

<h2 id="程序的设计细节"><a href="#程序的设计细节" class="headerlink" title="程序的设计细节"></a>程序的设计细节</h2><p>我们现在开始按照上述一般想法来编写一些程序。我们使用一些标志来做识别，例如表的第一个元素，我们记为 Header（表头）或哑结点（Dummy node）。不过至于要不要使用表头则是个人的兴趣问题。</p>
<p>我们定义一些抽象函数，一般来说我们会有2个文件.h和.c的文件，原型我们存放在所谓的.h头文件中，而具体的函数声明存放在.c文件中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#ifndef _List_H  // 防止头文件被多次重复定义</span><br><span class="line">#define _List_H </span><br><span class="line"></span><br><span class="line">struct Node; //声明Node结构体</span><br><span class="line">typedef struct Node *PtrToNode; //声明一个定位到Node结构的指针 PtrToNode</span><br><span class="line">typedef PtrToNode List; //定义链表类型List，表示指向表中的元素</span><br><span class="line">typedef PtrToNode Position; //定义链表的位置，表示表中某个元素的节点。</span><br><span class="line"></span><br><span class="line">List MakeEmpty(List L); //创建空列表</span><br><span class="line">int IsEmpty(List L); //判断列表是否为空</span><br><span class="line">int IsLast(Position P, List L); //是否为表中最后一个元素</span><br><span class="line">Position Find(ElementType X, List L); //查找是否含有元素X并返回位置</span><br><span class="line">void Delete(ElementType X, List L); //删除特定元素X</span><br><span class="line">Position FindPrevious(ElementType X, List L); //查找元素X的前一个元素</span><br><span class="line">void Insert(ElementType X, List L, Position P); //插入X在表中的位置P</span><br><span class="line">void DeleteList(List L); //删除整个表</span><br><span class="line">Position Header(List L); //返回头的位置</span><br><span class="line">Position First(List L); //返回第一个元素的位置</span><br><span class="line">Position Advance(Position P); //返回P的下一个位置</span><br><span class="line">ElementType Retrieve(Position P); //返回位置P的元素</span><br><span class="line"></span><br><span class="line">#endif /* _List_H */ //结束头文件保护</span><br><span class="line">/* Place in the implementation file */</span><br><span class="line">struct Node //具体Node的实现：</span><br><span class="line">&#123;</span><br><span class="line">    ElementType Element; //该结构包含一个元素Element和指向下一个节点位置的指针Next</span><br><span class="line">    Position Next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>首先第一个函数是测试表是否是空的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* Return true if L is empty */</span><br><span class="line">int IsEmpty(List L)</span><br><span class="line">&#123;</span><br><span class="line">    return L-&gt;Next == NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若表L的表头下一个元素为Null，则我们知道L是空的。</p>
<p>接着我们编写一个测试元素是否在表的末尾的函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* Return true if P is the last position in list L */</span><br><span class="line">/* Parameter L is unused in this implementation */</span><br><span class="line">int IsLast(Position P, List L)</span><br><span class="line">&#123;</span><br><span class="line">    return P-&gt;Next == NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数定义了两个输入，一个是位置P，一个是表L，若L的第P个位置的下一个指针是Null，则说明P位置的元素是最后的一个元素。</p>
<p>若我们递归的定义Find函数，则我们必须想办法避免冗长的终止条件，我们可以使用 &amp;&amp;符号，若前半部分为假，则自动终止函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* Return Position of X in L; NULL if not found */</span><br><span class="line">Position Find(ElementType X, List L)</span><br><span class="line">&#123;</span><br><span class="line">    Position P;</span><br><span class="line"></span><br><span class="line">    P = L-&gt;Next;</span><br><span class="line">    while (P != NULL &amp;&amp; P-&gt;Element != X)</span><br><span class="line">        P = P-&gt;Next;</span><br><span class="line"></span><br><span class="line">    return P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数定义了两个输入，一个是要查找的元素X，一个是表L。给定位置P，并定义P是L表头的下一个元素的地址。现在通过条件判断P是否导向NUll或者P处的元素是否等于X，若都不是，则P的指针重置为下一个元素的指针接着重新运行。</p>
<p>接着是删除函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/* Delete first occurrence of X from a list */</span><br><span class="line">/* Assume use of a header node */</span><br><span class="line"></span><br><span class="line">void Delete(ElementType X, List L)</span><br><span class="line">&#123;</span><br><span class="line">    Position P, TmpCell;</span><br><span class="line"></span><br><span class="line">    P = FindPrevious(X, L);</span><br><span class="line"></span><br><span class="line">    if (!IsLast(P, L)) /* Assumption of header use */</span><br><span class="line">    &#123;</span><br><span class="line">        TmpCell = P-&gt;Next;</span><br><span class="line">        P-&gt;Next = TmpCell-&gt;Next; /* Bypass deleted cell */</span><br><span class="line">        free(TmpCell);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给定位置P和Tmpceli，后者为储存被删除函数的临时变量。现在，定义P为X在L中的前一个元素（若存在的话），若P不是L中最后一个元素，则我们储存P的下一个元素的指针在TmpCeli。现在，重新令P的下一个元素链接到P的下一个元素再下一个元素的地址 。最后删除元素X，释放TmpCeli的内存即可完成操作。</p>
<p>上述的 <strong>FindPrevious</strong>函数如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/* If X is not found, then Next field of returned */</span><br><span class="line">/* Position is NULL */</span><br><span class="line">/* Assumes a header */</span><br><span class="line"></span><br><span class="line">Position FindPrevious(ElementType X, List L)</span><br><span class="line">&#123;</span><br><span class="line">    Position P;</span><br><span class="line"></span><br><span class="line">    P = L;</span><br><span class="line">    while (P-&gt;Next != NULL &amp;&amp; P-&gt;Next-&gt;Element != X)</span><br><span class="line">        P = P-&gt;Next;</span><br><span class="line"></span><br><span class="line">    return P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后一段代码是插入例程，我们将传入3个参数，要插入表中的元素X，表L和要插入的位置P</p>
<p>为了精准插入，我们需要调用 <strong>FindPrevious</strong>函数得知前一个值是什么。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/* Insert (after legal position P) */</span><br><span class="line">/* Header implementation assumed */</span><br><span class="line">/* Parameter L is unused in this implementation */</span><br><span class="line"></span><br><span class="line">void Insert(ElementType X, List L, Position P)</span><br><span class="line">&#123;</span><br><span class="line">    Position TmpCell;</span><br><span class="line"></span><br><span class="line">    TmpCell = malloc(sizeof(struct Node));</span><br><span class="line">    if (TmpCell == NULL)</span><br><span class="line">        FatalError(&quot;Out of space!!!&quot;);</span><br><span class="line"></span><br><span class="line">    TmpCell-&gt;Element = X;</span><br><span class="line">    TmpCell-&gt;Next = P-&gt;Next;</span><br><span class="line">    P-&gt;Next = TmpCell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数接受三个参数，要插入表的元素X，表L，还有要插入的位置P。定义临时变量TmpCeli的位置。首先，动态的分配一块内存给新的节点TmpCeli，若该元素分配为NULL，则返回分配错误。接着把X的指针储存在TmpCeli中，现在，为了完成插入操作，我们把原本在位置P的元素的下一个元素的指针分配给TmpCeli，这样就完成了对P的替换，接着，只需要把P的下一个指针指向Tmpceli，这样表就链接起来了。就成功的把X插入到P和P-next的中间。</p>
<h2 id="常见的错误"><a href="#常见的错误" class="headerlink" title="常见的错误"></a>常见的错误</h2><p>在实际的编程中，也许我们会遇到一些诸如 <strong>memory access violation</strong> 或者 <strong>segmentation violation</strong>的报错，通常情况下，这意味着指针包含了伪地址。而这样的结果来源自初始化变量失败，例如下述代码的第一行若遗漏，则P就是未定义的，的人也不可能指向内存的有效部分。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/* Incorrect DeleteList algorithm */</span><br><span class="line"></span><br><span class="line">void DeleteList(List L)</span><br><span class="line">&#123;</span><br><span class="line">    Position P;</span><br><span class="line"></span><br><span class="line">    P = L-&gt;Next; /* Header assumed */</span><br><span class="line">    L-&gt;Next = NULL;</span><br><span class="line">    while (P != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        free(P);</span><br><span class="line">        P = P-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>另一个典型的错误是上述 Insert函数遗漏了最后一行代码，若P是NULL，该指向就是非法的。但函数知道P不是NULL，所以例程不会有问题。一些编译器可能会给你做隐式检查，不过这不是c标准的一部分。所以有时候你可以在一个编译器上运行程序，在另一个编译器上则不行。</p>
<p>第二种错误涉及何时使用或者不使用malloc来获取一个新的单元。声明一个指向某结构的指针并不创建该结构，而只是给出足够的空间容纳结构可能会使用的地址。而创建尚未被声明过的记录的唯一方法就是使用malloc库函数，它会迫使系统创建一个新的结构并返回该结构的指针。</p>
<p>当你不需要这些东西的时候，你可以使用free函数来回收这段空间，free(P) 的结果是：P指向的数据是无定义的，但指针还存在。</p>
<p>当我们把free应用在链表中，那么调用free的次数应该对于表的大小，若表头存在就再加1，否则你会得到一个错误的程序。多一点你就会浪费空间也浪费时间。也许你在使用了大量空间之后，新单元的申请会返回NULL。</p>
<p>在执行一次删除表后，我们应该需要一个临时变量来储存被放弃的单元，因为你在删除后将不能引用它。所以上述free的例子不太完整，我们现在给出较完整的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/* Correct DeleteList algorithm */</span><br><span class="line"></span><br><span class="line">void DeleteList(List L)</span><br><span class="line">&#123;</span><br><span class="line">    Position P, Tmp;</span><br><span class="line"></span><br><span class="line">    P = L-&gt;Next; /* Header assumed */</span><br><span class="line">    L-&gt;Next = NULL;</span><br><span class="line">    while (P != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        Tmp = P-&gt;Next; // 先保存下一个节点</span><br><span class="line">        free(P);       // 释放当前节点</span><br><span class="line">        P = Tmp;       // 移动到下一个节点</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后提一个警告，malloc(sizeof(PtrToNode))是合法的，但是它并不给结构体分配足够的空间，它只会给指针分配一个空间。</p>
<h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><p>在某些时候，倒序扫描链表是很方便的，标准实现方法在这时候不能发挥作用，但是解决方法异常的简单，只需要在结构上附加一个域，它包含一个指向前一个单元的指针。但开销是一个附加的链。增加了空间的需求且使得插入和删除的开销增加一倍，因为有更多的指针需要定位，但简化了删除操作，因为你不再被迫使用一个指向前驱元的指针来访问一个关键字。</p>
<h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>另一个思想是，将最后一个单元反过来直指第一个单元。它可以有表头，也可以没有表头。（若存在表头，则最后的单元就指向它）并且还可以是双向的链表。下面是一个简单的流程图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A &lt;--&gt; B &lt;--&gt; C &lt;--&gt; A </span><br></pre></td></tr></table></figure>

<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>我们提供三个使用链表的例子，第一个是表示一元多项式的简单方法，第二个是在某些情况下以线性时间进行排序的方法。最后我们介绍一个复杂的例子，它讲述链表如何用于大学的课程注册。</p>
<h3 id="多项式-ADT"><a href="#多项式-ADT" class="headerlink" title="多项式 ADT"></a>多项式 ADT</h3><p>我们可以用表定义一种关于一元（具有非负次幂）多项式的抽象数据类型。令$f(x) &#x3D; \sum^n_{i&#x3D;0} a_ix^i$。若大部分系数非零，则我们可以用一个简单的数组来储存这些系数（更数学的来说，可以当作是多项式域里面的一个向量来看），然后我们可以编写一些对多项式进行加、减、乘、微分等其他操作的例程，我们将忽略初始化多项式为零的时间，则乘法例程的运行时间将和两个多项式的次数的乘机成正比。另一个问题接踵而至，若$P_1(x)$是次数为1000的多项式，而$P_2(x)$是次数为1990的多项式，那么这个时间就可能不太能接受了。因为大部分的时间都花费在了乘以0和单步调试两个输入多项式的大量不存在的部分上。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    int CoeffArray[MaxDegree + 1];</span><br><span class="line">    int HighPower;</span><br><span class="line">&#125; *Polynomial;</span><br></pre></td></tr></table></figure>

<p>我们定义了一个数组，它用来储存系数，一个是存储多项式的最高次幂。</p>
<p>然后我们来定义初始化多项式的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void ZeroPolynomial(Polynomial Poly)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for (i = 0; i &lt;= MaxDegree; i++)</span><br><span class="line">        Poly-&gt;CoeffArray[i] = 0;</span><br><span class="line">    Poly-&gt;HighPower = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该函数体通过指针设定Poly里面的数组都是0，然后初始化最高次幂为0.</p>
<p>然后我们定义多项式加法，对任意两个多项式$f,g$，则$f+g$就是对应幂次的多项式的加法：$f&#x3D;10x^2+6,g&#x3D;5x^2+10x+7$，则$f+g &#x3D; (10+5)x^2 + 10x + (6+7)$</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void AddPolynomial(const Polynomial Poly1, const Polynomial Poly2, Polynomial PolySum)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    ZeroPolynomial(PolySum);</span><br><span class="line">    PolySum-&gt;HighPower = Max(Poly1-&gt;HighPower, Poly2-&gt;HighPower);</span><br><span class="line">    for (i = PolySum-&gt;HighPower; i &gt;= 0; i--)</span><br><span class="line">        PolySum-&gt;CoeffArray[i] = Poly1-&gt;CoeffArray[i] + Poly2-&gt;CoeffArray[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个模块首先引入三个参数，多项式1，多项式2，还有多项式sum，最后是用来储存结果的多项式。接着调用zeroPolynomial函数初始化PolySum多项式。第二步，由于多项式的和最高次幂取决于谁的次数高，所以Max函数在2个幂次里面返回一个值最大的。最后是加法，把每个位置上的系数一一配对然后加起来，接着存储到PolySum里面就结束了。</p>
<p>然后是乘法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void MultiPolynomial(const Polynomial Poly1, const Polynomial Poly2, Polynomial PolyProd)</span><br><span class="line">&#123;</span><br><span class="line">    int i, j;</span><br><span class="line"></span><br><span class="line">    ZeroPolynomial(PolyProd);</span><br><span class="line">    PolyProd-&gt;HighPower = Poly1-&gt;HighPower + Poly2-&gt;HighPower;</span><br><span class="line"></span><br><span class="line">    if (PolyProd-&gt;HighPower &gt; MaxDegree)</span><br><span class="line">        Error(&quot;Exceeded array size&quot;);</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        for (i = 0; i &lt;= Poly1-&gt;HighPower; i++)</span><br><span class="line">            for (j = 0; j &lt;= Poly2-&gt;HighPower; j++)</span><br><span class="line">                PolyProd-&gt;CoeffArray[i + j] += Poly1-&gt;CoeffArray[i] * Poly2-&gt;CoeffArray[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于乘法，若$P_1(x) &#x3D; 10x^2+2x+1$，而$P_2(x) &#x3D;x^2+x+1$，则$P_1 \times P_2 &#x3D; 10x^2(x^2+x+1) + 2x(x^2+x+1) + (x^2+x+1)$，即把每一个$P_1$的项都去乘整个$P_2$，然后加起来。显然的事情是，若$P_1$有n个项，而$P_2$有$m$个，则$P_1 \times P_2$的项的个数就取决于$P_2$到底有多少个项。</p>
<p>另一种实现方法是用单链表，我们可以把多项式的每一项存在一个单元内，然后让这些单元按照次数递减的方式排序。例如下述例子，令$P_1 &#x3D; 10x^2+2x+1$，$P_2 &#x3D; x^2 + 3x + 7$，那么两个链表可以如下表示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">P_1 : (2) 10 --&gt; (1) 2 --&gt; (0) 1</span><br><span class="line">P_2 : (2) 1 --&gt; (1) 3 --&gt; (0) 7</span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct Node *PtrToNode;</span><br><span class="line"></span><br><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line">    int Coefficient; # 系数</span><br><span class="line">    int Exponent; #多项式的指针</span><br><span class="line">    PtrToNode Next; #下一个节点的指针</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef PtrToNode Polynomial; /* Nodes sorted by exponent */</span><br></pre></td></tr></table></figure>

<p>利用链表的一个难点是如何合并同类项。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 定义结构体</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    PolynomialNode* head;</span><br><span class="line">    int degree;</span><br><span class="line">&#125; Polynomial</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">// 定义链表节点结构</span><br><span class="line">typedef struct Node &#123;</span><br><span class="line">    int Coefficient; // 系数</span><br><span class="line">    int Exponent;    // 指数</span><br><span class="line">    struct Node* Next; // 指向下一个节点的指针</span><br><span class="line">&#125; Node, *Polynomial;</span><br><span class="line"></span><br><span class="line">// 创建新节点</span><br><span class="line">Node* CreateNode(int coeff, int exp) &#123;</span><br><span class="line">    Node* newNode = (Node*)malloc(sizeof(Node));</span><br><span class="line">    if (newNode == NULL) &#123;</span><br><span class="line">        fprintf(stderr, &quot;内存分配失败\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;Coefficient = coeff;</span><br><span class="line">    newNode-&gt;Exponent = exp;</span><br><span class="line">    newNode-&gt;Next = NULL;</span><br><span class="line">    return newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 插入节点（按指数排序）</span><br><span class="line">void InsertNode(Polynomial* P, int coeff, int exp) &#123;</span><br><span class="line">    // 创建一个新节点，存储系数和指数</span><br><span class="line">    Node* newNode = CreateNode(coeff, exp);</span><br><span class="line"></span><br><span class="line">    // 如果链表为空，直接将新节点作为头节点</span><br><span class="line">    if (*P == NULL) &#123;</span><br><span class="line">        *P = newNode;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 初始化 current 为链表的头节点，prev 为 NULL</span><br><span class="line">        Node* current = *P;</span><br><span class="line">        Node* prev = NULL;</span><br><span class="line"></span><br><span class="line">        // 遍历链表，找到插入位置</span><br><span class="line">        // 按指数降序排列，找到第一个小于等于 exp 的节点</span><br><span class="line">        while (current != NULL &amp;&amp; current-&gt;Exponent &gt; exp) &#123;</span><br><span class="line">            prev = current;          // 保存当前节点</span><br><span class="line">            current = current-&gt;Next; // 移动到下一个节点</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果找到相同指数的节点，合并同类项</span><br><span class="line">        if (current != NULL &amp;&amp; current-&gt;Exponent == exp) &#123;</span><br><span class="line">            current-&gt;Coefficient += coeff; // 合并系数</span><br><span class="line">            free(newNode);                // 释放新节点，因为不需要插入</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 如果没有找到相同指数的节点，插入新节点</span><br><span class="line">            if (prev == NULL) &#123;</span><br><span class="line">                // 插入到链表头部</span><br><span class="line">                newNode-&gt;Next = *P;</span><br><span class="line">                *P = newNode;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 插入到 prev 和 current 之间</span><br><span class="line">                newNode-&gt;Next = current;</span><br><span class="line">                prev-&gt;Next = newNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 多项式乘法</span><br><span class="line">Polynomial MultiplyPolynomials(Polynomial Poly1, Polynomial Poly2) &#123;</span><br><span class="line">    Polynomial result = NULL;</span><br><span class="line">    Node* p1 = Poly1;</span><br><span class="line">    Node* p2 = Poly2;</span><br><span class="line"></span><br><span class="line">    while (p1 != NULL) &#123;</span><br><span class="line">        p2 = Poly2; // 重置 p2</span><br><span class="line">        while (p2 != NULL) &#123;</span><br><span class="line">            int coeff = p1-&gt;Coefficient * p2-&gt;Coefficient;</span><br><span class="line">            int exp = p1-&gt;Exponent + p2-&gt;Exponent;</span><br><span class="line">            InsertNode(&amp;result, coeff, exp); // 插入结果多项式</span><br><span class="line">            p2 = p2-&gt;Next;</span><br><span class="line">        &#125;</span><br><span class="line">        p1 = p1-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 打印多项式</span><br><span class="line">void PrintPolynomial(Polynomial P) &#123;</span><br><span class="line">    while (P != NULL) &#123;</span><br><span class="line">        printf(&quot;%dx^%d&quot;, P-&gt;Coefficient, P-&gt;Exponent);</span><br><span class="line">        if (P-&gt;Next != NULL) &#123;</span><br><span class="line">            printf(&quot; + &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        P = P-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 释放多项式内存</span><br><span class="line">void FreePolynomial(Polynomial P) &#123;</span><br><span class="line">    Node* temp;</span><br><span class="line">    while (P != NULL) &#123;</span><br><span class="line">        temp = P;</span><br><span class="line">        P = P-&gt;Next;</span><br><span class="line">        free(temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>链表的第二个例子是基数排序，有时候也叫卡式排序，因为直到现代计算机的出现之前，它一直用于对老式穿孔卡的排序</p>
<p>若现在我们存在$n$个整数，范围在$1$到$M$（或者$0 $到$M-1$。那么我们可以用这个信息得到一种快速排序，或者叫桶式排序。我们设一个数组，叫 Count，大小为M，并初始化为0。于是Count存在M个单元（或者叫桶），开始时它们是空的，当$A_i$被读入时，Count[$A_i$]+1，在所有的输入读入之后，扫描数组Count并打印排好序的表，该算法花费$O(M+n)$，若$M &#x3D; \Theta (N)$，则桶式排序是O(N)的。</p>
<p>证明如下：我们假设排序方法是快速排序，快速排序的时间复杂度在$O(N\log(N))$，再设存在$m$个桶，则每个桶里面存在$n&#x2F;m$个元素，排序后花费的时间是$(n&#x2F;m)\log(n&#x2F;m)$，一共有m个桶，所以总的排序花费$O(m\times (n&#x2F;m)\log(n&#x2F;m) &#x3D; n(\log(n)-\log(m))$，把排序后的数据合并成一个数组花费大概$O(N)$，因为桶的数量是常数，所以$mN &#x3D; O(N)$，加起来就是$O(2n+c)$，$c &#x3D; n(\log(n)-\log(m))$，现在，数据限定的是整数，所以范围$M \geq N$。最终复杂度就是$O(N+M)$，若$M &#x3D; \Theta(N)$，这时候$O(2N) &#x3D; O(N)$。</p>
<h3 id="多重表"><a href="#多重表" class="headerlink" title="多重表"></a>多重表</h3><p>最后我们说一个复杂的实现，一所有4万名学生和2千5百门课程的大学需要生成两种类型的报告，一是列出每个班的注册者，而是报告列出每个学生注册的班级。</p>
<p>常见的方法是使用二维数组，而这样的数据大概能有一亿个，但平均一个学生注册3门课，所以真正有意义的数据只有12万项，大概占里面的0.1%。</p>
<p>该链表具体情况如下：首先学生自己选择的课是一个循环列表，而每门课的数据也是用循环列表储存，若c1有一个学生s1，则c1和s1指向的数据包含至少4个指针，一个是指向前驱元s1的指针和指向前驱元c1的指针，接着是指向下一门课和选择了c1的同学的指针：</p>
<center>

<p><img style="border-radius: 0.3125em;
                box-shadow: 0 2px 4px 0 rgba(34,36,38,.12), 0 2px 10px 0 rgba(34,36,38,.08);
                border: 10px solid transparent;
                margin-bottom: 20px"
        src="https://i.upmath.me/svg/%5Cbegin%7Btikzpicture%7D%5Bx%3D0.75pt%2Cy%3D0.75pt%2Cyscale%3D-1%2Cxscale%3D1%5D%0A%5Cdraw%20%20%20(120%2C31)%20--%20(159.18%2C31)%20--%20(159.18%2C50.19)%20--%20(120%2C50.19)%20--%20cycle%20%3B%0A%5Cdraw%20%20%20(335%2C29)%20--%20(374.18%2C29)%20--%20(374.18%2C48.19)%20--%20(335%2C48.19)%20--%20cycle%20%3B%0A%5Cdraw%20%20%20(264%2C30)%20--%20(303.18%2C30)%20--%20(303.18%2C49.19)%20--%20(264%2C49.19)%20--%20cycle%20%3B%0A%5Cdraw%20%20%20(193%2C31)%20--%20(232.18%2C31)%20--%20(232.18%2C50.19)%20--%20(193%2C50.19)%20--%20cycle%20%3B%0A%0A%5Cdraw%20%20%20(59%2C88.19)%20--%20(93.67%2C88.19)%20--%20(93.67%2C108)%20--%20(59%2C108)%20--%20cycle%20%3B%0A%5Cdraw%20%20%20(61%2C142.19)%20--%20(95.67%2C142.19)%20--%20(95.67%2C162)%20--%20(61%2C162)%20--%20cycle%20%3B%0A%0A%5Cdraw%20%20%20(122%2C87.19)%20--%20(156.67%2C87.19)%20--%20(156.67%2C107)%20--%20(122%2C107)%20--%20cycle%20%3B%0A%5Cdraw%20%20%20(123%2C141.19)%20--%20(157.67%2C141.19)%20--%20(157.67%2C161)%20--%20(123%2C161)%20--%20cycle%20%3B%0A%5Cdraw%20%20%20(195%2C142.19)%20--%20(229.67%2C142.19)%20--%20(229.67%2C162)%20--%20(195%2C162)%20--%20cycle%20%3B%0A%5Cdraw%20%20%20(265%2C85.19)%20--%20(299.67%2C85.19)%20--%20(299.67%2C105)%20--%20(265%2C105)%20--%20cycle%20%3B%0A%5Cdraw%20%20%20(341%2C139.19)%20--%20(375.67%2C139.19)%20--%20(375.67%2C159)%20--%20(341%2C159)%20--%20cycle%20%3B%0A%0A%5Cdraw%20%20%20%20(141%2C54)%20--%20(141%2C82.19)%20%3B%0A%5Cdraw%20%5Bshift%3D%7B(141%2C84.19)%7D%2C%20rotate%20%3D%20270%5D%20%5Bcolor%3D%7Brgb%2C%20255%3Ared%2C%200%3B%20green%2C%200%3B%20blue%2C%200%20%7D%20%20%5D%5Bline%20width%3D0.75%5D%20%20%20%20(10.93%2C-3.29)%20..%20controls%20(6.95%2C-1.4)%20and%20(3.31%2C-0.3)%20..%20(0%2C0)%20..%20controls%20(3.31%2C0.3)%20and%20(6.95%2C1.4)%20..%20(10.93%2C3.29)%20%20%20%3B%0A%5Cdraw%20%20%20%20(140%2C108)%20--%20(140%2C136.19)%20%3B%0A%5Cdraw%20%5Bshift%3D%7B(140%2C138.19)%7D%2C%20rotate%20%3D%20270%5D%20%5Bcolor%3D%7Brgb%2C%20255%3Ared%2C%200%3B%20green%2C%200%3B%20blue%2C%200%20%7D%20%20%5D%5Bline%20width%3D0.75%5D%20%20%20%20(10.93%2C-3.29)%20..%20controls%20(6.95%2C-1.4)%20and%20(3.31%2C-0.3)%20..%20(0%2C0)%20..%20controls%20(3.31%2C0.3)%20and%20(6.95%2C1.4)%20..%20(10.93%2C3.29)%20%20%20%3B%0A%5Cdraw%20%20%20%20(142%2C167)%20--%20(142%2C199.19)%20--%20(113.18%2C199.19)%20--%20(113.18%2C11.19)%20--%20(139.18%2C11.19)%20--%20(139.18%2C26.19)%20%3B%0A%5Cdraw%20%5Bshift%3D%7B(139.18%2C28.19)%7D%2C%20rotate%20%3D%20270%5D%20%5Bcolor%3D%7Brgb%2C%20255%3Ared%2C%200%3B%20green%2C%200%3B%20blue%2C%200%20%7D%20%20%5D%5Bline%20width%3D0.75%5D%20%20%20%20(10.93%2C-3.29)%20..%20controls%20(6.95%2C-1.4)%20and%20(3.31%2C-0.3)%20..%20(0%2C0)%20..%20controls%20(3.31%2C0.3)%20and%20(6.95%2C1.4)%20..%20(10.93%2C3.29)%20%20%20%3B%0A%5Cdraw%20%20%20%20(211%2C65)%20--%20(211%2C129.19)%20%3B%0A%5Cdraw%20%5Bshift%3D%7B(211%2C131.19)%7D%2C%20rotate%20%3D%20270%5D%20%5Bcolor%3D%7Brgb%2C%20255%3Ared%2C%200%3B%20green%2C%200%3B%20blue%2C%200%20%7D%20%20%5D%5Bline%20width%3D0.75%5D%20%20%20%20(10.93%2C-3.29)%20..%20controls%20(6.95%2C-1.4)%20and%20(3.31%2C-0.3)%20..%20(0%2C0)%20..%20controls%20(3.31%2C0.3)%20and%20(6.95%2C1.4)%20..%20(10.93%2C3.29)%20%20%20%3B%0A%5Cdraw%20%20%20%20(209%2C165)%20--%20(209%2C197.19)%20--%20(180.18%2C197.19)%20--%20(180.18%2C9.19)%20--%20(206.18%2C9.19)%20--%20(206.18%2C24.19)%20%3B%0A%5Cdraw%20%5Bshift%3D%7B(206.18%2C26.19)%7D%2C%20rotate%20%3D%20270%5D%20%5Bcolor%3D%7Brgb%2C%20255%3Ared%2C%200%3B%20green%2C%200%3B%20blue%2C%200%20%7D%20%20%5D%5Bline%20width%3D0.75%5D%20%20%20%20(10.93%2C-3.29)%20..%20controls%20(6.95%2C-1.4)%20and%20(3.31%2C-0.3)%20..%20(0%2C0)%20..%20controls%20(3.31%2C0.3)%20and%20(6.95%2C1.4)%20..%20(10.93%2C3.29)%20%20%20%3B%0A%5Cdraw%20%20%20%20(282%2C52)%20--%20(282%2C84.19)%20%3B%0A%5Cdraw%20%5Bshift%3D%7B(282%2C86.19)%7D%2C%20rotate%20%3D%20270%5D%20%5Bcolor%3D%7Brgb%2C%20255%3Ared%2C%200%3B%20green%2C%200%3B%20blue%2C%200%20%7D%20%20%5D%5Bline%20width%3D0.75%5D%20%20%20%20(10.93%2C-3.29)%20..%20controls%20(6.95%2C-1.4)%20and%20(3.31%2C-0.3)%20..%20(0%2C0)%20..%20controls%20(3.31%2C0.3)%20and%20(6.95%2C1.4)%20..%20(10.93%2C3.29)%20%20%20%3B%0A%5Cdraw%20%20%20%20(282%2C112.19)%20--%20(282%2C195.19)%20--%20(253.18%2C195.19)%20--%20(253.18%2C7.19)%20--%20(279.18%2C7.19)%20--%20(279.18%2C22.19)%20%3B%0A%5Cdraw%20%5Bshift%3D%7B(279.18%2C24.19)%7D%2C%20rotate%20%3D%20270%5D%20%5Bcolor%3D%7Brgb%2C%20255%3Ared%2C%200%3B%20green%2C%200%3B%20blue%2C%200%20%7D%20%20%5D%5Bline%20width%3D0.75%5D%20%20%20%20(10.93%2C-3.29)%20..%20controls%20(6.95%2C-1.4)%20and%20(3.31%2C-0.3)%20..%20(0%2C0)%20..%20controls%20(3.31%2C0.3)%20and%20(6.95%2C1.4)%20..%20(10.93%2C3.29)%20%20%20%3B%0A%5Cdraw%20%20%20%20(357%2C60)%20--%20(357%2C124.19)%20%3B%0A%5Cdraw%20%5Bshift%3D%7B(357%2C126.19)%7D%2C%20rotate%20%3D%20270%5D%20%5Bcolor%3D%7Brgb%2C%20255%3Ared%2C%200%3B%20green%2C%200%3B%20blue%2C%200%20%7D%20%20%5D%5Bline%20width%3D0.75%5D%20%20%20%20(10.93%2C-3.29)%20..%20controls%20(6.95%2C-1.4)%20and%20(3.31%2C-0.3)%20..%20(0%2C0)%20..%20controls%20(3.31%2C0.3)%20and%20(6.95%2C1.4)%20..%20(10.93%2C3.29)%20%20%20%3B%0A%5Cdraw%20%20%20%20(355%2C162.19)%20--%20(355%2C195.19)%20--%20(326.18%2C195.19)%20--%20(326.18%2C7.19)%20--%20(352.18%2C7.19)%20--%20(352.18%2C22.19)%20%3B%0A%5Cdraw%20%5Bshift%3D%7B(352.18%2C24.19)%7D%2C%20rotate%20%3D%20270%5D%20%5Bcolor%3D%7Brgb%2C%20255%3Ared%2C%200%3B%20green%2C%200%3B%20blue%2C%200%20%7D%20%20%5D%5Bline%20width%3D0.75%5D%20%20%20%20(10.93%2C-3.29)%20..%20controls%20(6.95%2C-1.4)%20and%20(3.31%2C-0.3)%20..%20(0%2C0)%20..%20controls%20(3.31%2C0.3)%20and%20(6.95%2C1.4)%20..%20(10.93%2C3.29)%20%20%20%3B%0A%5Cdraw%20%20%20%20(94%2C98)%20--%20(119.18%2C98)%20%3B%0A%5Cdraw%20%5Bshift%3D%7B(121.18%2C98)%7D%2C%20rotate%20%3D%20180%5D%20%5Bcolor%3D%7Brgb%2C%20255%3Ared%2C%200%3B%20green%2C%200%3B%20blue%2C%200%20%7D%20%20%5D%5Bline%20width%3D0.75%5D%20%20%20%20(10.93%2C-3.29)%20..%20controls%20(6.95%2C-1.4)%20and%20(3.31%2C-0.3)%20..%20(0%2C0)%20..%20controls%20(3.31%2C0.3)%20and%20(6.95%2C1.4)%20..%20(10.93%2C3.29)%20%20%20%3B%0A%5Cdraw%20%20%20%20(168%2C96)%20--%20(257.18%2C96)%20%3B%0A%5Cdraw%20%5Bshift%3D%7B(259.18%2C96)%7D%2C%20rotate%20%3D%20180%5D%20%5Bcolor%3D%7Brgb%2C%20255%3Ared%2C%200%3B%20green%2C%200%3B%20blue%2C%200%20%7D%20%20%5D%5Bline%20width%3D0.75%5D%20%20%20%20(10.93%2C-3.29)%20..%20controls%20(6.95%2C-1.4)%20and%20(3.31%2C-0.3)%20..%20(0%2C0)%20..%20controls%20(3.31%2C0.3)%20and%20(6.95%2C1.4)%20..%20(10.93%2C3.29)%20%20%20%3B%0A%5Cdraw%20%20%20%20(306.32%2C93.81)%20--%20(377.5%2C93.81)%20--%20(377.5%2C65)%20--%20(44.5%2C65)%20--%20(44.5%2C102)%20--%20(53.5%2C102)%20%3B%0A%5Cdraw%20%5Bshift%3D%7B(55.5%2C102)%7D%2C%20rotate%20%3D%20180%5D%20%5Bcolor%3D%7Brgb%2C%20255%3Ared%2C%200%3B%20green%2C%200%3B%20blue%2C%200%20%7D%20%20%5D%5Bline%20width%3D0.75%5D%20%20%20%20(10.93%2C-3.29)%20..%20controls%20(6.95%2C-1.4)%20and%20(3.31%2C-0.3)%20..%20(0%2C0)%20..%20controls%20(3.31%2C0.3)%20and%20(6.95%2C1.4)%20..%20(10.93%2C3.29)%20%20%20%3B%0A%5Cdraw%20%20%20%20(378.5%2C145.81)%20--%20(378.5%2C117)%20--%20(45.5%2C117)%20--%20(45.5%2C154)%20--%20(54.5%2C154)%20%3B%0A%5Cdraw%20%5Bshift%3D%7B(56.5%2C154)%7D%2C%20rotate%20%3D%20180%5D%20%5Bcolor%3D%7Brgb%2C%20255%3Ared%2C%200%3B%20green%2C%200%3B%20blue%2C%200%20%7D%20%20%5D%5Bline%20width%3D0.75%5D%20%20%20%20(10.93%2C-3.29)%20..%20controls%20(6.95%2C-1.4)%20and%20(3.31%2C-0.3)%20..%20(0%2C0)%20..%20controls%20(3.31%2C0.3)%20and%20(6.95%2C1.4)%20..%20(10.93%2C3.29)%20%20%20%3B%0A%5Cdraw%20%20%20%20(98%2C151)%20--%20(122.18%2C151)%20%3B%0A%5Cdraw%20%5Bshift%3D%7B(124.18%2C151)%7D%2C%20rotate%20%3D%20180%5D%20%5Bcolor%3D%7Brgb%2C%20255%3Ared%2C%200%3B%20green%2C%200%3B%20blue%2C%200%20%7D%20%20%5D%5Bline%20width%3D0.75%5D%20%20%20%20(10.93%2C-3.29)%20..%20controls%20(6.95%2C-1.4)%20and%20(3.31%2C-0.3)%20..%20(0%2C0)%20..%20controls%20(3.31%2C0.3)%20and%20(6.95%2C1.4)%20..%20(10.93%2C3.29)%20%20%20%3B%0A%5Cdraw%20%20%20%20(164%2C151)%20--%20(188.18%2C151)%20%3B%0A%5Cdraw%20%5Bshift%3D%7B(190.18%2C151)%7D%2C%20rotate%20%3D%20180%5D%20%5Bcolor%3D%7Brgb%2C%20255%3Ared%2C%200%3B%20green%2C%200%3B%20blue%2C%200%20%7D%20%20%5D%5Bline%20width%3D0.75%5D%20%20%20%20(10.93%2C-3.29)%20..%20controls%20(6.95%2C-1.4)%20and%20(3.31%2C-0.3)%20..%20(0%2C0)%20..%20controls%20(3.31%2C0.3)%20and%20(6.95%2C1.4)%20..%20(10.93%2C3.29)%20%20%20%3B%0A%5Cdraw%20%20%20%20(237%2C153)%20--%20(334.18%2C153)%20%3B%0A%5Cdraw%20%5Bshift%3D%7B(336.18%2C153)%7D%2C%20rotate%20%3D%20180%5D%20%5Bcolor%3D%7Brgb%2C%20255%3Ared%2C%200%3B%20green%2C%200%3B%20blue%2C%200%20%7D%20%20%5D%5Bline%20width%3D0.75%5D%20%20%20%20(10.93%2C-3.29)%20..%20controls%20(6.95%2C-1.4)%20and%20(3.31%2C-0.3)%20..%20(0%2C0)%20..%20controls%20(3.31%2C0.3)%20and%20(6.95%2C1.4)%20..%20(10.93%2C3.29)%20%20%20%3B%0A%5Cdraw%20(133%2C34)%20node%20%5Banchor%3Dnorth%20west%5D%5Binner%20sep%3D0.75pt%5D%20%20%20%5Balign%3Dleft%5D%20%7Bs1%7D%3B%0A%5Cdraw%20(206%2C34)%20node%20%5Banchor%3Dnorth%20west%5D%5Binner%20sep%3D0.75pt%5D%20%20%20%5Balign%3Dleft%5D%20%7Bs2%7D%3B%0A%5Cdraw%20(276%2C34)%20node%20%5Banchor%3Dnorth%20west%5D%5Binner%20sep%3D0.75pt%5D%20%20%20%5Balign%3Dleft%5D%20%7Bs3%7D%3B%0A%5Cdraw%20(347%2C31)%20node%20%5Banchor%3Dnorth%20west%5D%5Binner%20sep%3D0.75pt%5D%20%20%20%5Balign%3Dleft%5D%20%7Bs4%7D%3B%0A%5Cdraw%20(67%2C91)%20node%20%5Banchor%3Dnorth%20west%5D%5Binner%20sep%3D0.75pt%5D%20%20%20%5Balign%3Dleft%5D%20%7Bc1%7D%3B%0A%5Cdraw%20(68%2C145)%20node%20%5Banchor%3Dnorth%20west%5D%5Binner%20sep%3D0.75pt%5D%20%20%20%5Balign%3Dleft%5D%20%7Bc2%7D%3B%0A%5Cend%7Btikzpicture%7D" width="60%"></p>
</center>

<p>具体的实现情况如下，例如我们查询$c_3$学生的信息，由于我们需要这门课包含了多少学生，以及该学生选了多少门课，所以 首先再c3表头开始找数据，直到发现第一个选择该门课的学生si，这个时候停止搜索c3中其他学生的信息，转而找学生si的选课情况知道返回si单元，然后跳转回c3重新寻找下一个选了c3的学生sj，</p>
<h2 id="栈-ADT"><a href="#栈-ADT" class="headerlink" title="栈 ADT"></a>栈 ADT</h2><h3 id="栈模型"><a href="#栈模型" class="headerlink" title="栈模型"></a>栈模型</h3><p>栈是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫做栈的顶（Top），栈的基本操作有2个，<strong>Push</strong>（进栈）和 <strong>Pop</strong>（出栈）。前者相当于是插入元素，后者是删除最后插入的元素。最后插入的元素可以通过使用Top例程在执行Pop之前考察。对空栈执行pop可能会导致错误，这一般是ADT的错误，另一方面，若运行push的时候空间用尽是一个实现错误，不是ADT错误。</p>
<p>一个简单的栈结构和操作可以这样描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| Top |           | es  |        |Top|</span><br><span class="line">| en  |  Push(es) | Top |  Pop   | en|</span><br><span class="line">| en-1|   ----&gt;   | en  | ----&gt;  |...|</span><br><span class="line">| ... |           | ... |        |e1 |</span><br><span class="line">| e1  |           | e1  |</span><br></pre></td></tr></table></figure>

<p>所以栈有时叫LIFO（后进先出）表。普通的清空栈的操作和判断是否空栈的测试都是栈的操作指令系统的一部分，但是对栈能做的基本上只有pop和push操作。</p>
<h3 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h3><p>栈是一个表，所以实际上实现表的方法都能实现栈。我们给出2个方法，一个是指针，一个是数组。</p>
<h4 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h4><p>栈的第一种实现方法是使用单链表。我们通过在表顶插入实现push，删除表的顶端元素实现Pop。Top操作只是考察顶端元素并返回他的值。有时候需要Pop和Top操作合二为一。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;Stack_h&gt;</span><br><span class="line"></span><br><span class="line">struct Node;</span><br><span class="line">typedef struct Node *PtrToNode;</span><br><span class="line">typedef PtrToNode Stack;</span><br><span class="line"></span><br><span class="line">int IsEmpty(Stack S);</span><br><span class="line">Stack CreateStack(void);</span><br><span class="line">void DisposeStack(Stack S);</span><br><span class="line">void MakeEmpty(Stack S);</span><br><span class="line">void Push(ElementType X, Stack S);</span><br><span class="line">ElementType Top(Stack S);</span><br><span class="line">void Pop(Stack S);</span><br><span class="line"></span><br><span class="line">#endif /* _Stack_h */</span><br><span class="line"></span><br><span class="line">/* Place in implementation file */</span><br><span class="line">/* Stack implementation is a linked list with a header */</span><br><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line">    ElementType Element;</span><br><span class="line">    PtrToNode Next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>和之前一样，我们依然声明Node（节点）为一个结构，在结尾的Node给出了详细的结构，包含一段数据和一个指向下一个元素的指针Next。typedef定义了一个指向结构的指针PtrToNode。接着定义Stack也是PtrToNode的结构。可以直接用Stack定义所需的链表结构。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stack myStack; // 等价于 struct Node* myStack;</span><br></pre></td></tr></table></figure>

<p>其他的是一些函数，等一下讲实现的时候说明。</p>
<p>首先是第一个函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int IsEmpty(Stack S)</span><br><span class="line">&#123;</span><br><span class="line">    return S-&gt;Next == NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数接收一个栈结构S，若S表头的下一个元素为空，则返回1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Stack CreateStack(void)</span><br><span class="line">&#123;</span><br><span class="line">    Stack S;</span><br><span class="line">    S = malloc(sizeof(struct Node));</span><br><span class="line">    if (S == NULL)</span><br><span class="line">        FatalError(&quot;Out of space!!!&quot;);</span><br><span class="line">    S-&gt;Next = NULL;</span><br><span class="line">    MakeEmpty(S);</span><br><span class="line">    return S;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MakeEmpty(Stack S)</span><br><span class="line">&#123;</span><br><span class="line">    if (S == NULL)</span><br><span class="line">        Error(&quot;Must use CreateStack first&quot;);</span><br><span class="line">    else</span><br><span class="line">        while (!IsEmpty(S))</span><br><span class="line">            Pop(S);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该代码创建了一个空栈的例程,MakeEmpty函数是用来确保栈是空的。它会一直pop栈中的元素，直到栈是空的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void Pop(Stack S)</span><br><span class="line">&#123;</span><br><span class="line">    PtrToNode FirstCell;</span><br><span class="line">    if (IsEmpty(S))</span><br><span class="line">        Error(&quot;Empty stack&quot;);</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        FirstCell = S-&gt;Next;</span><br><span class="line">        S-&gt;Next = S-&gt;Next-&gt;Next;</span><br><span class="line">        free(FirstCell);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Pop函数是通过删除表的前端元素实现的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void Push(ElementType X, Stack S) &#123;</span><br><span class="line">    PtrToNode TmpCell;</span><br><span class="line"></span><br><span class="line">    TmpCell = malloc(sizeof(struct Node));</span><br><span class="line">    if (TmpCell == NULL)</span><br><span class="line">        FatalError(&quot;Out of space!!!&quot;);</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        TmpCell-&gt;Element = X;</span><br><span class="line">        TmpCell-&gt;Next = S-&gt;Next;</span><br><span class="line">        S-&gt;Next = TmpCell;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数接受2个参数，元素X和栈S。</p>
<p>首先给定一个临时变量TmpCell用来储存临时变量。接着申请一个Node结构大小的内存。若临时变量为空，返回插入失败。否则，令临时变量的内容为X，令Tmpcell下一个指针指向表头的下一个单元。接着令表头的下一个元素指向Tmpcell就完成了压栈操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ElementType Top(Stack S)</span><br><span class="line">&#123;</span><br><span class="line">    if (!IsEmpty(S))</span><br><span class="line">        return S-&gt;Next-&gt;Element;</span><br><span class="line">    Error(&quot;Empty stack&quot;);</span><br><span class="line">    return 0; /* Return value used to avoid warning */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Top函数用来检查栈顶元素。</p>
<p>所有的操作均花费常数时间，比较花费的地方主要在于free和malloc函数，可以通过使用第二个栈去避免，第二个栈初始化为空，当一个单元要从第一个栈弹出时，它只是被丢在第二个栈中。此后，当第一个栈需要新单元，它首先去检查第二个栈。</p>
<h4 id="数组实现栈"><a href="#数组实现栈" class="headerlink" title="数组实现栈"></a>数组实现栈</h4><p>数组的使用方法可能是更好的结果，缺点是需要提前声明一个数组的大小。</p>
<p>用数组实现栈稍微简单些，每一个栈都有一个栈顶的索引，称它为TopOfStack。而空栈的索引是-1，为了将一个元素压栈。则将需要将索引+1.然后令Stack[TopOfStack] &#x3D; X。其中Stack是一个具体的数组。</p>
<p>一个影响栈的执行效率的问题是错误检测，我们的链表实现是有仔细的检查错误的，比如，对空栈的pop和push或者是对满栈的push都会引起程序崩溃。显然我门不希望出现这种情况。数组去做检查效率非常的慢，一半来说除非在重要场合，否则一般会省去这种检查。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#ifndef _Stack_h</span><br><span class="line"></span><br><span class="line">struct StackRecord;</span><br><span class="line">typedef struct StackRecord *Stack;</span><br><span class="line"></span><br><span class="line">int IsEmpty(Stack S);</span><br><span class="line">int IsFull(Stack S);</span><br><span class="line">Stack CreateStack(int MaxElements);</span><br><span class="line">void DisposeStack(Stack S);</span><br><span class="line">void MakeEmpty(Stack S);</span><br><span class="line">void Push(ElementType X, Stack S);</span><br><span class="line">ElementType Top(Stack S);</span><br><span class="line">void Pop(Stack S);</span><br><span class="line">ElementType TopAndPop(Stack S);</span><br><span class="line"></span><br><span class="line">#endif /* _Stack_h */</span><br><span class="line"></span><br><span class="line">/* Place in implementation file */</span><br><span class="line">/* Stack implementation is a dynamically allocated array */</span><br><span class="line">#define EmptyTOS (-1)</span><br><span class="line">#define MinStackSize (5)</span><br><span class="line"></span><br><span class="line">struct StackRecord</span><br><span class="line">&#123;</span><br><span class="line">    int Capacity;</span><br><span class="line">    int TopOfStack;</span><br><span class="line">    ElementType *Array;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>数组的实现需要的东西如上。Stack被定义为一个指向结构体的指针，其包含TopOfStack的大小和Capcity的大小。也叫做域。一旦知道最大容量，则栈可以被动态的确定。 </p>
<p>在CreatStack中，我们将创建一个具有给定最大值的栈。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Stack CreateStack(int MaxElements)</span><br><span class="line">&#123;</span><br><span class="line">    Stack S;</span><br><span class="line"></span><br><span class="line">    if (MaxElements &lt; MinStackSize)</span><br><span class="line">        Error(&quot;Stack size is too small!&quot;);</span><br><span class="line"></span><br><span class="line">    S = malloc(sizeof(struct StackRecord));</span><br><span class="line">    if (S == NULL)</span><br><span class="line">        FatalError(&quot;Out of space!!!&quot;);</span><br><span class="line"></span><br><span class="line">    S-&gt;Array = malloc(sizeof(ElementType) * MaxElements);</span><br><span class="line">    if (S-&gt;Array == NULL)</span><br><span class="line">        FatalError(&quot;Out of space!!!&quot;);</span><br><span class="line">    S-&gt;Capacity = MaxElements;</span><br><span class="line">    MakeEmpty(S);</span><br><span class="line"></span><br><span class="line">    return S;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数接受一个最大元素数量的参数，一开始我们定义MinStackSize &#x3D; 5，若低于这个数量，则栈太小。需要重新配置。</p>
<p>在DisposeStack中，该函数用于释放一个栈结构。该程序首先释放栈数组，然后释放栈结构体。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void DisposeStack(Stack S)</span><br><span class="line">&#123;</span><br><span class="line">    if (S != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        free(S-&gt;Array);</span><br><span class="line">        free(S);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>接着是检测一个空栈，生成空栈和push操作的例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int IsEmpty(Stack S)</span><br><span class="line">&#123;</span><br><span class="line">    return S-&gt;TopOfStack == EmptyTOS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MakeEmpty(Stack S)</span><br><span class="line">&#123;</span><br><span class="line">    S-&gt;TopOfStack = EmptyTOS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Push(ElementType X, Stack S)</span><br><span class="line">&#123;</span><br><span class="line">    if (IsFull(S))</span><br><span class="line">        Error(&quot;Full stack&quot;);</span><br><span class="line">    else</span><br><span class="line">        S-&gt;Array[++S-&gt;TopOfStack] = X;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着是返回栈顶的例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ElementType Top(Stack S)</span><br><span class="line">&#123;</span><br><span class="line">    if (!IsEmpty(S))</span><br><span class="line">        return S-&gt;Array[S-&gt;TopOfStack];</span><br><span class="line">    Error(&quot;Empty stack&quot;);</span><br><span class="line">    return 0; /* Return value used to avoid warning */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是Pop操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void Pop(Stack S)</span><br><span class="line">&#123;</span><br><span class="line">    if (IsEmpty(S))</span><br><span class="line">        Error(&quot;Empty stack&quot;);</span><br><span class="line">    else</span><br><span class="line">        S-&gt;TopOfStack--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>++表示+1，–表示-1，这是直接将栈的空间减小1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ElementType TopAndPop(Stack S)</span><br><span class="line">&#123;</span><br><span class="line">    if (!IsEmpty(S))</span><br><span class="line">        return S-&gt;Array[S-&gt;TopOfStack--];</span><br><span class="line">    Error(&quot;Empty stack&quot;);</span><br><span class="line">    return 0; /* Return value used to avoid warning */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该例子是给出栈顶并pop元素的例子。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://monstergeo.github.io/btest/2025/02/12/%E9%93%BE%E8%A1%A8/" data-id="cmlgrfvh7002a6whxcb29cgr7" data-title="链表" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithms/" rel="tag">algorithms</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-素数测试" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/10/%E7%B4%A0%E6%95%B0%E6%B5%8B%E8%AF%95/" class="article-date">
  <time class="dt-published" datetime="2024-12-09T18:10:34.000Z" itemprop="datePublished">2024-12-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/12/10/%E7%B4%A0%E6%95%B0%E6%B5%8B%E8%AF%95/">素数测试</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在前两章的学习之后，我们了解了RSA加密原理。现在Bob准备用他的密钥和Alice进行通讯。为了创建RSA密钥，首先我们需要选择大素数p,q，主要的原因是，若p,q不是素数，则Bob需要对其进行因式分解再运算，其次，若素数不够大，则Eve可以对pq进行因式分解从而破解密码。</p>
<p>所以这节的主旨是，如何寻找大素数，只需要用到几个很简单的结论即可。例如，我们设Bob已经选择了一个大数</p>
<center>

<p>$\begin{aligned}<br>    n &#x3D; 31987937737479355332620068643713101490952335301<br>\end{aligned}$</p>
</center>

<p>现在我们来判断其是否是素数，首先的是，经过简单的计算，小于100,0000的素数都不是其的因子。我们怀疑可能是真的素数，现在，我们计算$2^{n-1} \mod n$的值，那么经过计算机可以得到：</p>
<center>

<p>$\begin{aligned}<br>    2^{n-1} \equiv 1281265953551359064133601216247151836053160074 \mod n<br>\end{aligned}$</p>
</center>

<p>那么利用费马小定理，若p是素数，则$a^{p-1}\equiv 1 \mod p$（除非p$\mid $a，则由该同余式子，我们知道其是合数。现在我们描述一个更强一点的费马小定理</p>
<h2 id="费马小定理（版本2"><a href="#费马小定理（版本2" class="headerlink" title="费马小定理（版本2"></a>费马小定理（版本2</h2><p>令p是素数，则</p>
<center>

<p>$\begin{aligned}<br>    a^p\equiv a \mod p ~~~\text{对所有整数a成立}<br>\end{aligned}$</p>
</center>

<p><strong>证明：</strong> 若$p\nmid a$，由费马小定理$a^{p-1}\equiv 1 \mod p$两边乘a就可以得到$a^p \equiv a \mod p$。其次，若$p\mid a$，由整除性，$a \equiv 0 \mod p$意味着定理两边都是0，矛盾。</p>
<p>现在，鲍勃可以利用它找到一个大素数</p>
<center>

<p>$\begin{aligned}<br>    n &#x3D; 2967952985951692762820418740138329004315165131<br>\end{aligned}$</p>
</center>

<p>现在鲍勃选择计算$2^n \equiv 2 \mod n$，它现在准备逆用费马小定理的版本2.但这可能成功吗，答案是不一定的，考虑</p>
<center>

<p>$\begin{aligned}<br>    2^{341} \equiv 2 \mod 341 ，但 341&#x3D;11*31<br>\end{aligned}$</p>
</center>

<p>所以341不是一个素数。但这是个不错的开始，我们开始能缩小范围寻找素数。这促使我们做出如下的定义</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>固定整数n，我们说整数a是判断n的合数性的证据，则</p>
<center>

<p>$\begin{aligned}<br>    a^n\not\equiv a \mod n<br>\end{aligned}$</p>
</center>

<p>所以，若这种证据只有一个，则结合版本2的费马小定理则很容易验证n是否为合数，其次，讨论n是否是质数一个方法就是尝试非常多的数字$a_1,\cdots$。若其中有一个满足上述条件可以作为证据，则n是合数。但是，由于刚才的例子，若其中没有可以证明n是合数的证据，则我们继续对n是否是素数保持怀疑。</p>
<p>所以鲍勃需要一个比费马小定理更强的定理来生成素数。</p>
<h2 id="命题"><a href="#命题" class="headerlink" title="命题"></a>命题</h2><p>令p是奇素数且记</p>
<center>

<p>$\begin{aligned}<br>    p-1 &#x3D; 2^kq &amp; 其中q是奇数<br>\end{aligned}$</p>
</center>

<p>再设a是任何不被p整除的数，则a满足下述两个条件之一</p>
<ul>
<li>$a^q\equiv 1 \mod p$</li>
<li>$a^q,a^{2q},\cdots ,a^{2^{q-1}q},a^{2^kq}$其中有一个模$p$与 $-1$同余</li>
</ul>
<p><strong>证明：</strong> 费马小定理告诉我们$a^{p-1}\equiv 1\mod p$，则对列表</p>
<center>

<p>$\begin{aligned}<br>    a^q,a^{2q},\cdots ,a^{2^{q-1}q},a^{2^kq}<br>\end{aligned}$</p>
</center>

<p>的最后一个数有$\mod p$为1，注意列表每个数字都是前一个数字的平方，那么会有两种情况：</p>
<ol>
<li>列表中第一个数模$p$余1.</li>
<li>列表中一些数字不模$p$余1，但它的平方模$p$余1.</li>
</ol>
<p>但唯一满足两个条件的数</p>
<center>

<p>$\begin{aligned}<br>    b\not\equiv 1\mod p ~~~ 和 ~~~ b^2\equiv 1\mod p<br>\end{aligned}$</p>
</center>

<p>是$-1$，因此表中应该有一个数与$-1$同余。</p>
<p>现在我们给出一种较强的米勒-拉宾合数检验流程：</p>
<p>||给定测试数n，令a是待检验的合数性证据|<br>|:—-|:—-|:—-|<br>|1.|若n是偶数或者1 &lt; gcd(a,n)，则n是合数||<br>|2.|记n-1 &#x3D; $2^kq$，其中$q$是奇数||<br>|3.|令$a &#x3D; a^q\mod n$||<br>|4.|若a$\equiv 1\mod n$，则测试失败，n不一定是合数||<br>|5.|做循环$i&#x3D;0,1,\cdots,k-1$||<br>||6.若$a\equiv -1\mod n$，则测试失败|<br>||7.令$a&#x3D;a^2\mod n$|<br>|8.|增加i的次数并持续的做步骤5的循环验证|<br>|9.|得到n是合数|</p>
<p>从上述流程，我们把它重写为定义。<br>##定义</p>
<p>设$n$是奇数且记$n-1 &#x3D; 2^kq$，其中$q$是奇数。则满足gcd(a,n) &#x3D;1且满足下述两个条件的整数$a$称为a是n的米勒-拉宾的合数性证据</p>
<ul>
<li>$a^q\equiv 1 \mod n$</li>
<li>$a^{2^iq}\not\equiv -1 \mod n$对所有$i&#x3D;0,1,\cdots,k-1$成立。</li>
</ul>
<p>所以由上述流程，若a是n的一个合数性证据，则n一定是合数。现在假设 Bob 想要检查大数 n 是否可能是素数。为此，他使用一组随机选择的 a 值运行米勒-拉宾检验。为什么这比使用费马小定理检验更好？答案是，对于米勒-拉宾检验，我们可以避免诸如之前341这样的奇葩例子存在。因为我们严格的检验每个小于n-1的2的平方。而每个合数都有非常多的合数性证据。他们如下述定理所描述：</p>
<h2 id="命题-1"><a href="#命题-1" class="headerlink" title="命题"></a>命题</h2><p>令$n$是奇合数，则$1$到$n-1$的数字a中至少有$75%$都是n关于米勒-拉宾的合数性证据</p>
<p>这意味着Bob在寻找合数的时候都有75%的概率找到。假设Bob十次都没有找到合数的证据，这样的概率是$(25%)^{10}$，如果找了100次，这个概率将低至$(25%)^{100}\approx 10^{-60}$</p>
<p>现在给出一个例子</p>
<p>###例子</p>
<p>我们选择$a&#x3D;2$和$n&#x3D;561$做合数检验，现在有</p>
<p>$$<br>n-1 &#x3D; 560 &#x3D; 2^4 \cdot 35<br>$$</p>
<p>那么就有</p>
<center>

<p>$\begin{aligned}<br>    2^35 \equiv&amp; 264 \mod 561\<br>    2^{2<em>35}\equiv&amp; 263^2 \equiv 166 \mod 561\<br>    2^{4</em>35} \equiv&amp; 166^2 \equiv 67 \mod 561\<br>    2^{8*35} \equiv&amp; 67^2 \equiv 1\mod 561<br>\end{aligned}$</p>
</center>

<p>由于第一个数字是$\mod 561$既不是1也不是余1，所以它是合数。其他数最后也不是mod 561 余-1，所以定理告诉我们它是合数。</p>
<h3 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h3><p>我们取$n &#x3D; 172947529$和$n-1 &#x3D; 2^3 \cdot 21618441 &#x3D; 2^3\cdot q$</p>
<p>我们引用检验法在$a &#x3D; 17$上并试着找</p>
<p>$$<br>17^q \equiv 1\mod n<br>$$</p>
<p>对于第一个数$a^q, $它是$17^{21618441} \equiv 1\mod n$。测试不通过，现在尝试$a&#x3D;3$，则$3^q \equiv -1 \mod n$，测试也不通过，但我们选择$a&#x3D;23$的时候，有</p>
<p>$$<br>\begin{aligned}<br>    23^q \equiv 40063806 \mod n\<br>    23^{2q}\equiv 2257065 \mod n\<br>    23^{4q} \equiv 1 \mod n<br>\end{aligned}<br>$$</p>
<p>所以$n$也是一个合数，但就是有点难发现。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://monstergeo.github.io/btest/2024/12/10/%E7%B4%A0%E6%95%B0%E6%B5%8B%E8%AF%95/" data-id="cmlgrfvh000206whx3ipfbepx" data-title="素数测试" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/" rel="tag">密码学</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-整数分解和RSA" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/16/%E6%95%B4%E6%95%B0%E5%88%86%E8%A7%A3%E5%92%8CRSA/" class="article-date">
  <time class="dt-published" datetime="2024-09-16T15:22:07.000Z" itemprop="datePublished">2024-09-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/16/%E6%95%B4%E6%95%B0%E5%88%86%E8%A7%A3%E5%92%8CRSA/">RSA 公钥密码系统</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在这个章节，我们来讲RSA，之前的密钥系统基于离散对数问题，这次我们整点不一样的。RSA系统是以其发明者 <em>Ron Rivest , Adi Shamir, Leonard Adleman</em>的名字命名的。</p>
<p>RSA密码系统的安全性依赖下述分歧：</p>
<ul>
<li>设置：令$p,q$是大素数，再令$N &#x3D; pq$和$e,c$是整数</li>
<li>问题：解关于$x$的同余式子$x^e \equiv c \mod N$</li>
<li>容易性：只要知道$p,q$就能简单的计算出$x$</li>
<li>困难部分：若不清楚$p,q$，就无法找到$x$</li>
<li>分歧： 若不知道一些额外的信息，则很难解决这个问题。</li>
</ul>
<p>轮到鲍勃和爱丽丝登场了，鲍勃的密钥是一对大素数$p,q$，它们的公钥是一对$(N,e)$，由乘积$N$和一个与$(p-1)(q-1)$互素的加密指数$e$组成。</p>
<p>现在爱丽丝将明文转化为介于$1$到$N$之间的整数$m$，接着通过计算</p>
<center>

<p>$\begin{aligned}<br>    c \equiv m^e \mod N<br>\end{aligned}$</p>
</center>

<p>加密明文。而整数$c$是爱丽丝的密文，接着将其发给鲍勃。那么鲍勃只需简单的求解同余式子$x^e \equiv c \mod N$ 即可恢复爱丽丝的信息$m$，这是因为鲍勃知道因式分解$N &#x3D; pq$。其次，对于他俩的老对手伊娃，除非他知道如何分解$N$，否则很难解$x^e \equiv c\mod N$</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>我们使用一个比较小的数字来说明RSA系统的实现，注意的是例子并不安全，因为数字太小，伊娃可以很简单的破解。实际使用中我们一般使用数百位数字的模数$N$</p>
<p><strong>RSA密钥创建：</strong></p>
<ol>
<li>鲍勃选择两个私密素数$p &#x3D; 1223$和$q &#x3D; 1987$，接着鲍勃计算它们的公开模数</li>
</ol>
<center>

<p>$\begin{aligned}<br>    N &#x3D; pq &#x3D; 2430101<br>\end{aligned}$</p>
</center>

<ol start="2">
<li>接着鲍勃选择一个公开的加密指数$e &#x3D; 948047$，它满足：</li>
</ol>
<center>

<p>$\begin{aligned}<br>    \gcd(e,(p-1)(q-1)) &#x3D; \gcd (948047,2426892) &#x3D; 1<br>\end{aligned}$</p>
</center>

<p><strong>RSA加密</strong></p>
<ol>
<li>爱丽丝将明文转化为整数</li>
</ol>
<center>

<p>$\begin{aligned}<br>    m &#x3D; 1070777 , 满足 1\leq m &lt; N<br>\end{aligned}$</p>
</center>

<ol start="2">
<li>爱丽丝使用鲍勃的公钥对$(N,e) &#x3D; (2430101, 948047)$计算</li>
</ol>
<center>

<p>$\begin{aligned}<br>    c\equiv m^e \mod N,~c \equiv 1070777^{948047} \equiv 1473513 \mod 2430101<br>\end{aligned}$</p>
</center>

<p>接着爱丽丝发送密文$c &#x3D; 14733513$给鲍勃。</p>
<p><strong>RSA解密</strong></p>
<ol>
<li>由于鲍勃知道$(p-1)(q-1) &#x3D; 1222\cdot 1986 &#x3D; 2426892$，则它可以计算</li>
</ol>
<center>

<p>$\begin{aligned}<br>    ed \equiv 1 \mod (p-1)(q-1) \to 948047\cdot d \equiv 1\mod 2426892<br>\end{aligned}$</p>
</center>

<p>那么简单计算可以得知$d &#x3D; 1051235$</p>
<ol start="2">
<li>接着鲍勃将密文$c &#x3D; 1473513$做计算：</li>
</ol>
<center>

<p>$\begin{aligned}<br>    c^d \mod N , 1473513^{1051235}\equiv 1070777\mod 2430101<br>\end{aligned}$</p>
</center>

<p>那么我们就得到了爱丽丝的明文$m &#x3D; 1070777$了。</p>
<p><strong>注释：</strong> 构成鲍勃公钥的值$N,e$分别称为模数和加密指数。而鲍勃用来解密爱丽丝消息的数字$d$满足：</p>
<center>

<p>$\begin{aligned}<br>    ed\equiv 1\mod (p-1)(q-1)<br>\end{aligned}$</p>
</center>

<p>称为解密指数，显然，若$e,d$是较小的，则加&#x2F;解密可以很简单的得到。但鲍勃不能选择它们都很小，因为一旦确定一个数，另一个数就由模数得到。当然，最重要的是不能取$d&#x3D;e&#x3D;1$。这样就没有加密了。</p>
<p>当然，你也不应该取$e&#x3D;2$，最小可能是$e&#x3D;3$。如果你担心$e$太小那么我们通常可以用$e &#x3D; 2^{16}+1 &#x3D; 65537$，因为我们只需要四次平方和一次乘法即可算的$m^65537$</p>
<p>另一方面，若我们让鲍勃选择较小的$d$，则同余式给出一个很大的$e$。然而若$d$小于$N^{1&#x2F;4}$，则使用连分数定理可以让伊娃破解RSA。</p>
<p>鲍勃的公钥包含数字$N &#x3D; pq$，它是两个秘密素数$pq$的乘积，若伊娃知道$(p-1)(q-1)$的值，则能够简单的解得$x^e \equiv c\mod N$。从而得到明文。</p>
<p>我们展开$(p-1)(q-1)$就有：</p>
<center>

<p>$\begin{aligned}<br>    (p-1)(q-1) &#x3D; pq-p-q+1 &#x3D; N-(p+q)+1<br>\end{aligned}$</p>
</center>

<p>由于$N$是公开的，所以伊娃知道$N$，因此我们只需要确定$p+q$是什么就可以得到$p,q$了。若伊娃知道$p+q$和$pq$，则我们只需要使用二次公式来找到多项式的根即可：</p>
<center>

<p>$\begin{aligned}<br>    x^2 -(p+q)x+pq<br>\end{aligned}$</p>
</center>

<p>那么该二次公式可以分解为$(x-q)(x-q)$。所以它的两个根就是$p,q$。</p>
<h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><p>我们举一个例子说明，若伊娃知道$N &#x3D; pq &#x3D; 66240912547$和$(p-1)(q-1) &#x3D; 66240396760$。</p>
<p>首先我们知道$p+q &#x3D; N+1 - (p-1)(q-1) &#x3D; 515788$</p>
<p>其次，利用二次公式有：</p>
<center>

<p>$\begin{aligned}<br>    x^2 -(p+q)X +N &#x3D; x^2 - 515788x+66240912547 &#x3D; (x-241511)(x-274277)<br>\end{aligned}$</p>
</center>


<h3 id="实施和安全性问题"><a href="#实施和安全性问题" class="headerlink" title="实施和安全性问题"></a>实施和安全性问题</h3><p>接下来我们提及一些安全方面的事实。我们不仅仅只讲密码学背后的数学原理，这样子远远不够。</p>
<h4 id="中间人攻击（Woman-in-the-Middle-Attack）"><a href="#中间人攻击（Woman-in-the-Middle-Attack）" class="headerlink" title="中间人攻击（Woman-in-the-Middle Attack）"></a>中间人攻击（Woman-in-the-Middle Attack）</h4><p>假设伊娃不仅仅是一个窃听者，它还完全控制着爱丽丝和鲍勃的通信网络。在这种情况下可以发起所谓的中间人攻击。</p>
<p>设想一下，在$D-H$密钥交换中，爱丽丝给鲍勃发送值$A &#x3D; g^a$。而鲍勃给爱丽丝发送$B &#x3D; g^b$，而且计算都是在有限域$F_p$中进行的。而现在，由于伊娃控制它们的通信网络，首先伊娃给自己指定了一个指数$e$计算$E &#x3D; g^e$。接着拦截了爱丽丝和鲍勃的通讯，接着伊娃给他们发送了数字E。注意这时候爱丽丝和鲍勃它们通讯是失败的，并没有收到对方的消息而是$E$。</p>
<p>设爱丽丝和鲍勃随后使用它们假定的密钥作为对称密码的密钥并互相发送消息，例如爱丽丝使用$E^a$加密消息$m$，则伊娃截获后可以用$A^e$作为密钥解密他，因此可以得到爱丽丝的信息。然后它使用$B^e$作为密钥重新发送给鲍勃。最后，因为鲍勃可以使用$E^b$解密，所以他不知道存在安全漏洞。</p>
<p>这个攻击的阴险之处在于，伊娃并没有破解密码，而是可以成功的读取爱丽丝和鲍勃的通讯而它们不知道他的成功。</p>
<h4 id="被截获了密文"><a href="#被截获了密文" class="headerlink" title="被截获了密文"></a>被截获了密文</h4><p>若爱丽丝发布了两个不同的指数$e_1,e_2$用于它的公开模数$N$，而鲍勃使用了爱丽丝的两个指数加密明文$m$。若被伊娃截获密文。那么</p>
<center>

<p>$\begin{aligned}<br>    c_1 \equiv m^{e_1} \mod N 和 c_2\equiv m^{e_2} \mod N<br>\end{aligned}$</p>
</center>


<p>那么我们可以选择两个数，计算$u,v$</p>
<center>

<p>$\begin{aligned}<br>    e_1\cdot u +e_2\cdot v &#x3D; \gcd(e_1,e_2)<br>\end{aligned}$</p>
</center>

<p>然后用$u,v$计算：</p>
<center>

<p>$\begin{aligned}<br>    e_1^u\cdot e^v_2 \equiv (m^e_1)^u\cdot (m^{e_2})^v \equiv m^{e_1\cdot u +e_2\cdot v} &#x3D; m^{\gcd(e_1,e_2)} \mod N<br>\end{aligned}$</p>
</center>


<p>若$\gcd(e_1,e_2) &#x3D;1$，则直接恢复明文。更一般的，若存在多个互素的指数$e_1,\cdots ,e_n$使得$\gcd(e_1,\cdots,e_n)&#x3D;1$，则我们可以恢复明文。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://monstergeo.github.io/btest/2024/09/16/%E6%95%B4%E6%95%B0%E5%88%86%E8%A7%A3%E5%92%8CRSA/" data-id="cmlgrfvfw001f6whx5bpzgc7x" data-title="RSA 公钥密码系统" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/" rel="tag">密码学</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-群论概述" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/12/%E7%BE%A4%E8%AE%BA%E6%A6%82%E8%BF%B0/" class="article-date">
  <time class="dt-published" datetime="2024-09-12T13:22:29.000Z" itemprop="datePublished">2024-09-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/12/%E7%BE%A4%E8%AE%BA%E6%A6%82%E8%BF%B0/">群论概述</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>我们这章短暂的回顾一下群论。</p>
<p>这个章节从我们强调一些$F^*_p$中乘法的重要属性，并指出这些属性出现许多情况下。</p>
<p>那么对基础的$F^*_p$的属性探讨一下：</p>
<ul>
<li>存在元素$1\in F^*_p$满足对所有的$a\in F^*_p$有$1\cdot a &#x3D; a$</li>
<li>每个 $a\in F^*_p$都存在$a^{-1}\in F^*_p$满足$a\cdot a^{-1} &#x3D; a^{-1}\cdot a &#x3D; 1$</li>
<li>满足乘法结合律 $a\cdot (b\cdot c) &#x3D; (a\cdot b)\cdot c$对所有$a,b,c\in F^*_p$成立。</li>
<li>满足交换 $a\cdot b &#x3D; b \cdot a$对所有$a,b\in F^*_p$成立。</li>
</ul>
<p>对群的研究是从加法和乘法开始的。这是群概念的由来：</p>
<h4 id="定义1："><a href="#定义1：" class="headerlink" title="定义1："></a>定义1：</h4><p>集合$G$和一些规则组成一个群，我们使用$*$表示这种规则，它用于将两个元素$a,b\in G$组合得到一个元素，但要完成运算需要具备如下三个条件</p>
<ul>
<li><p>[单位] 存在$e\in G$使得 $e*a &#x3D; a*e &#x3D; a$对所有$a\in G$成立，</p>
</li>
<li><p>[逆] 对每个$a\in G$存在唯一的$a^{-1} \in G$使得$a*a^{-1} &#x3D; e$</p>
</li>
<li><p>[结合] 对所有$a,b,c\in G$有$a*(b<em>c) &#x3D; (a</em>b)*c$</p>
</li>
</ul>
<p>满足下述条件的群我们称为阿贝尔群</p>
<ul>
<li>[交换] 对所有的$a,b,c\in G$有$a*b &#x3D; b*a $</li>
</ul>
<p>若$G$有有限个元素，则称$G$为有限群，$G$的阶指的是$G$中元素的数量，一般使用$\mid G\mid$表示。</p>
<p>我们将$g*g*g*\cdots *g$(n次)称为$g$的次幂，记为$g^n$</p>
<h4 id="定义2："><a href="#定义2：" class="headerlink" title="定义2："></a>定义2：</h4><p>设$G$是群，$a\in G$是群中的一个元素，设存在一个正整数$d$，使得$a^d &#x3D;e$，这个最小的$d$称为$a$的阶。如果不存在这样的$d$，则称$a$具有无限阶。</p>
<h4 id="命题1："><a href="#命题1：" class="headerlink" title="命题1："></a>命题1：</h4><p>令$g$是有限群，则每个$G$的元素都是有限阶的。进一步说，若$a\in G$阶为$d$且$a^k &#x3D; e$，则$d\mid k$</p>
<p><strong>证明：</strong> 由于$G$有限，序列</p>
<center>

<p>$\begin{aligned}<br>    a,a^2,a^3,a^4,\cdots<br>\end{aligned}$</p>
</center>

<p>这个序列最终是一定会重复的，即存在正整数$i,j$且$i &lt; j$使得$a^i&#x3D;a^j$。将两边乘上一个$a^{-i}$就有$a^{i-j} &#x3D;e$，因为$i - j&gt;0$，这证明了$a$的某个幂等于$e$。不妨设$d$是满足条件$a^d &#x3D; e$的最小正整数。</p>
<p>现在设$k\geq d$也满足$a^k &#x3D; e$。我们用$k$去除$d$，将得到</p>
<center>

<p>$\begin{aligned}<br>    k &#x3D; dq+r , 0 \leq r &lt; d<br>\end{aligned}$</p>
</center>

<p>由于$a^k &#x3D; a^d &#x3D; r$，比较两边幂次就有</p>
<center>

<p>$\begin{aligned}<br>    e &#x3D; a^k &#x3D; a^{dq+r} &#x3D; e^q*e^r &#x3D; a^r<br>\end{aligned}$</p>
</center>

<p>由于$d$是$a$的最小幂次，则$r$必须是$0$。因此我们得到$k &#x3D; dq$有$d\mid q$</p>
<h4 id="命题2：拉格朗日定理"><a href="#命题2：拉格朗日定理" class="headerlink" title="命题2：拉格朗日定理"></a>命题2：拉格朗日定理</h4><p>令$G$是有限群和令$a\in G$，则$a$的阶被$G$的阶整除。</p>
<p>更具体一点的，令$n &#x3D; \mid G\mid $是$G$的阶，令$a\in G$的阶是$d$，则</p>
<center>

<p>$\begin{aligned}<br>    a^n &#x3D; e 和 d\mid n<br>\end{aligned}$</p>
</center>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://monstergeo.github.io/btest/2024/09/12/%E7%BE%A4%E8%AE%BA%E6%A6%82%E8%BF%B0/" data-id="cmlgrfvh300246whxdcy704bf" data-title="群论概述" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/" rel="tag">密码学</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-ElGamal公钥系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/09/ElGamal%E5%85%AC%E9%92%A5%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2024-09-09T13:56:03.000Z" itemprop="datePublished">2024-09-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/09/ElGamal%E5%85%AC%E9%92%A5%E7%B3%BB%E7%BB%9F/">ElGamal公钥系统</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>上一章我们讲了$D-H$密钥一种公开共享随机密钥的方法，但总的来说并没有实现作为公钥密码体系的全部目的，因为密码系统允许交换特定信息，而不仅仅是一串随机的bit。第一个公钥密码体系是$RSA$，<em>Shamir</em>和<em>Adleman</em>在1978提出。但我们这节讲的系统是在D-H写的论文之后发展比较自然的的系统。ElGamal公钥加密算法基于离散对数问题，接下来我们要谈的是基于$F^*_p$的离散对数问题的ElGamal Key版本。</p>
<p>爱丽丝选择一个数字$a$作为其私钥，并着手计算</p>
<center>

<p>$\begin{aligned}<br>    A \equiv g^a \mod p<br>\end{aligned}$</p>
</center>

<p>和D-H密钥交换相似之处为，爱丽丝将会公布她的公钥$A$，而保留私钥。</p>
<p>现在我们假设鲍勃想用爱丽丝的公钥$A$加密信息，首先我们假设鲍勃想用公钥$A$加密信息，设鲍勃的信息$m$是介于$0$到$p$之间的整数（可以用ASCII编码转换），为了加密$m$，首先我们选择一个$\mod p$的数字$k$，用它加密信息，然后将其丢弃，数字$k$称为临时密钥，因为其仅仅是用来加密单个信息</p>
<p>鲍勃取一段明文$m$，用随机临时密钥$k$和爱丽丝的公钥$A$计算两个等式</p>
<center>

<p>$\begin{aligned}<br>    c_1 \equiv g^k \mod p 和 c_2 \equiv m A^k \mod p<br>\end{aligned}$</p>
</center>

<p>则鲍勃的加密得到一对参数$(c_1,c_2)$。他将其发给爱丽丝。</p>
<p>那么爱丽丝如何解密$(c_1,c_2)$呢，由于爱丽丝知道$a$，则他可以计算值</p>
<center>

<p>$\begin{aligned}<br>    x \equiv c_1^a \mod p<br>\end{aligned}$</p>
</center>

<p>同样的也可以计算$x^{-1}$，接着将$c_2$乘$x^{-1}$，那我们就得到了明文$m$，我们来仔细看看$c_2 x^{-1}$</p>
<center>

<p>$\begin{aligned}x^{-1}\cdot c_{2}&amp;\equiv(c_1^a)^{-1}\cdot c_2\pmod{p}\&amp;\equiv(g^{ak})^{-1}\cdot(mA^k)\pmod{p}\&amp;\equiv(g^{ak})^{-1}\cdot(m(g^a)^k)\pmod{p}\&amp;\equiv m\pmod{p}\end{aligned}$</p>
</center>

<p>现在，若我们想破解密码，伊娃的任务是什么呢？首先，伊娃知道公共参数$p,g$，并且她知道$A &#x3D; g^a\mod p$的值。由于$A$是公钥，若伊娃能解决这个离散对数问题，则就能找到$a$并解密。</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>爱丽丝选择素数$p &#x3D; 467$和原根$g&#x3D;2$，接着选择数$153$，接着计算公钥</p>
<center>

<p>$\begin{aligned}<br>A \equiv g^a \equiv 2^{153} \equiv 224 \mod 467<br>\end{aligned}$</p>
</center>


<p>接着，鲍勃的明文为$m &#x3D; 331$，它选择一个临时密钥$k &#x3D; 197$，则它需要计算两个值</p>
<center>

<p>$\begin{aligned}<br>    c_1 \equiv 2^{197}\equiv 87 \mod 467 和 c_2 \equiv 331\cdot 224^{197}\equiv 57\mod 467<br>\end{aligned}$</p>
</center>

<p>接着鲍勃发送$(87,57)$给爱丽丝。</p>
<p>爱丽丝用$a &#x3D;153$计算</p>
<center>

<p>$\begin{aligned}<br>    x\equiv c_1^a \equiv 87^{153} \equiv 367 \mod 467 \to x^{-1} \equiv 14\mod 467<br>\end{aligned}$</p>
</center>

<p>最后，我们就计算$c_2x^{-1} &#x3D; 57\cdot 14 \equiv 331 \mod 467$</p>
<p>就得到明文了。</p>
<p><strong>注意：</strong> 消息对$(c_1,c_2)$是2个字段组成，所以写下密文需要的位数一般是明文的两倍。</p>
<p>接着我们有一个问题，对于伊娃来说，ElGamal系统是否像D-H问题一样难以攻击？或者，我们可以引入一些巧妙的信息，使得它发挥了后门的作用。这样我们即使解决不了D-H问题也能够有效的获得信息。那么我们的任务是诸如识别像D-H这样的底层难题，并证明像ElGamal这样给定的加密构造至少和这些问题一样难以攻击。</p>
<p>那么我们实际的思考的问题就是：</p>
<h4 id="命题1"><a href="#命题1" class="headerlink" title="命题1"></a>命题1</h4><p>选定素数$p$和基$g$以用于$ElGamal$加密。设伊娃可以访问一个oracle(黑盒子)，oracle可以解密任意ElGamal公钥加密的密文，则伊娃可以使用它解决$D-H$问题。</p>
<p><strong>证明：</strong> 在$D-H$问题中，我们将得到两个密文 $A,B$，其中</p>
<center>

<p>$\begin{aligned}<br>    A\equiv g^a\pmod{p}\quad\text{and}\quad B\equiv g^b\pmod{p}<br>\end{aligned}$</p>
</center>

<p>则伊娃需要计算$g^{ab}\mod p$的值。但伊娃知道$A,B$而不知道$a,b$</p>
<p>现在，伊娃向oracle发送素数$p$，基$g$，一个假定的公钥$A$和一个假定的密文$(c_1,c_2)$。则oracle返回</p>
<center>

<p>$\begin{aligned}<br>    (c_1^a)^{-1}\cdot c_2\pmod{p}.<br>\end{aligned}$</p>
</center>

<p>最后一步，我们需要思考什么样的值是好的，使得问题能够解决，一种选择是$c_1 &#x3D; B &#x3D; g^b$和$c_2 &#x3D;1$。由这个输入，则返回$(g^{ab})^{-1}\mod p$，我们只需要对$\mod p$取逆就得到$g^{ab} \mod p$。于是我们就解决了$D-H$问题。</p>
<p>另一种方法，我们不试图解决DLP而是直接解决D-H问题。</p>
<p>伊娃选择任意的$c_2$，并告诉oracle公钥是$A$，密文是$(B,c_2)$。则返回</p>
<center>

<p>$\begin{aligned}<br>    m\equiv(c_1^a)^{-1}\cdot c_2\equiv(B^a)^{-1}\cdot c_2\equiv(g^{ab})^{-1}\cdot c_2\pmod{p}.<br>\end{aligned}$</p>
</center>

<p>在得道oracle返回的值$m$之后，我们只需要计算</p>
<center>

<p>$\begin{aligned}<br>    m^{-1}\cdot c_2 \equiv g^{ab} \mod p<br>\end{aligned}$</p>
</center>

<p>就求出了$g^{ab}\mod p$的值。但这次解决问题之后我们依然不知道$a,b$，所以我们只是解决了D-H问题而不是DLP。</p>
<p><strong>注意：</strong> 这种攻击称为选择密文攻击，我们刚才的证明告诉了我们ElGamal系统是可以抵御选择密文攻击的。更进一步，若假设$D-H$问题很难，则密文是安全的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://monstergeo.github.io/btest/2024/09/09/ElGamal%E5%85%AC%E9%92%A5%E7%B3%BB%E7%BB%9F/" data-id="cmlgrfvf000076whx77ip1dqy" data-title="ElGamal公钥系统" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/" rel="tag">密码学</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-离散对数问题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/08/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0%E9%97%AE%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2024-09-08T09:52:19.000Z" itemprop="datePublished">2024-09-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/08/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0%E9%97%AE%E9%A2%98/">离散对数问题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>这节先讲$\mod p$的离散对数问题，还有一个椭圆曲线版本的下次讲。上节讲了，关于非对称密钥的提出是由<br>*Diffie *和 <em>Hellman</em>提出的。而第一个公钥也是，它基于有限域$F_p$中的离散对数问题。其中$F_p$是一个具有$p$个元素的域，$p$是素数。其次，对于一个域$\mathrm{Z}&#x2F;p\mathrm{Z}$也是具有$p$个元素的，所以我们有时会交替使用，那么涉及到$F_p$时，我们使用等号，提及$\mathrm{Z}&#x2F;p\mathrm{Z}$时，我们使用同余符号。</p>
<p>令$p$是素数，则存在一个本原元素$g$，将使得$F_p$上的元素都是$g$的幂次。特别的，由费马小定理可知，$g^{p-1} &#x3D; 1$。而$F_p$的乘法群是一个只有$p-1$个元素的域。即：</p>
<center>

<p>$\begin{aligned}<br>    1,g,g^2,g^3,\cdots,g^{p-2}\in F^*_p<br>\end{aligned}$</p>
</center>

<h4 id="定义：离散对数问题（DLP）"><a href="#定义：离散对数问题（DLP）" class="headerlink" title="定义：离散对数问题（DLP）"></a>定义：离散对数问题（DLP）</h4><p>令$g$是$F_p$的本原根且令$h$是$F_p$的非零元素。则离散对数问题(DLP)是指找一个指数$x$使得</p>
<center>

<p>$\begin{aligned}<br>    g^x\equiv h \mod p<br>\end{aligned}$</p>
</center>

<p>的问题 。数字$x$称为$h$的离散对数。它是以$g$为底的，我们记为$\log_g(h)$</p>
<p><strong>注意1：</strong> 离散对数问题是一个良定义问题(well-posed problem)。即找到整数$x$使得$g^x &#x3D; h$。另一方面，若$x$被我们找到了一个解，则这意味着存在无穷多个解：由费马小定理，$g^{p-1} \equiv 1\mod p$，若$x$是一个$g^x&#x3D;h$的解，则$x+k(p-1)$也是另一个方程的解，注意</p>
<center>

<p>$\begin{aligned}<br>    g^{x+k(p-1)} &#x3D; g^x\cdot (g^{p-1})^k \equiv h\cdot 1^k \equiv h \mod p<br>\end{aligned}$</p>
</center>

<p>不难验证，$\log_g$给出了一个良定义的函数。</p>
<center>

<p>$\begin{aligned}<br>    \log_g:F^*_p \to \frac{\mathrm{Z}}{(p-1)\mathrm{Z}}<br>\end{aligned}$</p>
</center>

<p>有时为了具体说明，我们将离散对数称为满足同余式$g^x\equiv h \mod p$且位于$0$和$p-2$之间的整数x。</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>$p &#x3D; 56509$是素数，我们可以验证$2$是$\mod p$的一个原根（理论上说，域$F_{56509}$存在$56508$个元素）。若我们想计算$h &#x3D; 38679$的离散对数，一种显而易见的方法就是计算：</p>
<center>

<p>$\begin{aligned}<br>    2^2, 2^3,\cdots \mod 56509<br>\end{aligned}$</p>
</center>

<p>直到得到$38679$的幂。就别用你那个破纸在那画了，用计算机，我们得到$\log_p(h) &#x3D;  11235$。</p>
<p>我们转化为群论的一般结论：</p>
<h4 id="定义：群-G-上的DLP"><a href="#定义：群-G-上的DLP" class="headerlink" title="定义：群$G$上的DLP"></a>定义：群$G$上的DLP</h4><p>令$G$是群，则$G$上的DLP问题指的是对$G$中的任意两个元素$g,h$，求整数$x$满足：</p>
<center>

<p>$\begin{aligned}<br>    \underbrace{g\cdot g\cdot g\cdots}_{x\text{次}}&#x3D;h.<br>\end{aligned}$</p>
</center>

<h3 id="Diffie-Hellman密钥交换"><a href="#Diffie-Hellman密钥交换" class="headerlink" title="Diffie-Hellman密钥交换"></a><em>Diffie-Hellman</em>密钥交换</h3><p>D-H密钥交换解决了下述问题：</p>
<p>爱丽丝和鲍勃想要共享一个用于对称密码的密钥，但他们的通信方式是不安全的。则交换的每条信息都能被他们的对手伊娃看到，那么爱丽丝和鲍勃两人如何在共享密钥的同时不被伊娃发现呢。D-H的绝妙见解是，$F^*_p$上的离散对数问题提供了一个可能的解决方案。</p>
<p>第一步，爱丽丝和鲍勃取一个较大的素数$p$和$\mod p$的非零整数$g$。然后他们将$p$和$g$的值公开，例如可以发到自己的个人博客上。所以伊娃也可以看到。当然，选择$g$的时候最好是一个较大的素数。</p>
<p>下一步，爱丽丝将选择一个不向任何人透露的秘密整数$a$，同时鲍勃选择一个私密的整数$b$。然后分别用这两个私密整数计算</p>
<center>

<p>$\begin{aligned}<br>    \underbrace{A\equiv g^a\pmod{p}}<em>{\text{爱丽丝}}\quad\text{和}\quad\underbrace{B\equiv g^b\pmod{p}}</em>{\text{鲍勃}}.<br>\end{aligned}$</p>
</center>

<p>接着鲍勃和爱丽丝交换他们计算出来的值，注意的是，伊娃也可以看到这些值。这是我们一开始的假设。接着将用私密整数计算</p>
<center>

<p>$\begin{aligned}<br>    \underbrace{A’\equiv B^a\pmod{p}}<em>{\text{爱丽丝负责的部分}}\quad\text{和}\quad\underbrace{B’\equiv A^b\pmod{p}}</em>{\text{鲍勃负责的部分}}.<br>\end{aligned}$</p>
</center>

<p>如果正确，那实际上计算出来的值是一样的，注意到</p>
<center>

<p>$\begin{aligned}<br>    A’\equiv B^a\equiv(g^b)^a\equiv g^{ab}\equiv(g^a)^b\equiv A^b\equiv B’\pmod{p}.<br>\end{aligned}$</p>
</center>

<p>总结一下：</p>
<h4 id="D-H密钥交换流程"><a href="#D-H密钥交换流程" class="headerlink" title="D-H密钥交换流程"></a>D-H密钥交换流程</h4><ol>
<li>选择大素数$p$和在关于素数$p$的域$F_p^*$中的具有大阶数的$g$</li>
<li>然后爱丽丝和鲍勃各自选择一个私密整数$a,b$，然后计算$A\equiv g^a \mod p$和$B\equiv g^b\mod p$</li>
<li>接着，爱丽丝将$A$发送给鲍勃，鲍勃将$B$发送给爱丽丝。</li>
<li>最后爱丽丝计算$B^a \mod p$，鲍勃计算$A^b\mod p$。注意共享值是$B^{a}\equiv(g^{b})^{a}\equiv g^{ab}\equiv(g^{a})^{b}\equiv A^{b}\pmod{p}.$</li>
</ol>
<h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><p>现在我们选择素数$p &#x3D; 941$和本原根$g &#x3D;627$，爱丽丝选择$a &#x3D;347$，则$A &#x3D; 390 \equiv 627^{347}\mod 941$，类似的，鲍勃选择$b&#x3D;781$并计算$B &#x3D; 691 \equiv 627^{781}\mod 941$。接着爱丽丝给鲍勃发送$390$，鲍勃给爱丽丝发送$691$。而且我们应该将$A,B$视为公开发送的。$a,b$是保密的。然后，理论上说，爱丽丝和鲍勃都能计算到数字</p>
<center>

<p>$\begin{aligned}<br>    470\equiv627^{347\cdot781}\equiv A^b\equiv B^a\pmod{941},<br>\end{aligned}$</p>
</center>

<p>则$470$是他们共享的密钥。</p>
<p>若此时伊娃想破解这个秘密，只要能解决其中任何一个问题，他就能解出爱丽丝和鲍勃的的密钥：</p>
<center>

<p>$\begin{aligned}<br>    627^a \equiv 390 \mod 941 或者 627^b \equiv 691 \mod 941<br>\end{aligned}$</p>
</center>

<p>这是伊娃在没有爱丽丝和鲍勃帮助的情况下得到秘密共享值的唯一方法。</p>
<p>上述例子选择的$p$比较小，所以计算机可以在很短的时间给出答案。总的来说，伊娃的困境在于，若知道$A,B$，所以他也知道$g^a$和$g^b$的值，如果伊娃有能力解决DLP，则他可以找到$a$和$b$。之后就能很简单的计算出爱丽丝和鲍勃共享的私密值$g^{ab}$。因此，若伊娃无法解决DLP，那么鲍勃和爱丽丝就安全了。而该安全性实际上取决于以下可能更简单的问题。</p>
<h4 id="定义-Diffie-Hellman-Problem-DHP"><a href="#定义-Diffie-Hellman-Problem-DHP" class="headerlink" title="定义 Diffie-Hellman Problem(DHP)"></a>定义 <em>Diffie-Hellman Problem</em>(DHP)</h4><p>令$p$是素数，$g$是整数，则$DHP$指的是根据已知的$g^a\mod p$和$g^b\mod p$计算$g^{ab}\mod p$的问题。</p>
<p>这和我们之前提到的非对称密码是很相似的，区别在于本质上还是一个对称密码。即可以通过自己的私钥去解密别人发送过来的密文。回到问题上来，显然的是$DHP$并不比$DLP$难，若伊娃可以解决DLP，则解决DHP是容易的，但反过来就不一定了。如果伊娃有一个可以有效解决DHP的方法，但能不能解决DLP是尚未清楚的事实。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://monstergeo.github.io/btest/2024/09/08/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0%E9%97%AE%E9%A2%98/" data-id="cmlgrfvgy001y6whxborc56q0" data-title="离散对数问题" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/" rel="tag">密码学</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-对称和非对称加密" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/05/%E5%AF%B9%E7%A7%B0%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/" class="article-date">
  <time class="dt-published" datetime="2024-09-05T09:26:54.000Z" itemprop="datePublished">2024-09-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/05/%E5%AF%B9%E7%A7%B0%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/">对称和非对称加密</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>这一张我们讲什么是对称和非对称密码。为了了解什么是对称加(解)密，我们假设有这么一个场景，鲍勃给艾米共享自己的密钥$k$，使用密钥$k$，则他们可以同时加解密信息。所以为了完成这个动作，鲍勃和艾米必须具备相同的知识和能力，即同时拥有密钥。基于此共识，此类型的密码称为对称密码。</p>
<p>从数学上看，对称加密就是用一个可能的密钥空间$K$中选择一个密钥$k$来加密一个可能的消息空间$M$中的信息$m$，而加密的结果是密文空间$C$中的密文$c$。</p>
<p>所以，我们可以把加密的过程看成是一个函数：</p>
<center>

<p>$\begin{aligned}<br>    e:K\times M\to C<br>\end{aligned}$</p>
</center>

<p>其中$K\times C$是$K,C$的笛卡尔积，表示用的密钥和文段，其范围是$C$。类似的，解密也是一个函数</p>
<center>

<p>$\begin{aligned}<br>    d:K\times C\to M<br>\end{aligned}$</p>
</center>

<p>因此，我们希望这个函数是具备“反函数”的，即我们能够还原密文，否则就没任何意义了。可以表示为：</p>
<center>

<p>$\begin{aligned}<br>    d(k,e(k,m)) &#x3D; m 对所有 k\in K和m\in M成立<br>\end{aligned}$</p>
</center>

<p>其次，由于密钥$k$是选定的，则我们可以用下标来代替笛卡尔积。</p>
<center>

<p>$\begin{aligned}<br>    e_k:M\to C 和 d_k :C\to M<br>\end{aligned}$</p>
</center>

<p>并且满足 $d_k(e_k(m)) &#x3D; m$对所有$m\in M$成立。</p>
<p>对于艾米和鲍勃来讲，最安全的做法是，即使第三人伊娃知道加密方法，即知道$e,d$函数，而不知道密钥$k$，则伊娃不能得到信息。这是现代密码学的一个基本前提，即$Kerckhoff$原理，该原理认为密码系统的安全新应该仅取决于密钥的保密性，而不是加密算法本身的保密性。</p>
<p>基于此，若$(K,M,C,e,d)$是一个完整的密码，那么他必须具备下列要求：</p>
<ul>
<li><p>对任意密钥$k\in K$和信息$m\in M$，计算密文$e_k(m)$的时候必须是较简单的</p>
</li>
<li><p>对任意和密钥$k\in K$和密文$c\in C$，在计算明文的时候必须是简单的。</p>
</li>
<li><p>给定使用密钥$k$加密的一个或多个密文$c_1,c_2,\cdots,c_n\in C$，如若不知道$k$，则计算相应的明文$d_k(c_1)\cdots,d(c_n)$是困难的。</p>
</li>
<li><p>该条一个理想属性，尽管它实现是不简单的：给定一对或者多对明文和他们对应的密文$(m_1,c_1),(m_2,c_2),\cdots,(m_n,c_n)$，则必须很难解密任何不在给定表中的密文$c$，这被称为针对选择明文攻击的安全性。</p>
</li>
</ul>
<p>而现在，我们并不简单的说容易和困难究竟是何语义，非正式的来说，在没给定义之前，我们简单的认为，一个密码“简单”是指在计算机不超过一秒就能得到的，而困难指的是要计算几年才能完成破解。</p>
<p>接下来，我们基于编码块来使用对称加密</p>
<h3 id="编码块的对称加密"><a href="#编码块的对称加密" class="headerlink" title="编码块的对称加密"></a>编码块的对称加密</h3><p>为了方便，我们将明文空间$M$的元素看做是由长度为$B$的二进制串。即用$B$个$1$或$0$填充的字符串，我们将$B$称为密码快的大小。若明文以少于密码块长度的位结尾，则我们在里面继续填充0。</p>
<p>由于加解密都是针对一个块，因此我们只需要研究一个块即可，而明文块是一串长度为$B$的二进制字符串。 即，明文$M$将转为满足$0 \leq m &lt; 2^B$的整数集$M$，它如下所示：</p>
<center>

<p>$\begin{aligned}<br>    \overbrace{m_{B-1}m_{B-2}\cdots m_{2}m_{1}m_{0}}^{\text{list of }B\text{ bits of }m}\longleftrightarrow\overbrace{m_{B-1}\cdot2^{B-1}+\cdots+m_{2}\cdot2^{2}+m_{1}\cdot2+m_{0}}^{\text{integer between }0\text{ and }2^{B}-1}.<br>\end{aligned}$</p>
</center>

<p>其中$m_0 ,\cdots,m_{B-1}$是一些$0$或者$1$。</p>
<p>类似的，我们也可以将密钥空间$K$和密文空间$C$用一组与特定的块大小表示。为了表示方便，我们用$B_k,B_m,B_c$表示密钥，明文和密文的大小。此前我们已经用正整数确定了集合$K,M,C$（用ASCII码）</p>
<center>

<p>$\begin{aligned}<br>K &#x3D;&amp; {k\in \mathrm{Z}: 0\leq k &lt; 2^{B_k}}\<br>M &#x3D;&amp; {m\in \mathrm{Z}: 0\leq m &lt; 2^{B_m}}\<br>C &#x3D;&amp; {c\in \mathrm{Z}: 0\leq c &lt; 2^{B_c}}<br>\end{aligned}$</p>
</center>

<p>那么这将引发另一个问题，我们需要选择多大的密钥块，若密钥块较小，则伊娃可以通过遍历密钥来破解密码。</p>
<p>这种攻击叫暴力破解，若空间至少存在$280$个元素，则暴力破解基本上是不可能的，因此鲍勃和艾米至少该选择$B_k \geq 80$的密钥。</p>
<h3 id="对称加密的例子"><a href="#对称加密的例子" class="headerlink" title="对称加密的例子"></a>对称加密的例子</h3><p>在继续深入理论和符号的扭曲中，我们先暂停一下，看看这些基本对称密码的数学描述。</p>
<p>令$p$是较大的素数，设$2^{159} &lt; p &lt; 2^{160}$。而艾米和鲍勃令密钥空间$K$、明文空间$M$和密文空间$C$三者为同一个空间，则</p>
<center>

<p>$\begin{aligned}<br>    K &#x3D; M &#x3D; C &#x3D;{1,2,3,\cdots,p-1}<br>\end{aligned}$</p>
</center>

<p>更进一步的，我们令这个空间是$F^*_p$，即$p$个元素的域。</p>
<p>那么艾米和鲍勃随机选择一个密钥$k\in K$，即选择一个$1\leq k &lt; p$的整数$k$。而他们选择的加密函数$e_k$定义如下：</p>
<center>

<p>$\begin{aligned}<br>    e_k(c) \equiv k\cdot m \mod p<br>\end{aligned}$</p>
</center>

<p>这里的意思是，通过模运算，我们可以将文字映射到$1$到$p$之间的正整数。该整数可以由$k\cdot m\mod p$所替换。而对应的解密函数$d_k$是</p>
<center>

<p>$\begin{aligned}<br>    d_k(m) \equiv k’\cdot c \mod p<br>\end{aligned}$</p>
</center>

<p>其中密钥$k’$是$k$的逆，尽管$p$是非常大的，但拓展的欧几里得算法可以允许我们在$2\log_2 p+2$步的复杂度内计算出$k$。</p>
<p>在这种情况下显然伊娃难以解决$k$，因为我们选择的$p$在$2^{160}$下而$k$大约也是$2^{160}$种可能。反之，若知道密文是什么，也是很难破解的。注意加密函数</p>
<center>

<p>$\begin{aligned}<br>    e_k:M\to C<br>\end{aligned}$</p>
</center>

<p>选择任意的一个密钥$k$，在这种情况下函数是一个满射，这意味着对每个$c\in C$和$k\in K$都存在一个$m\in M$使得$e_k(m) &#x3D;c$，那么对于密钥，我们有</p>
<center>

<p>$\begin{aligned}<br>    k \equiv m^{-1}\cdot c\mod p<br>\end{aligned}$</p>
</center>

<p>这表明我们鲍勃和艾米设计的这个密码是具有在刚才列出的前三点属性，即知道密钥的人可以轻松解密和加密，但若不知道$k$则很难得到这一步。但这密码不具备第四个属性，若知道一个明文&#x2F;密文对$(m,c)$，则可以利用上面$k$的公式轻松得到密钥。</p>
<p>接下来我们分析一下，若不进行模$p$操作，则上述函数$e_k$变成简单的乘法，这时候具备条件1，2而不存在3、4，即不知道$k$也可以简单的破解到明文。更进一步的，若存在多个密文$c_1,\cdots,c_n$，则一个好的选择是</p>
<center>

<p>$\begin{aligned}<br>    \gcd (c_1,\cdots,c_n) &#x3D; \gcd(k\cdot m_1,\cdots , k\cdot m_n) &#x3D; k\cdot \gcd(m_1,\cdots,m_n)<br>\end{aligned}$</p>
</center>

<p>即$k$本身或者是小点的倍数。而计算这种东西也是简单的。</p>
<p>在上面的分析之后，一个显然的事实是，若我们采用模运算，则模运算具有很奇妙的混合效果，可以破坏可分等属性。但这不是我们最后的解决方案，改密码对明文攻击还是较脆弱的。如果伊娃可以同时获得密文c和对应的明文m，他依然可以计算轻松得到密钥。$k &#x3D; m^{-1}\cdot c\mod p$，所以即使只有一对，也足以破解密钥。</p>
<h3 id="随机比特序列和对称密码"><a href="#随机比特序列和对称密码" class="headerlink" title="随机比特序列和对称密码"></a>随机比特序列和对称密码</h3><p>在饶了一大圈之后，我们回到最基本的问题，是否可以用单个相对较短的密钥$k$来安全高效的发送任意长的信息？我们给出一个构造：</p>
<center>

<p>$\begin{aligned}<br>    R:K\times \mathrm{Z}\to {0,1}<br>\end{aligned}$</p>
</center>

<p>它具备一下属性：</p>
<ol>
<li>对所有$k\in K$和所有$j\in \mathrm{Z}$，它容易计算$R(k,j)$。</li>
<li>给定任意长度的整数序列$j_1,\cdots,j_n$和给定所有的值$R(k,j_1),\cdots,R(k,j_n)$，但$k$是难以计算的。</li>
<li>给定正整数列$j_1,\cdots,j_n$和给定值。</li>
</ol>
<center>

<p>$\begin{aligned}<br>    R(k,j_1),\cdots,R(k,j_n)<br>\end{aligned}$</p>
</center>

<p>对于列表中没出现的$j_i$和其对应的值，猜到密码的概率不超过$1&#x2F;2$</p>
<p>若我们能找到一个函数$R$，它满足上述3点，则我们可以用它将密钥$k$转换为一个比特列</p>
<center>

<p>$\begin{aligned}<br>    R(k,j_1),\cdots,R(k,j_n)<br>\end{aligned}$</p>
</center>

<p>并且我们可以用该序列作为一次性的密钥。</p>
<p>该方法一个问题是，$R$是一个伪随机生成器，而不是真随机的。但，直到现在还是没有人证明伪随机数生成器的存在。但有一些经得住考验的方案，以下是构造上述$R$的两种方法：</p>
<p>第一种方法是重复的应用一些特别的混合操作，这些混合操作适用于高效的计算，并且非常难解开。这种方法是大多数实际对称密码的基础，包括数据加密标准DES和高级加密标准AES。目前使用广泛的两个系统就是这些了。</p>
<p>第二种方法是用一个函数构造$R$，该函数的逆是一个我们认为非常难的数学问题。而这个方法提供了让我们省心的理论基础。但不好的一点在于，该类型的已知构造都不如一些特殊构造有效，对实际应用程序没什么吸引力。</p>
<h3 id="非对称密码的首次出现"><a href="#非对称密码的首次出现" class="headerlink" title="非对称密码的首次出现"></a>非对称密码的首次出现</h3><p>对称密码基于艾米和鲍勃两人知道密钥。但是如何传达密钥是个问题。在每一次交流都被伊娃监控的情况下，还有机会交换一个密钥吗？大多数人的第一反应是这不可能，因为伊娃看到了鲍勃和艾米的每次交流。但Diffie 和 Hellman的绝妙见解下是可能的，这个问题的有效解决方案的搜索称为公钥（非对称）密码学，这是我们要研究的主要部分。</p>
<p>回到正题，我们继续假设，艾米和鲍勃要如何在伊娃监视下传送信息。现在，艾米买了一个顶部带有窄槽的保险箱，并将保险箱放在广场上，世界上的每个人都可以随便的检查保险箱，看看它是否安全。鲍勃将他给艾米的信写在纸上，并将他塞在保险箱顶部的孔里，而现在只有一个拥有保险箱钥匙的人能打开，也就是说只有艾米能看到保险箱里面的东西。在这个场景中，我们说保险箱是公钥，加密算法是将信息放入插槽的过程，解密算法是用密钥大概保险箱的过程。这样密码系统和实际公钥系统共享的一个特性是，艾米只需要在公共位置放个保险箱，然后世界上每个人都可以通过保险箱给艾米发送加密信息。艾米也不需要给每个人提供保险箱，也不需要阅后即焚。</p>
<p>现在我们给出一般数学定义。</p>
<p>一般的，我们还是给出密钥空间$K$，明文空间$M$和密文空间$C$。无论如何，密钥空间的元素$k$实际上是一对密码：</p>
<center>

<p>$\begin{aligned}<br>    k &#x3D; (k_{priv},k_{pub})<br>\end{aligned}$</p>
</center>

<p>它们分别称为私钥(private key)和公钥(public key)。对每个公钥$k_{pub}$，都有对应的加密功能：</p>
<center>

<p>$\begin{aligned}<br>    e_{k_{pub}}:M\to C<br>\end{aligned}$</p>
</center>

<p>对于每个私钥，都有对应的解密函数：</p>
<center>

<p>$\begin{aligned}<br>    d_{k_{priv}}:C\to M<br>\end{aligned}$</p>
</center>

<p>若这对密钥$(k_{priv},k_{pub})$都在密钥空间$K$内，则</p>
<center>

<p>$\begin{aligned}<br>    d_{k_{priv}}(e_{k_{pub}}(m)) &#x3D; m，对所有m成立<br>\end{aligned}$</p>
</center>

<p>若非对称密码是安全的，则伊娃是很难计算私钥$k_{priv}$，即使她拥有公钥，在这个假设下，艾米可以使用不安全的信道向鲍勃发送公钥$k_{pub}$而不必担心被解密。为了解密则必须使用私钥，在我们的假设下，艾米是唯一有私钥的人，该私钥也被称为艾米的 <strong>陷门</strong>。作用根后门差不多但不一样。因为该私钥的反函数提供了一个捷径（陷门）。因为加密和解密是不一样的事实，所以我们称该密码是非对称密码。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://monstergeo.github.io/btest/2024/09/05/%E5%AF%B9%E7%A7%B0%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/" data-id="cmlgrfvfq00116whxbgzjd7w0" data-title="对称和非对称加密" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/" rel="tag">密码学</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-基于整数环的密码学" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/03/%E5%9F%BA%E4%BA%8E%E6%95%B4%E6%95%B0%E7%8E%AF%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6/" class="article-date">
  <time class="dt-published" datetime="2024-09-03T07:51:19.000Z" itemprop="datePublished">2024-09-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/03/%E5%9F%BA%E4%BA%8E%E6%95%B4%E6%95%B0%E7%8E%AF%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6/">基于整数环的密码学</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="双素数密码"><a href="#双素数密码" class="headerlink" title="双素数密码"></a>双素数密码</h3><p>最早广为流传的公钥密码体系称为RSA(Rivest,Shamir, Adleman)密码体系。它是非对称密码体系，基于整数的模幂运算和大整数因子分解的难解性。一般技术通称位双素数密码，不同的是，RSA基于初等数论：令$n &#x3D; pq$，其中$p,q$是较大的素数，也许它们都超过100位。这样的$n$被我们称为双素数，他指的是一个数$n$可以被分解为2个素数的乘积。现在我们假设存在一个合数$n$，它的位数可能有$140$或者200位，计算刚才提及的$pq$分解是十分困难的，或者直截了当，这是完全不可能的。因子分解的复杂难解性。对于因式分解，至今也没有好的方法。</p>
<p>现在我们将开始在环$Z_n$上展开讨论，其中$Z_n$是指整数上的模$n$同余类构成的环，若其中$n$是素数。在这种情况下$Z_n$构成一个域。现在，对$Z_n$，其中$n$是一个不相等的大素数乘积。现在，整数$n$是公开的，素数$p,q$由解密器保密，并且对加密器也保密。因为$n$是素数乘积，关于$n$的欧拉定理表示：$\phi&#x3D;(p-1)(q-1)$。在这种情况下，我们可以通过$p,q$简单计算得到，但通过$n$则不现实。现在我们选取加密指数$b,b\in Z_n$，由欧几里得算法，我们计算$GCD(b,\phi) &#x3D;1$是否成立，若不成立，重新选择$b$，若成立，则利用拓展欧几里得算法继续计算$a &#x3D; b^{-1}\mod \phi(n)$，由于$b,\phi$互素，因此$a$的存在是被保证的。</p>
<p>而加密秘钥$b$是公开的，$n$也是公开的，但解密密钥$a$是保密的，且不能由$b,\phi(n)$计算得到。一个漏洞就是，$a &#x3D; b^{-1}\mod \phi(n)$，但这无伤大雅，$\phi$对不知道$p,q$的人来说是不清楚的，他们没办法得到$\phi(n)$本身。所以计算$a$本身是不可能的。因为这等价于对$n$进行因式分解。</p>
<p>现在我们谈谈加密过程：对任意的$x\in Z_n$，定义映射$y &#x3D; e_k(x) &#x3D; x^b\mod n$，则一个加密的过程可以用$Z_n\to Z_n$的映射表示。而解密是一个反的过程，对$y\in Z_n$，我们计算$d_k(y) &#x3D; y^a\mod n$，其中$a &#x3D;b^{-1}\mod \phi(n)$</p>
<p>那么我们要做的事情就是，先来验证一下是否可以还原信息</p>
<h4 id="命题1"><a href="#命题1" class="headerlink" title="命题1"></a>命题1</h4><p>在双素数密码体系中，对两个映射$d_k,e_k$存在$d_k(e_k(x)) &#x3D; x$对任意$x\in Z_n$成立。</p>
<p><strong>证明：</strong>首先，由于我们定义$a &#x3D; b^{-1}\mod \phi(n)$，注意$\phi(n) &#x3D; p-1$。于是我们可以重写位$ab &#x3D; 1+r\phi(n)$对整数$r$成立，则$d_k(e_k(x)) &#x3D; (x^b)^a \mod n &#x3D; x^{1+r\phi(n)} \mod n &#x3D; x(x^{\phi(n)})^r$，那么现在我们有2种情况，由于$n$不一定是素数，因此，若$x$有逆，则利用欧拉定理，我们有</p>
<center>

<p>$\begin{aligned}<br>    x^{\phi(n)}\equiv 1\mod n<br>\end{aligned}$</p>
</center>

<p>因此在$\mod n$的情况下，最终我们得到$d_k(e_k(x)) &#x3D; x \mod n$</p>
<p>其次，若$x$是不存在逆的。在这种情况下，$n,x$是不互素的，那么$\gcd(x,p) &#x3D; p$或者有$\gcd(x,q) &#x3D;q$成立，我们不妨假设$\gcd(x,q)&#x3D;1$，其他不变，则$x &#x3D; 0\mod p$。就有$x^{ab} &#x3D; x&#x3D;0\mod p$。另一方面，由于$\gcd(x,q)&#x3D;1$，再由欧拉定理可知$\phi(n)&#x3D;\phi(q)\phi(p)$，跟上面一样，我们重写$\phi(ab) &#x3D; 1+r\phi(p)\phi(q)$。利用中国剩余定理，我们知道$p,q$互素，则这里存在一个解使得$\mod pq &#x3D; \mod n$成立。即$x^{ab} &#x3D; x^{1+\phi(q)\phi(p)} &#x3D; x\mod pq$，在$\mod q$的情况下，我们有$x^{ab} &#x3D;x\mod q$，综上所述，无论是$\mod p$还是$\mod q$，$x^{ab} &#x3D; x$是成立的，因此就有$x^{ab}&#x3D;x\mod n$成立。</p>
<p>因此，在任何情况$d_k(e_k(x)) &#x3D; x$都是成立的。</p>
<p>上述证明的注意点是无论如何$x$都是可以表示出来的。而RSA的安全性基于一个事实，记$e_k(x)$实际上是一个单向函数，但是一个有点点缺陷的，所以选择RSA加密需要一个比较大的素数来防止破解。例如选择一个$p,q$在大概500位的素数，则这样会产生$1000~4000$的双素数，分解这些素数是非常困难的。</p>
<p>我们选取$p&#x3D;1171$和$q &#x3D;1019$，则$n &#x3D; 1193249$，而$\phi(n) &#x3D; 1191060$。现在我们由解码器随机选择解密指数$a &#x3D;1076531$，则$b &#x3D; a^{-1}\mod \phi(n) &#x3D; 120251$，那么信息$x$将会被加密为$y &#x3D; x^{120251}$，密文$y$被解密为$x &#x3D; y^{1076531}$</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://monstergeo.github.io/btest/2024/09/03/%E5%9F%BA%E4%BA%8E%E6%95%B4%E6%95%B0%E7%8E%AF%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6/" data-id="cmlgrfvfp00106whx2hz9g559" data-title="基于整数环的密码学" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/" rel="tag">密码学</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-任意开集的解析性质" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/26/%E4%BB%BB%E6%84%8F%E5%BC%80%E9%9B%86%E7%9A%84%E8%A7%A3%E6%9E%90%E6%80%A7%E8%B4%A8/" class="article-date">
  <time class="dt-published" datetime="2024-08-26T05:41:02.000Z" itemprop="datePublished">2024-08-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/26/%E4%BB%BB%E6%84%8F%E5%BC%80%E9%9B%86%E7%9A%84%E8%A7%A3%E6%9E%90%E6%80%A7%E8%B4%A8/">任意开集的解析性质</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在前几篇文章中介绍的方法并不能在任意开集上求一个给定的幂级数。虽然在一般的情况下这种方法也不存在。例如，给定一个复平面上的正方形，并给定正方形内点$a$，在我们尝试寻找一个绕着点$a$和正方形中心$\alpha$的轮廓$C$，使得</p>
<center>

<p>$<br>\begin{aligned}<br>   \left| \frac{a-\alpha}{\omega -\alpha}\right|  &lt; 1 对所有\omega\in C 成立<br>\end{aligned}<br>$</p>
</center>

<p>会出现矛盾。</p>
<p>这不仅仅是技术上的困难，总的来说这反应了一个事情，就是不存在任意的幂级数。不过我们可以用以前得到的结果来构造一个一般的定理。</p>
<h3 id="定理1"><a href="#定理1" class="headerlink" title="定理1"></a>定理1</h3><p>若$f$在任意的开域$D$上解析，则对每个$\alpha\in D$，这里存在常数$C_k$使得</p>
<center>

<p>$\begin{aligned}<br>    f\left( z \right) \ &#x3D;\ \sum_{k&#x3D;0}^{\infty}{C_k\left( z-\alpha \right) ^k}<br>\end{aligned}$</p>
</center>

<p>对以$\alpha$作为圆心包含在$D$内的最大圆盘的所有点$z$成立。</p>
<p><strong>证明：</strong></p>
<p>这实际上就是我们之前证明过的圆盘内幂级数定理的证明</p>
<p>使用柯西积分定理，当满足$\mid z-\alpha\mid &lt; \mid a-\alpha\mid$的时候，有</p>
<center>

<p>$\begin{aligned}<br>    f(z) &#x3D; \frac{1}{2\pi i}\int_{C_p}{\frac{f\left( \omega \right)}{\omega -z}d\omega}<br>\end{aligned}$</p>
</center>

<p>然后我们对函数$\frac{1}{\omega-z}$展开有</p>
<center>

<p>$\begin{aligned}<br>    \frac{1}{\omega -\alpha}+\frac{z-\alpha}{\left( \omega -\alpha \right) ^2}+\frac{\left( z-\alpha \right) ^2}{\left( \omega -\alpha \right) ^3}+\cdots<br>\end{aligned}$</p>
</center>

<p>带回然后令系数$C_k &#x3D;  C_k(\rho) &#x3D; \frac{1}{2\pi i}\int_{C_p}\frac{f(\omega)}{(\omega-a)^{k+1}}d\omega$即可证明完毕。</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><ul>
<li>$f(z) &#x3D; 1&#x2F;(z-1)$在$z&#x3D;2$处解析的，其中收敛域是以$z&#x3D;2$为中心，$r &#x3D;1$的圆。那么我们就可以在圆盘中将他展开成下列级数：</li>
</ul>
<center>

<p>$\begin{aligned}<br>    \frac{1}{z-1}\ &#x3D;\ \frac{1}{1+\left( z-2 \right)}\ &#x3D;\ 1-\left( z-2 \right) +\left( z-2 \right) ^3+\cdots -\cdots<br>\end{aligned}$</p>
</center>

<p>注意当且$\mid z-2\mid &lt;1$收敛。</p>
<p>虽然函数在$\mid z-2\mid&gt;1 $的其他地方上也是解析的，但是级数展开式在此之外发散，因此无意义。</p>
<ul>
<li>我们来求$f(z) &#x3D; 1&#x2F;z^2$在$z&#x3D;3$的幂级数。令</li>
</ul>
<center>

<p>$\begin{aligned}<br>    \frac{1}{z^2}\ &#x3D;&amp;\ \left[ \frac{1}{3+\left( z-3 \right)} \right] ^2\ &#x3D;\ \frac{1}{9}\left[ \frac{1}{1+\left( z-3 \right) &#x2F;3} \right] ^2\<br>    &#x3D;&amp; \sum_{k&#x3D;0}^{\infty}{\frac{\left( -1 \right) ^k}{9}\frac{\left( k+1 \right)}{3^k}\left( z-3 \right) ^k}<br>\end{aligned}$</p>
</center>

<p>它的收敛域就是 $1&#x2F;\lim \mid C_k\mid ^{1&#x2F;k} &#x3D; \lim_{n\to\infty}\left(\frac{9\cdot 3^k}{k+1}\right)^{1&#x2F;k} &#x3D;3$</p>
<h2 id="唯一性、中值、最大模原理；临界点和鞍点"><a href="#唯一性、中值、最大模原理；临界点和鞍点" class="headerlink" title="唯一性、中值、最大模原理；临界点和鞍点"></a>唯一性、中值、最大模原理；临界点和鞍点</h2><p>我们现在来考虑一些定理1中的幂级数表示的影响。</p>
<p>我们从下述定理开始</p>
<h4 id="定理2"><a href="#定理2" class="headerlink" title="定理2"></a>定理2</h4><p>若$f$在$\alpha$处是解析的，则</p>
<center>

<p>$\begin{aligned}<br>    g(z) &#x3D; \left{ \begin{array}{l}<br>    \frac{f\left( z \right) -f\left( \alpha \right)}{z-\alpha} &amp; z \neq \alpha\<br>    f’\left( \alpha \right) &amp; z &#x3D; \alpha\<br>\end{array} \right.<br>\end{aligned}$</p>
</center>

<p>也在点$\alpha$可解析</p>
<p>我们已经用了十分多的篇幅来描写这个函数的性质了。不管是他的导数，幂级数，还是极限也好。现在我们来证明一下。</p>
<p><strong>证明：</strong> 我们选择一些$\alpha$的邻域，那么$f(z)$有如下的表达式：</p>
<center>

<p>$\begin{aligned}<br>    f(z) &#x3D; f\left( \alpha \right) +\ f’\left( \alpha \right) \left( z-\alpha \right) +\frac{f’’\left( \alpha \right)}{2!}\left( z-\alpha \right) ^2+\cdots<br>\end{aligned}$</p>
</center>

<p>因此，$g$在相同的邻域上也有级数表达式</p>
<center>

<p>$\begin{aligned}<br>    g\left( z \right) ,,&#x3D;,,f’\left( \alpha \right) +\frac{f’’\left( \alpha \right)}{2!}\left( z-\alpha \right) +\frac{f^{\left( 3 \right)}\left( \alpha \right)}{3!}\left( z-\alpha \right) ^2+\cdots<br>\end{aligned}$</p>
</center>

<p>并且$g$也在$\alpha$上解析。</p>
<h4 id="定理3"><a href="#定理3" class="headerlink" title="定理3"></a>定理3</h4><p>若$f$在$z$上解析，则$f$在$z$上是无限可微的。</p>
<p><strong>证明：</strong>根据定义，若$f$在点$z$上是可解析的，那么$f$在$z$的某个邻域内可以被表示为幂级数，因此$f(z)$是无限可微的。</p>
<h4 id="唯一性定理。"><a href="#唯一性定理。" class="headerlink" title="唯一性定理。"></a>唯一性定理。</h4><p>设$f$在域$D$上解析且$f(z_n)&#x3D;0$对所有$n&#x3D;1,2\cdots,$成立，其中${z_n}$是不同点$z_n\to z_0\in D$的序列，则在$D$上，$f\equiv 0$</p>
<p><strong>证明：</strong>由于$f$在$z_0$周围有幂级数表达式，而且这种表示是唯一的。那么$f&#x3D;0$穿过包含$z_0$的某个圆。为了$f \equiv 0$在整个域$D$上成立，我们将$D$分割为两个域：</p>
<center>

<p>$\begin{aligned}<br>    A &#x3D;&amp; {z\in D: \lim_{z\to z_0} f(z) &#x3D; 0}\<br>    B &#x3D;&amp; {z\in D: z\notin A}<br>\end{aligned}$</p>
</center>

<p>由定义可得$A\cap B &#x3D; 0$，而$A$可由幂级数的唯一性定理证明：若$z$是$f&#x3D;0$的零点极限，那么对于整个绕$z$的圆盘上的函数$f\equiv 0$，并且圆盘被$A$包含。其次，$B$是开的，因为对每个$z\in B$都存在某个$\delta &gt; 0$使得$f(\omega)\neq 0$对$ 0 &lt;\mid z-\omega\mid &lt;\delta $成立。那么圆$D(z:\delta)$就被$B$包含。因为$D$是连通的，这意味着$A$或者$B$必须有一个是空集。由假设，$z_0\in A$，因此$B$是空的，并且对每个$z\in D$都是$f$上的零极限，由$f$的连续性，则$f\equiv 0\in D$</p>
<h4 id="推论"><a href="#推论" class="headerlink" title="推论"></a>推论</h4><p>若存在两个函数$f,g$且都在域$D$上解析，并且$f,g$在$D$上的一组具有聚点的点上是相等的，则在$D$上有$f\equiv g$</p>
<p><strong>证明：</strong> 我们首先考虑$f-g$，利用唯一性定理，则$f,g$在$D$上始终有$f &#x3D; g$，因此$f-g \equiv0 $在$D$上始终成立，所以$f\equiv g$</p>
<h4 id="定理4"><a href="#定理4" class="headerlink" title="定理4"></a>定理4</h4><p>若$f$全纯且若$f(z)\to \infty$当$z\to\infty$成立，则$f$是多项式。</p>
<p><strong>证明：</strong> 由题设，那么这里存在数$M&gt;0$使得$\mid z\mid &gt; M$有$\mid f(z)\mid &gt; 1$。那么这里至多只能有有限个零点，则$0$集合将在$D(0;M)$中有聚点，否则由唯一性原理，$f$是恒等于零的，这与我们最开始的假设矛盾。为此，我们去除$f$的零点，构造函数</p>
<center>

<p>$\begin{aligned}<br>    g(z) &#x3D; \frac{f\left( z \right)}{\left( z-a_1 \right) \cdots \left( z-a_n \right)}<br>\end{aligned}$</p>
</center>

<p>其中$a_1,\cdots,a_n$为零点，并且函数是全纯的。因此</p>
<center>

<p>$\begin{aligned}<br>    h(z) &#x3D; \frac{1}{g(z)} &#x3D; \frac{\left( z-a_1 \right) \cdots \left( z-a_n \right)}{f\left( z \right)}<br>\end{aligned}$</p>
</center>

<p>也是纯的，由于当$z\to\infty$有$f\to\infty$，利用拓展的刘维尔定理，存在常数$A$使得$h(z) \leq A+\mid z\mid ^n$并且$h$是多项式。但$h &#x3D; 1&#x2F;g \neq 0$，由代数基本定理，$h$拥有一个常数$k$，因此</p>
<center>

<p>$\begin{aligned}<br>    f(z) &#x3D; \frac{1}{k}\left( z-a_1 \right) \cdots \left( z-a_n \right)<br>\end{aligned}$</p>
</center>

<h4 id="中值定理"><a href="#中值定理" class="headerlink" title="中值定理"></a>中值定理</h4><p>若$f$在$D$上是解析的且$\alpha \in D$。则$f(\alpha)$等于$f$取在$D$上以$\alpha$为中心的任意圆周的中值，因此，当$D(\alpha;r)\subset D$有</p>
<center>

<p>$\begin{aligned}<br>    f(\alpha)  &#x3D; \frac{1}{2\pi}\int^{2\pi}_0 f(\alpha+re^{i\theta})d\theta<br>\end{aligned}$</p>
</center>

<p><strong>证明：</strong> 由柯西积分定理，我们取$a &#x3D; \alpha$，有</p>
<center>

<p>$\begin{aligned}<br>    f(\alpha) &#x3D; \frac{1}{2\pi i}\int_{C_r}\frac{f(z)}{z-\alpha}dz<br>\end{aligned}$</p>
</center>

<p>接着我们引入参数化变量$z &#x3D; \alpha+re^{i\theta}$，做简单的换元即可得到</p>
<center>

<p>$\begin{aligned}<br>    f(\alpha)  &#x3D; \frac{1}{2\pi}\int^{2\pi}_0 f(\alpha+re^{i\theta})d\theta<br>\end{aligned}$</p>
</center>

<hr>
<p>当我们说一个点$z$是$f$的最大值时，我们指的是对$f$的任意点$\omega$，存在$\mid f(z)\mid \geq \mid f(\omega)\mid $</p>
<h4 id="最大模定理"><a href="#最大模定理" class="headerlink" title="最大模定理"></a>最大模定理</h4><p>在域$D$上的非零解析函数不存在局部最大值点：对每个$z\in D$和$\delta &gt; 0$，这里存在一些$\omega\in D(z;\delta)\cap D$使得$\mid f(\omega)\mid &gt; \mid f(z)\mid $</p>
<p><strong>证明：</strong> 之前我们已经讲过一个刘维尔定理，刘维尔定理告诉我们，在有限的区间上，有界全纯函数是常数。而最大模定理告诉我们另一个事实，即若$f$是全纯且非常数，则它的模$\mid f\mid$在定义域内没有局部最大值。</p>
<p>利用中值定理，对点$z$的邻域上的点$\omega$，我们有$\mid f(\omega)\mid \geq \mid f(z)\mid $</p>
<p>由中值定理，因为$r &gt;0$，就有圆盘$D(z;r)\subset D$，我们有</p>
<center>

<p>$\begin{aligned}<br>    f(z) &#x3D; \frac{1}{2\pi}\int^{2\pi}_0 f(z+re^{i\theta})d\theta<br>\end{aligned}$</p>
</center>

<p>那么我们可以得到一个不等式</p>
<center>

<p>$\begin{aligned}<br>    \begin{aligned}|f(z)|\leq\frac{1}{2\pi}\int_{0}^{2\pi}|f(z+re^{i\theta})|d\theta\leq\max_{\theta}|f(z+re^{i\theta})|.\end{aligned}<br>\end{aligned}$</p>
</center>

<p>类似的，对某个$\omega\in D(z;r)$我们可以推出$\mid f(\omega)\mid &gt; \mid f(z)\mid $，如果要使得上述不等式中的等号成立，则要求$\mid f\mid$必须是常数，并且对任意小的$r&gt;0$成立。即在圆盘内保持不变。由于$\mid f\mid$在$D$上始终为常数，再利用唯一性定理，则$f\equiv C$在$D$上成立。其中$C$是常数。</p>
<h4 id="最小模定理"><a href="#最小模定理" class="headerlink" title="最小模定理"></a>最小模定理</h4><p>若$f$在$D$上是非常数解析函数，除非$f(z) &#x3D; 0$，否则没有相对的最小值。</p>
<p><strong>证明：</strong> 我们设$f(z)\neq 0$并考虑$g &#x3D; 1&#x2F;f$。若$z$是$f$的最小值。则它是$g$上的最大值。因此，利用最大模定理，它要么没有最大值要么是常数，所以$g$在$D$上是常数，这与我们假设的$f$矛盾。</p>
<h4 id="定理5"><a href="#定理5" class="headerlink" title="定理5"></a>定理5</h4><p>设$f$是在闭圆$D$上的非常数解析函数，再设它的最大模在边界点$z_0$取到。则$f’(z_0)\neq 0$</p>
<p><strong>证明：</strong> 我们设$f’(z_0) &#x3D; 0$，对任意模足够小的复数$\xi$，我们有</p>
<center>

<p>$\begin{aligned}<br>    f(z_0+\xi)&#x3D;f(z_0)+\frac{f^{(k)}(z_0)}{k!}\xi^k+\cdots<br>\end{aligned}$</p>
</center>

<p>其中$k$是使得$f^{(k)}(z_0)$不为0的最小整数。被我们省略的项均是比$\xi^k$高的高阶项。</p>
<p>接下来我们在上述等式乘上其一个共轭，得到</p>
<center>

<p>$\begin{aligned}<br>\mid f(z_0+\xi)\mid^2 &#x3D;&amp; f(z_0+\xi)\overline{f(z_0+\xi)}\<br>&#x3D;&amp; |f(z_0)|^2+\frac{2}{k!}\mathrm{Re}\left(\overline{f(z_0)}f^{(k)}(z_0)\xi^k\right)+\cdots<br>\end{aligned}$</p>
</center>


<p>由于$\mid f(z_0)\mid &#x3D; \max_{z\in D}\mid f(z)\mid $，$\mid f(z_0)\mid \neq 0$，我们记$\overline{f(z_{0})}f^{(k)}(z_{0}) &#x3D; Ae^{i\alpha}$，其中$A &gt; 0$，再令$e^{i\theta} &#x3D; \xi&#x2F;\mid \xi\mid $，这是标准化流程，我们通过除以模来得到标准化的向量。</p>
<p>那么有</p>
<center>

<p>$\begin{aligned}<br>    \left|f(z_0+\xi)\right|^2&#x3D;\left|f(z_0)\right|^2+\frac{2A}{k!}\left|\xi\right|^k\cos(k\theta+\alpha)+\cdots,<br>\end{aligned}$</p>
</center>

<p>对模足够小的$\xi$，可知$\mid f(z_0+\xi)\mid - |f(z_0)|$具有与$\cos(k\theta+\alpha)$相同的符号。</p>
<p>若$z$位于形如</p>
<center>

<p>$\begin{aligned}<br>    \left{z_0+r_\theta e^{i\theta}:\theta\in\left(\frac{-\pi+4\pi j-2\alpha}{2k},\frac{\pi+4\pi j-2\alpha}{2k}\right) 且~~ r_\theta\in(0,\varepsilon_\theta)\right}<br>\end{aligned}$</p>
</center>

<p>的$k$个楔形区域中的任意一个，其中对每个整数$\epsilon_\theta$和$j &#x3D; 0,1,\cdots,k-1$成立。那么可以推出$\mid f(z)\mid &gt; \mid f(z_0)\mid $。</p>
<p>由于$f’(z_0) &#x3D; 0$，$k\geq 2$，则上述说的楔形中至少有一个与$D$相交，因此$\mid f(z_0)\mid $不可能是$D$上$|f|$的极大值</p>
<h4 id="定义：鞍点"><a href="#定义：鞍点" class="headerlink" title="定义：鞍点"></a>定义：鞍点</h4><p>$z_0$是解析函数$f$的鞍点若其也是实函数$g &#x3D; \mid f\mid$的鞍点，因此，若$g$在$z_0$处可微，且有$g_x(z_0) &#x3D;g_y(z_0)&#x3D;0$，但$z_0$既不是局部最大值也不是局部最小值。</p>
<h4 id="定理6"><a href="#定理6" class="headerlink" title="定理6"></a>定理6</h4><p>$z_0$是解析函数$f$的鞍点当且仅当$f’(z_0) &#x3D;0$且$f(z_0)\neq 0$</p>
<p><strong>证明：</strong> 令$f &#x3D; u+iv$，其中$u$和$v$均为实数，再令$g&#x3D;\mid f\mid $</p>
<p>首先，设$z_0$是$f$的鞍点。则$g&#x3D;\mid f\mid$在$z_0$处可微。那么$g(z_0)\neq 0$，有</p>
<center>

<p>$\begin{aligned}<br>    g_{x}&#x3D;\frac{(uu_{x}+vv_{x})}{g},\quad g_{y}&#x3D;\frac{(uu_{y}+vv_{y})}{g}.<br>\end{aligned}$</p>
</center>

<p>由假设，则$g_x(z_0) &#x3D; g_y(z_0) &#x3D;0$，那么</p>
<center>

<p>$\begin{aligned}<br>    u(z_{0})u_{x}(z_{0})+v(z_{0})v_{x}(z_{0})&#x3D;0,\u(z_{0})u_{y}(z_{0})+v(z_{0})v_{y}(z_{0})&#x3D;0.<br>\end{aligned}$</p>
</center>

<p>但$u(z_0),v(z_0)$不完全为0，因此，为了证明导数为0，由于$u,v$不同时为0，这说明存在非零解，因而$u_x,v_x$的关系如下：</p>
<center>

<p>$\begin{aligned}<br>    \det\begin{pmatrix}u_x\left(z_0\right)&amp; v_x\left(z_0\right)\u_y\left(z_0\right) &amp;v_y\left(z_0\right)\end{pmatrix}&#x3D;0.<br>\end{aligned}$</p>
</center>

<p>由柯西-黎曼等式，可知解析函数$f$有$u^2_x(z_0)+v^2_x(z_0) &#x3D;0$，因此$f’(z_0) &#x3D; 0$确实成立。</p>
<p>反之，若$f’(z_0) &#x3D;0$，$f(z_0)\neq 0$，则$u_x(z_0)$和$v_x(z_0)$都是0，利用柯西-黎曼定理，则$g_x &#x3D; g_y&#x3D;0$在$z-0$处同样成立。那么带入到$g$的微分中可得$g_x&#x3D;g_y&#x3D;0$在$z_0$处成立。利用定理5和最小模原理，$z_0$不是极大值和极小值。因此它是鞍点。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://monstergeo.github.io/btest/2024/08/26/%E4%BB%BB%E6%84%8F%E5%BC%80%E9%9B%86%E7%9A%84%E8%A7%A3%E6%9E%90%E6%80%A7%E8%B4%A8/" data-id="cmlgrfvfh000o6whx2jfc1hqf" data-title="任意开集的解析性质" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/complex-analysis/" rel="tag">complex_analysis</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-解析函数的性质" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/16/%E8%A7%A3%E6%9E%90%E5%87%BD%E6%95%B0%E7%9A%84%E6%80%A7%E8%B4%A8/" class="article-date">
  <time class="dt-published" datetime="2024-08-16T05:57:10.000Z" itemprop="datePublished">2024-08-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/16/%E8%A7%A3%E6%9E%90%E5%87%BD%E6%95%B0%E7%9A%84%E6%80%A7%E8%B4%A8/">解析函数的性质</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>这个章节我们来研究一下幂级数和整函数之前的关系。</p>
<h2 id="圆盘解析函数的幂级数形式"><a href="#圆盘解析函数的幂级数形式" class="headerlink" title="圆盘解析函数的幂级数形式"></a>圆盘解析函数的幂级数形式</h2><h3 id="定理1"><a href="#定理1" class="headerlink" title="定理1"></a>定理1</h3><p>设$f$是在$D &#x3D; D(a;r)$上的解析的。若封闭矩形$R$和它的点$a$是被$D$包含的，且$\Gamma$表示$R$的边界，则</p>
<center>

<p>$\begin{aligned}<br>    \int_\Gamma f(z)dz &#x3D; \int_\Gamma \frac{f(z)-f(a)}{z-a}dz &#x3D;0<br>\end{aligned}$</p>
</center>

<p><strong>证明：</strong> 这是我们之前证明过的矩形定理，但是定理要求被缩小在圆盘$D$内，并且满足$f$在$R$上是可解析的。这在题设已经给出了。</p>
<p>为了做简化，我们规定，若$f(z)$在区域$D$中解析，并且包括点$a$，则函数</p>
<center>

<p>$\begin{aligned}<br>  g(z) &#x3D; \frac{f(z)-f(a)}{z-a}<br>\end{aligned}$</p>
</center>

<p>表示为：</p>
<center>

<p>$\begin{aligned}<br>   g(z) &#x3D; \begin{cases}<br>    \frac{f(z)-f(a)}{z-a} &amp; z\in D,z\neq a\<br>    f’(a) &amp; z &#x3D;a<br>\end{cases}<br>\end{aligned}$</p>
</center>

<h3 id="定理2"><a href="#定理2" class="headerlink" title="定理2"></a>定理2</h3><p>若$f$在$D(\alpha;r)$上解析，且$a\in D(\alpha;r)$，那么这里存在函数$F$和$G$在$D$上解析且使得</p>
<center>

<p>$\begin{aligned}<br>    F’(z) &#x3D; f(z) , G’(z) &#x3D; \frac{f(z)-f(a)}{z-a}<br>\end{aligned}$</p>
</center>


<p><strong>证明：</strong> </p>
<p>我们记 </p>
<center>

<p>$\begin{aligned}<br>    F(z) &#x3D; \int^z_a f(\zeta)d\zeta<br>\end{aligned}$</p>
</center>

<p>且</p>
<center>

<p>$\begin{aligned}<br>    G(z) &#x3D; \int^z_a \frac{f(\zeta)-f(a)}{\zeta -a}d\zeta<br>\end{aligned}$</p>
</center>

<p>由柯西积分定理，我们知道闭曲线上全纯函数积分值位0，这意味着若我们选择两条不一样的线使得闭合且$f$在上解析，则这两条路径积分值是一样的。那么其中积分路径我们选择从$\alpha$到$z$的水平和垂直线段组成。注意对任意的$z\in D(\alpha;r)$和足够小的$h$,那么$z+h\in D(\alpha;r)$，利用积分基本定理，全纯函数若处处可解析，则存在一个函数$F(z)$它使得对任意的点$z\in D(\alpha;r)$使得$F’(z) &#x3D; f(z)$</p>
<p>并且应用矩形定理有</p>
<center>

<p>$\begin{aligned}<br>    G’(z) &#x3D; \frac{f(\zeta)-f(a)}{\zeta - a}<br>\end{aligned}$</p>
</center>

<h3 id="定理3"><a href="#定理3" class="headerlink" title="定理3"></a>定理3</h3><p>若$f$在圆盘$D(\alpha;r)$上解析且$a\in D(\alpha;r)$，且$C$是在$D(\alpha;r)$内的光滑闭曲线，那么</p>
<center>

<p>$\begin{aligned}<br>    \int_C f(z)dz &#x3D; \int_C \frac{f(z)-f(a)}{z-a} dz &#x3D;0<br>\end{aligned}$</p>
</center>

<p>由定理2，这里存在一个函数$G$使得在$D(\alpha;r)$上解析，有</p>
<center>

<p>$\begin{aligned}<br>    G’(z) &#x3D; \frac{f(z)-f(a)}{z-a}<br>\end{aligned}$</p>
</center>

<p>因此</p>
<center>

<p>$\begin{aligned}<br>\int_C{\frac{f\left( z \right) -f\left( a \right)}{z-a}}dz\ &#x3D;\ \int_C{ G’\left( z \right) dz\ &#x3D;\ G\left( z\left( b \right) \right) -G\left( z\left( a \right) \right)}&#x3D;0<br>\end{aligned}$</p>
</center>

<p>由于$G$的起点和终点重合，因此$\int_C f(z) dz &#x3D;0$</p>
<h3 id="定理4-圆盘上的柯西方程"><a href="#定理4-圆盘上的柯西方程" class="headerlink" title="定理4 圆盘上的柯西方程"></a>定理4 圆盘上的柯西方程</h3><p>设$f$是$D(\alpha;r)$上解析的函数，其中$ 0 &lt; \rho &lt; r$，且对任意的点$a$有$\mid a- \alpha\mid &lt; \rho$。则</p>
<center>

<p>$\begin{aligned}<br>    f\left( a \right) \ &#x3D;\ \frac{1}{2\pi i}\int_{C_p}{\frac{f\left( z \right)}{z-a}dz}<br>\end{aligned}$</p>
</center>

<p>其中$C_p$表示$\alpha+\rho e^{i\theta}$的圆，其中$0\leq \theta\leq 2\pi$</p>
<center>

<p>&lt;img style&#x3D;”border-radius: 0.3125em;<br>                box-shadow: 0 2px 4px 0 rgba(34,36,38,.12), 0 2px 10px 0 rgba(34,36,38,.08);<br>                border: 10px solid transparent;<br>                margin-bottom: 20px”<br>        src&#x3D;”<a target="_blank" rel="noopener" href="https://i.upmath.me/svg/%5Ctikzset%7Bevery%20picture%2F.style%3D%7Bline%20width%3D0.75pt%7D%7D%20%25set%20default%20line%20width%20to%200.75pt%20%20%20%20%20%20%20%20%0A%0A%5Cbegin%7Btikzpicture%7D%5Bx%3D0.75pt%2Cy%3D0.75pt%2Cyscale%3D-1%2Cxscale%3D1%5D%0A%25uncomment%20if%20require%3A%20%5Cpath%20(0%2C941)%3B%20%25set%20diagram%20left%20start%20at%200%2C%20and%20has%20height%20of%20941%0A%0A%25Shape%3A%20Axis%202D%20%5Bid%3Adp04920795887887053%5D%20%0A%5Cdraw%20%20(49%2C354.86)%20--%20(353%2C354.86)(79.4%2C110.57)%20--%20(79.4%2C382)%20(346%2C349.86)%20--%20(353%2C354.86)%20--%20(346%2C359.86)%20(74.4%2C117.57)%20--%20(79.4%2C110.57)%20--%20(84.4%2C117.57)%20%20%3B%0A%25Shape%3A%20Ellipse%20%5Bid%3Adp04586323555444949%5D%20%0A%5Cdraw%20%20%20(125%2C255.79)%20..%20controls%20(125%2C222.06)%20and%20(152.34%2C194.71)%20..%20(186.07%2C194.71)%20..%20controls%20(219.8%2C194.71)%20and%20(247.14%2C222.06)%20..%20(247.14%2C255.79)%20..%20controls%20(247.14%2C289.51)%20and%20(219.8%2C316.86)%20..%20(186.07%2C316.86)%20..%20controls%20(152.34%2C316.86)%20and%20(125%2C289.51)%20..%20(125%2C255.79)%20--%20cycle%20%3B%0A%25Shape%3A%20Circle%20%5Bid%3Adp8593123416691568%5D%20%0A%5Cdraw%20%20%20(143.23%2C255.79)%20..%20controls%20(143.23%2C232.13)%20and%20(162.41%2C212.95)%20..%20(186.07%2C212.95)%20..%20controls%20(209.73%2C212.95)%20and%20(228.91%2C232.13)%20..%20(228.91%2C255.79)%20..%20controls%20(228.91%2C279.45)%20and%20(209.73%2C298.63)%20..%20(186.07%2C298.63)%20..%20controls%20(162.41%2C298.63)%20and%20(143.23%2C279.45)%20..%20(143.23%2C255.79)%20--%20cycle%20%3B%0A%25Straight%20Lines%20%5Bid%3Ada4385916728892565%5D%20%0A%5Cdraw%20%20%20%20(186.07%2C255.79)%20--%20(247.14%2C255.79)%20%3B%0A%5Cdraw%20%5Bshift%3D%7B(186.07%2C255.79)%7D%2C%20rotate%20%3D%200%5D%20%5Bcolor%3D%7Brgb%2C%20255%3Ared%2C%200%3B%20green%2C%200%3B%20blue%2C%200%20%7D%20%20%5D%5Bfill%3D%7Brgb%2C%20255%3Ared%2C%200%3B%20green%2C%200%3B%20blue%2C%200%20%7D%20%20%5D%5Bline%20width%3D0.75%5D%20%20%20%20%20%20(0%2C%200)%20circle%20%5Bx%20radius%3D%203.35%2C%20y%20radius%3D%203.35%5D%20%20%20%3B%0A%25Straight%20Lines%20%5Bid%3Ada08312286056225471%5D%20%0A%5Cdraw%20%20%20%20(186.07%2C255.79)%20--%20(219%2C283)%20%3B%0A%5Cdraw%20%20%20(179%2C291)%20--%20(193%2C298)%20--%20(179%2C305)%20%3B%0A%5Cdraw%20%20%20(190%2C207)%20--%20(176%2C214)%20--%20(190%2C221)%20%3B%0A%25Shape%3A%20Circle%20%5Bid%3Adp8098307423200428%5D%20%0A%5Cdraw%20%20%5Bfill%3D%7Brgb%2C%20255%3Ared%2C%205%3B%20green%2C%200%3B%20blue%2C%200%20%7D%20%20%2Cfill%20opacity%3D1%20%5D%20(169%2C233.5)%20..%20controls%20(169%2C232.12)%20and%20(167.88%2C231)%20..%20(166.5%2C231)%20..%20controls%20(165.12%2C231)%20and%20(164%2C232.12)%20..%20(164%2C233.5)%20..%20controls%20(164%2C234.88)%20and%20(165.12%2C236)%20..%20(166.5%2C236)%20..%20controls%20(167.88%2C236)%20and%20(169%2C234.88)%20..%20(169%2C233.5)%20--%20cycle%20%3B%0A%25Straight%20Lines%20%5Bid%3Ada4194909180522304%5D%20%0A%5Cdraw%20%20%20%20(211.25%2C218.44)%20--%20(238%2C185)%20%3B%0A%5Cdraw%20%5Bshift%3D%7B(210%2C220)%7D%2C%20rotate%20%3D%20308.66%5D%20%5Bcolor%3D%7Brgb%2C%20255%3Ared%2C%200%3B%20green%2C%200%3B%20blue%2C%200%20%7D%20%20%5D%5Bline%20width%3D0.75%5D%20%20%20%20(10.93%2C-4.9)%20..%20controls%20(6.95%2C-2.3)%20and%20(3.31%2C-0.67)%20..%20(0%2C0)%20..%20controls%20(3.31%2C0.67)%20and%20(6.95%2C2.3)%20..%20(10.93%2C4.9)%20%20%20%3B%0A%0A%25%20Text%20Node%0A%5Cdraw%20(211%2C239.4)%20node%20%5Banchor%3Dnorth%20west%5D%5Binner%20sep%3D0.75pt%5D%20%20%20%20%7B%24r%24%7D%3B%0A%25%20Text%20Node%0A%5Cdraw%20(179%2C257.4)%20node%20%5Banchor%3Dnorth%20west%5D%5Binner%20sep%3D0.75pt%5D%20%20%20%20%7B%24%5Crho%20%24%7D%3B%0A%25%20Text%20Node%0A%5Cdraw%20(161%2C236.4)%20node%20%5Banchor%3Dnorth%20west%5D%5Binner%20sep%3D0.75pt%5D%20%20%20%20%7B%24a%24%7D%3B%0A%25%20Text%20Node%0A%5Cdraw%20(239%2C165.4)%20node%20%5Banchor%3Dnorth%20west%5D%5Binner%20sep%3D0.75pt%5D%20%20%20%20%7B%24C_%7Bp%7D%24%7D%3B%0A%0A%0A%5Cend%7Btikzpicture%7D">https://i.upmath.me/svg/%5Ctikzset%7Bevery%20picture%2F.style%3D%7Bline%20width%3D0.75pt%7D%7D%20%25set%20default%20line%20width%20to%200.75pt%20%20%20%20%20%20%20%20%0A%0A%5Cbegin%7Btikzpicture%7D%5Bx%3D0.75pt%2Cy%3D0.75pt%2Cyscale%3D-1%2Cxscale%3D1%5D%0A%25uncomment%20if%20require%3A%20%5Cpath%20(0%2C941)%3B%20%25set%20diagram%20left%20start%20at%200%2C%20and%20has%20height%20of%20941%0A%0A%25Shape%3A%20Axis%202D%20%5Bid%3Adp04920795887887053%5D%20%0A%5Cdraw%20%20(49%2C354.86)%20--%20(353%2C354.86)(79.4%2C110.57)%20--%20(79.4%2C382)%20(346%2C349.86)%20--%20(353%2C354.86)%20--%20(346%2C359.86)%20(74.4%2C117.57)%20--%20(79.4%2C110.57)%20--%20(84.4%2C117.57)%20%20%3B%0A%25Shape%3A%20Ellipse%20%5Bid%3Adp04586323555444949%5D%20%0A%5Cdraw%20%20%20(125%2C255.79)%20..%20controls%20(125%2C222.06)%20and%20(152.34%2C194.71)%20..%20(186.07%2C194.71)%20..%20controls%20(219.8%2C194.71)%20and%20(247.14%2C222.06)%20..%20(247.14%2C255.79)%20..%20controls%20(247.14%2C289.51)%20and%20(219.8%2C316.86)%20..%20(186.07%2C316.86)%20..%20controls%20(152.34%2C316.86)%20and%20(125%2C289.51)%20..%20(125%2C255.79)%20--%20cycle%20%3B%0A%25Shape%3A%20Circle%20%5Bid%3Adp8593123416691568%5D%20%0A%5Cdraw%20%20%20(143.23%2C255.79)%20..%20controls%20(143.23%2C232.13)%20and%20(162.41%2C212.95)%20..%20(186.07%2C212.95)%20..%20controls%20(209.73%2C212.95)%20and%20(228.91%2C232.13)%20..%20(228.91%2C255.79)%20..%20controls%20(228.91%2C279.45)%20and%20(209.73%2C298.63)%20..%20(186.07%2C298.63)%20..%20controls%20(162.41%2C298.63)%20and%20(143.23%2C279.45)%20..%20(143.23%2C255.79)%20--%20cycle%20%3B%0A%25Straight%20Lines%20%5Bid%3Ada4385916728892565%5D%20%0A%5Cdraw%20%20%20%20(186.07%2C255.79)%20--%20(247.14%2C255.79)%20%3B%0A%5Cdraw%20%5Bshift%3D%7B(186.07%2C255.79)%7D%2C%20rotate%20%3D%200%5D%20%5Bcolor%3D%7Brgb%2C%20255%3Ared%2C%200%3B%20green%2C%200%3B%20blue%2C%200%20%7D%20%20%5D%5Bfill%3D%7Brgb%2C%20255%3Ared%2C%200%3B%20green%2C%200%3B%20blue%2C%200%20%7D%20%20%5D%5Bline%20width%3D0.75%5D%20%20%20%20%20%20(0%2C%200)%20circle%20%5Bx%20radius%3D%203.35%2C%20y%20radius%3D%203.35%5D%20%20%20%3B%0A%25Straight%20Lines%20%5Bid%3Ada08312286056225471%5D%20%0A%5Cdraw%20%20%20%20(186.07%2C255.79)%20--%20(219%2C283)%20%3B%0A%5Cdraw%20%20%20(179%2C291)%20--%20(193%2C298)%20--%20(179%2C305)%20%3B%0A%5Cdraw%20%20%20(190%2C207)%20--%20(176%2C214)%20--%20(190%2C221)%20%3B%0A%25Shape%3A%20Circle%20%5Bid%3Adp8098307423200428%5D%20%0A%5Cdraw%20%20%5Bfill%3D%7Brgb%2C%20255%3Ared%2C%205%3B%20green%2C%200%3B%20blue%2C%200%20%7D%20%20%2Cfill%20opacity%3D1%20%5D%20(169%2C233.5)%20..%20controls%20(169%2C232.12)%20and%20(167.88%2C231)%20..%20(166.5%2C231)%20..%20controls%20(165.12%2C231)%20and%20(164%2C232.12)%20..%20(164%2C233.5)%20..%20controls%20(164%2C234.88)%20and%20(165.12%2C236)%20..%20(166.5%2C236)%20..%20controls%20(167.88%2C236)%20and%20(169%2C234.88)%20..%20(169%2C233.5)%20--%20cycle%20%3B%0A%25Straight%20Lines%20%5Bid%3Ada4194909180522304%5D%20%0A%5Cdraw%20%20%20%20(211.25%2C218.44)%20--%20(238%2C185)%20%3B%0A%5Cdraw%20%5Bshift%3D%7B(210%2C220)%7D%2C%20rotate%20%3D%20308.66%5D%20%5Bcolor%3D%7Brgb%2C%20255%3Ared%2C%200%3B%20green%2C%200%3B%20blue%2C%200%20%7D%20%20%5D%5Bline%20width%3D0.75%5D%20%20%20%20(10.93%2C-4.9)%20..%20controls%20(6.95%2C-2.3)%20and%20(3.31%2C-0.67)%20..%20(0%2C0)%20..%20controls%20(3.31%2C0.67)%20and%20(6.95%2C2.3)%20..%20(10.93%2C4.9)%20%20%20%3B%0A%0A%25%20Text%20Node%0A%5Cdraw%20(211%2C239.4)%20node%20%5Banchor%3Dnorth%20west%5D%5Binner%20sep%3D0.75pt%5D%20%20%20%20%7B%24r%24%7D%3B%0A%25%20Text%20Node%0A%5Cdraw%20(179%2C257.4)%20node%20%5Banchor%3Dnorth%20west%5D%5Binner%20sep%3D0.75pt%5D%20%20%20%20%7B%24%5Crho%20%24%7D%3B%0A%25%20Text%20Node%0A%5Cdraw%20(161%2C236.4)%20node%20%5Banchor%3Dnorth%20west%5D%5Binner%20sep%3D0.75pt%5D%20%20%20%20%7B%24a%24%7D%3B%0A%25%20Text%20Node%0A%5Cdraw%20(239%2C165.4)%20node%20%5Banchor%3Dnorth%20west%5D%5Binner%20sep%3D0.75pt%5D%20%20%20%20%7B%24C_%7Bp%7D%24%7D%3B%0A%0A%0A%5Cend%7Btikzpicture%7D</a>“</p>
<p>, width&#x3D;”60%”&gt;</p>
</center>


<p><strong>证明：</strong></p>
<center>

<p>$\begin{aligned}<br>        \int_{C_p}{\frac{f\left( z \right) -f\left( a \right)}{z-a}}dz &#x3D;0<br>\end{aligned}$</p>
</center>

<p>那么</p>
<center>

<p>$\begin{aligned}<br>    f\left( a \right) \int_{C_p}{\frac{dz}{z-a}}&#x3D;,,\int_{C_p}{\frac{f\left( z \right)}{z-a}dz}</p>
<p>\end{aligned}$</p>
</center>

<p>其次，我们知道$\int_{C_p} \frac{dz}{z-a} &#x3D; 2\pi i$</p>
<p>那么我们就证明完了。</p>
<h3 id="圆盘上的解析函数的幂级数表达式"><a href="#圆盘上的解析函数的幂级数表达式" class="headerlink" title="圆盘上的解析函数的幂级数表达式"></a>圆盘上的解析函数的幂级数表达式</h3><p>这是今天最后一个定理</p>
<p>若$f$在$D(\alpha;r)$上解析，则存在常数$C_k$使得</p>
<center>

<p>$\begin{aligned}<br>    f(z) &#x3D; \sum^\infty_{k&#x3D;0} C_k(z-\alpha)^k<br>\end{aligned}$</p>
</center>

<p>对所有$z\in D(\alpha;r)$成立</p>
<p><strong>证明：</strong> </p>
<p>选择$a\in D(\alpha;r)$和$\rho &gt; 0$使得$\mid a-\alpha\mid &lt; \rho &lt;r$。</p>
<p>由柯西积分定理，若$\mid z -\alpha\mid &lt; \mid a-\alpha\mid $</p>
<center>

<p>$\begin{aligned}<br>    f\left( a \right) \ &#x3D;\ \frac{1}{2\pi i}\int_{C_p}{\frac{f\left( \omega\right)}{\omega-z}d\omega}<br>\end{aligned}$</p>
</center>

<p>我们对被积函数做展开，那么有</p>
<center>

<p>$\begin{aligned}<br>    \frac{1}{\omega -\alpha}+\frac{z-\alpha}{\left( \omega -\alpha \right) ^2}+\frac{\left( z-\alpha \right) ^2}{\left( \omega -\alpha \right) ^3}+\cdots<br>\end{aligned}$</p>
</center>

<p>这个级数我们知道在$C_p$上是一致收敛到$\frac{1}{\omega-z}$的。</p>
<p>那么</p>
<center>

<p>$\begin{aligned}<br>    f(z) &#x3D; \frac{1}{2\pi i}\int_{C_p}{f\left( \omega \right) \left[ \frac{1}{\omega -\alpha}+\frac{z-\alpha}{\left( \omega -\alpha \right) ^2}+\frac{\left( z-\alpha \right) ^2}{\left( \omega -\alpha \right) ^3}+\cdots \right]}d\omega<br>\end{aligned}$</p>
</center>

<p>我们做替换令</p>
<center>

<p>$\begin{aligned}<br>    C_k(\rho) &#x3D; \frac{1}{2\pi i}\int_{C_p}\frac{f(\omega)}{(\omega-a)^{k+1}}d\omega<br>\end{aligned}$</p>
</center>

<p>那么就可以把上面的积分展开式重写为</p>
<center>

<p>$\begin{aligned}<br>f(z) &#x3D; C_0(\rho) + C_1(\rho)(z-\alpha) + C_2(\rho)(z-\alpha)^2+\cdots<br>\end{aligned}$</p>
</center>

<p><strong>注意：</strong>这里的$\rho$和系数$C_k(\rho)$是无关的 由于函数无限可微，则系数$C_k(\rho)$</p>
<center>

<p>$\begin{aligned}<br>    C_k(\rho) &#x3D; \frac{f^{(k)}(\alpha)}{k!} 对每个<br>\end{aligned}$ $\rho$ 成立，$0 &lt; \rho &lt; r $ 对所有$k$成立</p>
</center>


<p>那么我们就可以把$f(z)$重写为级数展开式：</p>
<center>

<p>$\begin{aligned}<br>    f(z) &#x3D; \sum^\infty_{k&#x3D;0}C_k(z-\alpha)^k<br>\end{aligned}$</p>
</center>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://monstergeo.github.io/btest/2024/08/16/%E8%A7%A3%E6%9E%90%E5%87%BD%E6%95%B0%E7%9A%84%E6%80%A7%E8%B4%A8/" data-id="cmlgrfvh400266whxfaue5wns" data-title="解析函数的性质" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/complex-analysis/" rel="tag">complex_analysis</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/MATLAB/">MATLAB</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/analyze/">analyze</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/computer/">computer</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Stm32/" rel="tag">Stm32</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/algorithms/" rel="tag">algorithms</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/complex-analysis/" rel="tag">complex_analysis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/computer/" rel="tag">computer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/math/" rel="tag">math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/matlab/" rel="tag">matlab</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tech/" rel="tag">tech</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" rel="tag">图形学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/" rel="tag">密码学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/" rel="tag">计算机原理</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Stm32/" style="font-size: 12.5px;">Stm32</a> <a href="/tags/algorithms/" style="font-size: 15px;">algorithms</a> <a href="/tags/complex-analysis/" style="font-size: 20px;">complex_analysis</a> <a href="/tags/computer/" style="font-size: 10px;">computer</a> <a href="/tags/math/" style="font-size: 12.5px;">math</a> <a href="/tags/matlab/" style="font-size: 10px;">matlab</a> <a href="/tags/tech/" style="font-size: 10px;">tech</a> <a href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" style="font-size: 10px;">图形学</a> <a href="/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/" style="font-size: 17.5px;">密码学</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/" style="font-size: 12.5px;">计算机原理</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2026/02/">February 2026</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/09/">September 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/08/">August 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/07/">July 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">June 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">March 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/02/">February 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/12/">December 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">November 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2026/02/10/liner_algebra/">利用MATLAB计算矩阵</a>
          </li>
        
          <li>
            <a href="/2026/02/10/bqj/">海涅-博雷尔定理</a>
          </li>
        
          <li>
            <a href="/2026/02/10/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2025/09/10/%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/">合作式调度器</a>
          </li>
        
          <li>
            <a href="/2025/08/31/ocrs/">边缘识别</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2026 Marcus<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>