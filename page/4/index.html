<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Marcus&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="nop">
<meta property="og:type" content="website">
<meta property="og:title" content="Marcus&#39;s Blog">
<meta property="og:url" content="https://monstergeo.github.io/btest/page/4/">
<meta property="og:site_name" content="Marcus&#39;s Blog">
<meta property="og:description" content="nop">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Marcus">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Marcus's Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Marcus&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Hello</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://monstergeo.github.io/btest"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Code" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/29/Code/" class="article-date">
  <time class="dt-published" datetime="2024-01-29T14:47:33.000Z" itemprop="datePublished">2024-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/29/Code/">Code</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>这一章我们讲讲编码</p>
<p>首先思考一个问题，我们如何防止一个未经授权的人获取我们的信息？我们假设帕特问麦克要艾拉电话，但麦克回答的时候有一只狗在叫，由于这个噪声，帕特不确信他真的听到了电话号码，并一次要求麦克重复一遍。有可能的大多数情况下，在一次或者两次后的重复才能保证帕特听到艾拉的电话号码。但简单的重复一个信息可数次是不可行的，例如地球上的科学家查看来自火星或者木星的照片就是一个很好的例子。在2004年，在这些星球上的机器人用照相机将每一个图片用下述的方式编码成二进制数字，一个图片会被分成1024 $\times$ 1024的格点$p_{ij}$，他一共存在$2^{10}\times 2^{10} &#x3D; 1<del>048</del>576$个格点。每一个格点都带有一个$12$位的二进制数$c_{ij}$，用于描述它的颜色，密度等等。而这个$2^{10}\times 2^{10}$矩阵$[c_{ij}]$被写为一个2进制数，从第一行到第二行直到第1024行。那么在这种情况下一个图片传达的信息大约有$12<del>000</del>000$节信息，但太空是“嘈杂的”，因为存在宇宙射线会干扰电磁信号。所以多次的重复依然有可能在收到的信息中是不存在一样的消息的。所以我们来寻找一些可行的信息编码的方式，使得我们在接受信息时，错误可被察觉，当然，我们希望能够修正。</p>
<h2 id="分组码"><a href="#分组码" class="headerlink" title="分组码"></a>分组码</h2><p>将一个信息在一个嘈杂的渠道上传输涉及三步</p>
<ul>
<li>对信息编码（编制冗余码）</li>
<li>传递信息</li>
<li>对信息译码</li>
</ul>
<p>现在我们来定义一些东西</p>
<p align="left">记号：我们用$B$表示有限域$F_2$</p>

<p align="left">定义：一个有限集$A$被称为字母表，若其元素为字母，设$m,n$是正整数。一个编码函数是单射的函数$E:A^m\to A^n$，$A^m$或者$A^n$的元素$\omega$称为字，集合$C = \mathrm{im} E\subseteq A^n$称为$A$上的$[n,m]$分组码，$C$的元素称为码字。若$A = B$，则一个$[n,m]$分组码称为一个二进制码。</p>

<p>编码涉及到冗余，这是因为一般情况下为$m&lt;n$（理由看一开始的简介），$m$的选择是不受控制的，因为一个任意长的信息可以被细分为长度$\leq m$的更短的子字。一个传输的信息可能是从外层空间到地球的一张照片，当然，这是我们想要的。如果没有任何干扰，则任意码字$c &#x3D; E(\omega)$都是可以用$\omega &#x3D; E^{-1}(c)$译码，由于编码函数是一个单射，这是因为有可能出现错误，因此我们的任务就是给一个码加上足够多的冗余码，使得我们可以从中有效的回复出原来的码字。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="一"><a href="#一" class="headerlink" title="一"></a>一</h3><p align="left">奇偶性校验$[m+1,m]$码</p>

<p>定义编码函数$E:B^m \to B^{m+1}$为</p>
<center>

<p>$\omega &#x3D; (a_1,\cdots,a_m)\in B^m \to E(\omega) &#x3D; (a_1,\cdots,a_m,b)$</p>
</center>

<p>其中$b &#x3D; \sum^m_{i&#x3D;1} a_i$，容易验证$E$是一个单射，且有码字$C &#x3D; \mathrm{im} E\subseteq B^{m+1}$ 如下给出：</p>
<center>

<p>$C &#x3D; {(b_1,\cdots,b_{m+1}\in B^{m+1}: b_1+b_2+\cdots+b_{m+1} &#x3D; 0}$</p>
</center>

<p>那么，我们定义了一个集合$C$，它的元素由$B^{m+1}$中坐标的和为0给定。不妨取$\omega\in B^m$，则$E(\omega)$的奇偶性为偶当其的坐标的和在$B$中为0，若我们收到一个奇偶性为奇的信息，则我们知道一定在传输中出了错，若存在一对错误，则不能被察觉出，注意$2\equiv 0 \mod 2$。C的作用我们等一下再说。</p>
<h3 id="二、三重重复-12-4-码"><a href="#二、三重重复-12-4-码" class="headerlink" title="二、三重重复$[12,4]$码"></a>二、三重重复$[12,4]$码</h3><p>我们考虑定义为$E(\omega) &#x3D; (\omega,\omega,\omega)$的编码函数$E:B^4\to B^{12}$，那么$C$由如下的形式组成：</p>
<center>

<p>$E(a_1,a_2,a_3,a_4) &#x3D; (a_1,a_2,a_3,a_4,a_1,a_2,a_3,a_4,a_1,a_2,a_3,a_4)$</p>
</center>

<p>我们现在开始传输$(a_1,a_2,a_3,a_4)$，设收到的消息为$y &#x3D; (r_1,\cdots,r_{12})$，由于干扰，可能由</p>
<center>

<p>$(r_1,\cdots,r_{12}) \neq E(a_1,a_2,a_3,a_4)$</p>
</center>

<p>对收到的字$y$译码如下：若传输中无错误，就有$r_1 &#x3D;r_5&#x3D;r_9$。那么这三个码可能的取值只有2种。所以在任何情况下，至少里面的值有两个是相等的。定义$b_1$为在取得最多的值，类似的我们再定义$b_2,b_3,b_4$，那么我们重译$y$为$(b_1,b_2,b_3,b_4)$，若$r_i,r_{i+4},r_{i+8}$不全等，我们知道就存在一个错误。但情况没那么糟糕，我们可以修正这个错误。若收到一个信息$y$的错误，则$y$可以被替换成除一个字母外其余与$y$的字母一样的码字。</p>
<h1 id="度量"><a href="#度量" class="headerlink" title="度量"></a>度量</h1><p>其次，我们来了解一下度量在$A^n$上字的距离</p>
<p align ="left">定义：设$X$是一个集合，$X$上的度量是满足下列条件的一个函数$\delta:X\times X\to R$</p>

<ul>
<li>$\delta(a,b)\geq 0$，对所有$a,b\in X$成立且$\delta(a,b) &#x3D; 0$ 当且仅当$a &#x3D; b$</li>
<li>$\delta(a,b) &#x3D; \delta(b,a)$</li>
<li><strong>三角不等式</strong>：</li>
</ul>
<center>

<p>$\delta(a,b)\leq\delta(a,c)+\delta(c,b)$对所有$a,b,c\in X$成立。</p>
</center>

<h3 id="例-1-出租车度量"><a href="#例-1-出租车度量" class="headerlink" title="例 1-出租车度量"></a>例 1-出租车度量</h3><p>若$X &#x3D; R$，则$\delta(x,y) &#x3D; \mid x-y\mid $是一个度量。</p>
<p>该度量被称为出租车度量，记为$l^1$</p>
<p>###例2-欧几里得度量</p>
<p>若$X &#x3D; R^n$，$x&#x3D; (x_1,\cdots,x_n)$，$y &#x3D; (y_1,\cdots,y_n)$，则$\delta(x,y)  &#x3D; \sqrt{\sum^n_{i&#x3D;1}(x_i-y_i)^2}$是一个度量，注意当$n&#x3D;1$时$\sqrt{x^2} &#x3D; \mid x\mid$变成了例1</p>
<p>###例3-$L^2$度量</p>
<p>设$L^2[a,b]$表示所有平方可积函数构成的集合，即$L^2[a,b] &#x3D; {f:[a,b]\to R:\int^b_a f^2(x)dx &lt; \infty}$，则</p>
<center>

<p>$\delta(f,g) &#x3D; \sqrt{\int^b_a (f(x)-g(x))^2dx}$</p>
</center>

<p>是$L^2[a,b]$上的一个度量</p>
<h3 id="例4-p-进制度量"><a href="#例4-p-进制度量" class="headerlink" title="例4-$p$进制度量"></a>例4-$p$进制度量</h3><p>若$p$是一个素数，$n\in Z$是非零的，则$n &#x3D; p^ku$，其中$k\geq 0$且$p\nmid u$，即$p^k$是整除$n$的p的最大方幂。记为$k &#x3D;k(n)$，若我们定义$n\neq m$，$\delta(n,n) &#x3D;0$和$\delta(n,m) &#x3D; p^{-k(n-m)}$，则$\delta$是$Z$上的一个度量。</p>
<h2 id="定义：汉明距离"><a href="#定义：汉明距离" class="headerlink" title="定义：汉明距离"></a>定义：汉明距离</h2><p>设$A$是一个字母表，$\omega &#x3D; (a_1,\cdots,a_n)$，$\omega’ &#x3D; (a_1’,a_2’,\cdots,a_n’)\in A^n$，定义函数$\delta:A^n\times A^n\to R$如下</p>
<center>

<p>$\delta(\omega,\omega’) &#x3D; $满足$a_i\neq a’_i$的i的个数</p>
</center>

<p>称为汉明距离</p>
<h3 id="命题"><a href="#命题" class="headerlink" title="命题"></a>命题</h3><p>若$A$是一个字母表，$n\geq 1$，则汉明距离是$A^n$上的一个度量。</p>
<p align="left">证明： 定义$\omega=(a_1,\cdots,a_n)$和$\omega'=(a_1',\cdots,a_n')\in A^n$，显然$\delta(\omega,\omega')\geq 0$。$\delta(\omega,\omega) =0$是一定的。其次，若$\delta(\omega,\omega') = 0$，则对所有$i$都存在$a_i = a_i'$，则有$\omega = \omega'$。现在，我们只需要证明三角不等式成立即可。</p>

<p>若定义$\delta_i(\omega,\omega’)&#x3D;1$，则$a_i\neq a_i’$，若$\delta_i(\omega,\omega’) &#x3D; 0$，则$a_i &#x3D; a_i’$，则</p>
<center>

<p>$\delta(\omega,\omega’) &#x3D; \sum^n_{i&#x3D;1}\delta_i(\omega,\omega’)$</p>
</center>

<p>我们只需要证明对每个$i$都有$\delta_i(\omega,\omega’) \leq \delta_i(\omega,z)+\delta_i(z,\omega’)$，其中$z &#x3D; (b_1,\cdots,b_n)$，若$\delta(\omega,\omega’) &#x3D; 0$，则不等式成立,否则$\delta_i(\omega,\omega’) &#x3D;1$，则对于$ \delta_i(\omega,z)+\delta_i(z,\omega’)$有三种可能，$0,1,2$。若等于0，则$ \delta_i(\omega,z) &#x3D; \delta_i(z,\omega’)$，则对于里面的元素就有$a_i &#x3D; b_i &#x3D; a_i’$，但$\delta(\omega,\omega’) &#x3D;1$，这是一个矛盾。</p>
<h3 id="定义：最小距离"><a href="#定义：最小距离" class="headerlink" title="定义：最小距离"></a>定义：最小距离</h3><p align ="left">若$A$是字母表，$C\subseteq A^n$是一个码，则其最小距离是：</p>

<center>

<p>$d &#x3D; d(C) &#x3D; \min_{\omega,\omega’\in C,\omega\neq \omega’}\delta(\omega,\omega’)$</p>
</center>

<p>其中$\delta(\omega,\omega’)$是汉明距离</p>
<p>现在我们说一些记号</p>
<p align="left">$A$上的一个$(n,M,d)$码指的是码$C\subseteq A^n$，其中$A$是一个字母表，$M =\mid C\mid$，$d$是最小距离。</p>


<p>然后我们给出查错与纠错的定义：</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>设$A$是一个字母表，$C\subseteq A^n$是一个码，码$C$可以查$s&gt;0$个错若至多$s$处改变一个码字$c\in C$使得得不到码字。</p>
<p>例如奇偶校验，我们更改里面一个坐标就可以把偶变成奇。</p>
<h3 id="定义：最靠近码字"><a href="#定义：最靠近码字" class="headerlink" title="定义：最靠近码字"></a>定义：最靠近码字</h3><p>设$A$是一个字母表，$C\subseteq A^n$是一个码，若$y\in A^n$则称$c\in C$是一个与$y$最靠近的码字，若对所有$c’\in C$有$\delta(y,c)\leq \delta(y,c’)$</p>
<h3 id="定义：纠错"><a href="#定义：纠错" class="headerlink" title="定义：纠错"></a>定义：纠错</h3><p>设$A$是字母表，$C\subseteq A^n$是码，称码$C$可以纠$t$个错，若至多$t$处改变一个码字$c$，得到一个字$y\in A^n$且$y$的唯一最靠近码字为$c$</p>
<h3 id="命题1"><a href="#命题1" class="headerlink" title="命题1"></a>命题1</h3><p align="left">设$A$是一个字母表，$C\subseteq A^n$是一个$(n,M,d)$码</p>


<ul>
<li>设$d\geq 2t+1$且$y\in A^n$，如果满足$\delta(y,c)\leq t$的码字$c\in C$存在的话，则它一定唯一。</li>
<li>若$d\geq s+1$，则$C$可以查$s$个错</li>
<li>若$d\geq 2t+1$，则$C$可纠$t$个错</li>
</ul>
<p align="left">证明1：设$c.c'$是满足$\delta(y,c) = \delta(y,c')\leq t$的码字，则利用三角不等式得到$\delta(c,y)+\delta(y,c') \leq 2t$但不同码字之间的最小距离$d(C)\geq \delta(c,c')+2t =  2t+1$，因此$c = c'$</p>

<p align="left">证明2：若$\omega\neq c$与$c$至多在$s$处不同，则$0<\delta(c,\omega) \leq s$，若$\omega\in C$，则有$s\geq \delta(c,\omega)\geq d > s$矛盾</p>

<p align="left">证明3：若$\omega$是改变$c$的至多$t$处所得，则$\delta(c,\omega)\leq t$，利用定义，我们设一个最靠近的码字$c'$满足$\delta(c',\omega) < \delta(c,\omega)$，由三角不等式得

<center>

<p>$\begin{aligned}<br>    2t+1\leq&amp; d\<br>    \leq &amp; \delta(c.c’)\<br>    \leq &amp; \delta(c,\omega)+\delta(\omega,c’)\<br>    \leq &amp; 2\omega(c,\omega) \leq 2t<br>\end{aligned}$</p>
</center>

<p>矛盾</p></p>
<h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><p>一个奇偶性校验$[m+1,m]$码是一个$(m+1,2^m,2)$码，是由$B^{m+1}$中具有偶数个1的字构成的，极小距离至少是2，因为改边具有偶数个1的字一处，则产生一个具有奇数个1的字，这个码可以查一个错，但不能纠错。</p>
<p>一个码若具有很大的极小距离，例如，一个$101-$次二重重复码，它是$[101m,m]-$码，它的编码函数$E:B^m\to B^{101m}$。将一个$m$位字重复$101$次，此时$d &#x3D; 101$利用命题1的3，我们知道其可纠$101\geq 2*50+1$，也就是50个错。但$C$显然不符合实际，所以我们现在要做的就是测量码的实际性。</p>
<h3 id="定义：信息率"><a href="#定义：信息率" class="headerlink" title="定义：信息率"></a>定义：信息率</h3><p>一个$[n.m]$码的信息率定义为$\frac{m}{n}$，若$\mid A\mid &#x3D; q$，那么$M &#x3D; q^m$，因此一个$(n,M,d)$码的信息率就是$(\log_q M)&#x2F;n$</p>
<p>信息率指的是，$n$个字母被用于发送$m$位的信息，例如我们刚才说的多重复码$[101m,m]$码，它的效率比较低，信息率为$\frac{1}{101}$，这个效率是非常低的，它意味着发送一段非常短的信息需要庞大数量的字母。反过来，无冗余码$[m,m]$码函数为$1_{A^m}:A^m\to A^m$。它的信息率是$1$，但它仅仅是无改变的重复信息。因此我们发现，信息率低的码可以纠多个错，但信息率大的则不能查错。所以$d$越大，它越精确。我们要做的，就是在精确和便捷找一个比较折中的方法。</p>
<h1 id="线性码"><a href="#线性码" class="headerlink" title="线性码"></a>线性码</h1><p>设$A$是任一集合，函数$E:A^m\to A^n$的定义可能很复杂，另一方面，若$A$是一个域，则$A^m$和$A^n$都是带有标准基的向量空间，若$E$是线性变换，则我们用下面的公式可高效的描述其：存在一个$m\times n$的矩阵$G$使得$E(\omega) &#x3D; \omega G$。其中$\omega$是$1\times m$的行向量。</p>
<h3 id="定义：线性码"><a href="#定义：线性码" class="headerlink" title="定义：线性码"></a>定义：线性码</h3><p align="left">有限域$k$上的一个$[n,m]$线性码$C$指的是$k^n$的一个$m$维子空间，$C$的一个编码函数$E:k^m\to k^n$是一个满足$E(k^m)= C$的单射线性变换。</p>

<p>若$k &#x3D; F_q$是一个具有$q$个元素的有限域，则一个$[n.m]$线性码就是一个$(n,q^m,d)$码。其中$d$是极小距离，我们来展示线性码中另一种求极小距离的方法。</p>
<h3 id="定义：支撑"><a href="#定义：支撑" class="headerlink" title="定义：支撑"></a>定义：支撑</h3><p align="left">若$\omega = (a_1,\cdots,a_n)\in k^n$，其中$k$是域，则$\omega$的支撑定义指的是

<center>

<p>$\mathrm{Supp}(\omega) &#x3D; {\text{index}~ i:a_i\neq 0}$</p>
</center>
</p>

<p align="left"> 若$C$是一个线性$(n,M,d)-$码,则$\omega$的汉明权是

<center>

<p>$\mathrm{wt}(\omega) &#x3D; \mid \mathrm{Supp}(\omega)\mid $</p>
</center>
</p>

<p>汉明权就是$\omega$中非零坐标的个数，而$\omega$的零集就是$\mathrm{Supp}(\omega)$的补集:</p>
<center>

<p>$Z(\omega) &#x3D; {\mathrm{index}~i:a_i &#x3D; 0}$</p>
</center>

<p>注意的是，汉明权又可以被我们重写为$\mathrm{wt}(\omega) &#x3D; \delta(\omega,0)$，其中$\delta$是汉明距离。且$0 &#x3D; (0,\cdots,0)$。</p>
<h3 id="命题2"><a href="#命题2" class="headerlink" title="命题2"></a>命题2</h3><p>若$C$是有限域$F_q$上的一个线性$(n,M,d)-$码，则</p>
<center>

<p>$d &#x3D; \min_{c\in C,c\neq 0}(\mathrm{wt}(c):c\in C)$</p>
</center>

<p>因此，$d$是非零码字的最小权数。</p>
<p align="left">证明：由于$C$是子空间，那么我们由$\omega-\omega'\in C$</p>

<p>$\begin{aligned}<br>    d &#x3D;&amp; \min_{w,w’\in C,w\neq w’}\delta(\omega,\omega’)\<br>    &#x3D;&amp; \min_{w,w’\in C,w\neq w’}{\mathrm{wt}(\omega-\omega’\neq 0)} \<br>    &#x3D;&amp; \min_{c\in C,c\neq 0}{\mathrm{wt}(c):c\in C}<br>\end{aligned}$</p>
<p>我们来引入一个可描述给定线性码的矩阵，为此先介绍关于一个矩阵U的划分</p>
<p align="left">设$A$是一个$m\times r$的矩阵$m\times r$矩阵，而$B$是一个$m\times s$的矩阵。则

<center>

<p>$U &#x3D; [A\mid B]$</p>
</center>

</p>

<p>是一个$m\times (r+s)$矩阵。它的头$r$列是矩阵$A$后s列是矩阵$B$。</p>
<p>设$\sigma\in S_{n}$是一个置换，$Q_\sigma$是对单位矩阵使用置换$\sigma$置换其列得到的$n\times n$矩阵，若$k$是一个域，$c &#x3D; (c_1,\cdots,c_n)\in k^n$是一个$1\times n$行向量，则</p>
<center>

<p>$cQ_\sigma &#x3D; (c_1,\cdots,c_n)Q_\sigma &#x3D; (c_{\sigma{(1)}},\cdots,c_{\sigma_{(n)}})$</p>
</center>

<p>其中$c_{\sigma_{(j)}} &#x3D; c\cdot e_{\sigma_{(j)}} &#x3D; (c_1,\cdots,c_n) \cdot (0,\cdots,1,\cdots,0)$</p>
<p>所以，若$Q_\sigma$是一个$n\times n$的置换矩阵，则定义$\sigma_{*}:k^n\to k^n$为</p>
<center>

<p>$\sigma_{*}(c) &#x3D; cQ_\sigma$</p>
</center>

<h3 id="置换等价"><a href="#置换等价" class="headerlink" title="置换等价"></a>置换等价</h3><p>定义：域$k$上的两个$[n,m]$线性码$C,C’$是置换等价的，若存在$\sigma\in S_n$使得$\sigma_*(C) &#x3D; C’$。</p>
<p>即$c &#x3D; (a_1,\cdots,a_n)\in C$当且仅当$(a_{\sigma(1)},\cdots,a_{\sigma(n)})\in C’$</p>
<h3 id="命题3"><a href="#命题3" class="headerlink" title="命题3"></a>命题3</h3><p>若$C$是域$k$上一个线性$[n,m]$码，则存在置换等价于$C$的线性码$C’$和一个具有形式$G &#x3D; [I\mid B]$的$m\times n$的矩阵$G$，其中$I$是$m\times m$的单位矩阵，使得</p>
<center>

<p>$C’ &#x3D; {\omega’G:\omega’\in k^m}$</p>
</center>

<p>因此，$C’$是矩阵$G$的行空间。</p>
<p align="left">证明：设$e_1,\cdots,e_m$是$k^m$的标准基，而$\gamma_1,\cdots,\gamma_m$是$C$的某组基。我们定义$E(e_i) = \gamma_i$决定线性映射$E:k^m\to k^n$，$E$是一个单射和满的。事实上，$E$是一个同构$k^m\cong C$，那么就有$E(\omega) = A\omega^T$。其中$\omega\in k^m$是一个$1\times m$的行向量。而$A$是列为向量$E(e_i)^T$的$n\times m$的矩阵。因为我们将$k^m$的元素看做行向量而不是列向量，则重记$E(\omega) = \omega N$。其中$N = A^T$是一个$m\times n$的矩阵。</p>

<p>利用高斯消元法，它将矩阵$N$变为一个阶梯型矩阵$G$，存在一个非奇异矩阵$m\times n$矩阵$P$和一个$n\times n$的置换矩阵$Q_\sigma$使得$G &#x3D; PNQ_\sigma &#x3D; [U\mid B]$，其中$U$是一单位矩阵。现在，因为$E$是单射的，基的数量为$m$。则阶梯型矩阵$U$是$m\times m$的。因此$B$是$m\times (n-m)$矩阵。从而$G &#x3D; [I\mid B]$。定义</p>
<center>

<p>$C’ &#x3D; {\omega’G :\omega’\in k^m}$</p>
</center>

<p>由于$e_1G,\cdots,e_mG$是线性无关的表，那么由$m\leq \dim(C’)$。我们断言$C,C’$是置换等价的，也就是有$C’ &#x3D; \sigma_*(C’)$。不妨设$c’ &#x3D; \omega’G\in C’$。定义$\omega &#x3D;\omega’P$和$c &#x3D; \omega N$。注意$c\in C$，因为$\omega N &#x3D; E(\omega) \in C$。则有</p>
<center>

<p>$\begin{aligned}<br>    c’ &#x3D;&amp; \omega’G\<br>    &#x3D;&amp; \omega’ PNQ_\sigma\<br>    &#x3D;&amp;\omega NQ_\sigma\<br>    &#x3D;&amp; \omega NQ_\sigma\<br>    &#x3D;&amp; cQ_\sigma\<br>    &#x3D;&amp; \sigma_*(c)<br>\end{aligned}$</p>
</center>

<p>因此，$C’\subseteq \sigma_* (C)$，从而我们由$m\leq \dim(C’)\leq \dim( \sigma_*(C)) &#x3D; \dim(C) &#x3D;m$。那么由于$C’$是$\sigma_*(C)$的子空间而维数相同，则$\sigma_*(C)&#x3D; C’$，因此$C,C’$是置换等价的码。</p>
<h3 id="定义：生成矩阵"><a href="#定义：生成矩阵" class="headerlink" title="定义：生成矩阵"></a>定义：生成矩阵</h3><p>若$C$是域$k$上的一个$[n,n]$线性码，则满足$C &#x3D; \mathrm{ROW}(G) &#x3D; {\omega G:\omega\in k^n}$的$m\times n$矩阵称为$C$的生成矩阵，C的阶梯型生成矩阵具有形式$G &#x3D; [I\mid B]$的生成矩阵，其中$I$是$m\times m$矩阵。</p>
<p>每一个线性码$C$都有一个生成矩阵，例如：任一由其行向量构成$C$的一组基的$m\times n$的矩阵就是$C$的一个生成矩阵。再利用命题3，我们可以假设每一个线性码都有一个阶梯型生成矩阵。</p>
<h3 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h3><p>一个奇偶性校验$[m+1,m]$码$C$，码字是满足$\sum b_i&#x3D;0$的$c &#x3D; (b_1,\cdots,b_{m+1})\in B^{m+1}$，这些码构成一个子空间，因此$C$是一个线性码。现在，我们看看映射$E:B^m\to B^{m+1}$，它被定义为</p>
<center>

<p>$E:(a_1,\cdots,a_m) \to (a_1,\cdots,a_m,b)$</p>
</center>

<p>其中$b &#x3D; \sum^m_{i&#x3D;1} a_i$，显然这是一个线性变换，它的阶梯型生成矩阵可以写为如下的$m\times (m+1)$的矩阵</p>
<center>

<p>$G &#x3D;  \begin{bmatrix}<br>    1&amp;		0&amp;		0&amp;		\cdots&amp;		0&amp;		1\<br>    0&amp;		1&amp;		0&amp;		\cdots&amp;		0&amp;		1\<br>    \vdots&amp;		\vdots&amp;		\vdots&amp;		&amp;		\vdots&amp;		\vdots\<br>    0&amp;		0&amp;		0&amp;		\cdots&amp;		1&amp;		1\<br>\end{bmatrix}  $</p>
</center>

<p>用记号划分，$G &#x3D; [I\mid B]$，其中$I$是$m\times m$的单位矩阵，$B$是所有元素为1的列向量。</p>
<h3 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h3><p>三重复$[3m,m]$码的阶梯型生成矩阵是$G &#x3D; [I\mid I\mid I]$</p>
<h3 id="命题4"><a href="#命题4" class="headerlink" title="命题4"></a>命题4</h3><p>设$G &#x3D; [I\mid B]$是域$k$上的一个线性$[m+p,m]$码的$m\times (m+p)$的阶梯型生成矩阵。则$\omega\in k^{m+p}$落在$C$中当且仅当$\omega[-B^T\mid J^T] &#x3D;0$其中$J$是$p\times p$的单位矩阵。</p>
<p>证明：记$(m+p)\times p$的矩阵$[-B^{T}\mid J]$为$H$。由于$C$是$G$的行空间，那么每个码字$c$是$G$的行的一个线性组合。$G$的第$i$行是$e_i G$，其中$e_i,i &#x3D; 1,2,\cdots,m$是$k^m$的标准基。那么$c &#x3D; \sum_i a_i(e_iG)$，其中$a_i\in k$。我们只要证明$GH^T &#x3D;0$即可。因为这样子就得到$cH^T &#x3D; \sum_i a_ie_iGH^T &#x3D; 0$</p>
<p>$v,w\in k^{m+p}$的点积等于矩阵的乘积$v\cdot w &#x3D; vw^T$。而$GH^T$的$ij$位元素是$\mathrm{ROW_G(i)} \cdot \mathrm{\mathrm{COL}<em>{H^T(j)}} &#x3D; \mathrm{ROW_G(i)} \cdot \mathrm{\mathrm{COL}</em>{H^T(j)}}^T$，那么$G$的第$i$行是</p>
<center>

<p>$\mathrm{ROW}<em>{G}(i) &#x3D; e_iG &#x3D; e_i[I\mid B] &#x3D; [e_i\mid e_iB] &#x3D; (e_i,b</em>{i1},\cdots,e_{im})$</p>
</center>

<p>而$H^T$的第$j$列是$H^T(e’_j)^T$，其中$e_1’,\cdots,e_p’$是$k^p$上的标准基。且$(e_j’)^T$是列向量。那么</p>
<center>

<p>$H^T(e_j’) &#x3D; [-B^T\mid J]^T(e_j’)^T &#x3D; (e’_j[-B^T\mid J])^T &#x3D; [-e_j’B^T\mid e’_j]^T$</p>
</center>

<p>但$e’_jB^T$是$B^T$的第$j$行，这是$B$的第$j$列。那么</p>
<center>

<p>$\mathrm{COL}<em>{H^T}(j) &#x3D; (-b</em>{1j},&#x3D;b_{2j},\cdots -b_{pj},e_j’)^T$</p>
</center>

<p>且</p>
<center>

<p>$\mathrm{COL}<em>{H^T}(j)^T &#x3D; (-b</em>{1j},\cdots,-b_{pj},e_j’)$</p>
</center>

<p>因此$GH^T$的$ij$位元素是</p>
<center>

<p>$\begin{aligned}<br>    \mathrm{ROW}<em>G(i)\cdot \mathrm{COL}</em>{H^T}(j) &#x3D;&amp; \mathrm{ROW}<em>G(i)(\mathrm{COL}</em>{H^T}(j))^T\<br>    &#x3D;&amp; (e_i,b_{i1},\cdots,b_{ip}) \cdot (-b_{1j},\cdots,-b_{pj},e’_j)<br>\end{aligned}$</p>
</center>

<p>注意这里我们用$(0,\cdots,e_i,\cdots,0)$去简写为$e_i$，由于$e_i$是$1\times m+p$的行向量而$e_j’$是$1\times m+p$的行向量那么对于$e_i$做内积我们得到$b_{ij}$，同样的我们得到$-b_{ij}$，那么结果就是0。</p>
<p>反之，我们考虑其次方程组$[-B^T\mid J]^Tx^T &#x3D; 0$和其解空间$S &#x3D; {v^T\in k^{m+p}:[-B^T\mid J]^Tv^T &#x3D; 0}$，那么就有$v[-B^T\mid J] &#x3D; 0$，由我们一开始写的就有$C\subseteq S$。但$\dim(C) &#x3D; m$,，而$\dim(S) &#x3D; m+p-r$，其中$r &#x3D; rank([-B^T\mid J]^T) &#x3D;p$，那么就有$\dim(S) &#x3D; m+p-p&#x3D;m$，由$C &#x3D; S$，因此，若$w[-B^T\mid J]^T &#x3D; 0$，那么$w\in S$有$W\in C$</p>
<h3 id="定义：奇偶校验矩阵"><a href="#定义：奇偶校验矩阵" class="headerlink" title="定义：奇偶校验矩阵"></a>定义：奇偶校验矩阵</h3><p>设$C$是域$k$上的一个线性$[(m+p),m]$码，一个$m\times (m+p)$的句子$H$称为$C$的一个奇偶性校验矩阵，若对所有$w\in k^{m+p}$都有$wH^T &#x3D;0$当且仅当$w\in C$</p>
<h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>若$A$是域上一个$m\times n$矩阵，其中$m&lt;n$，则由它的列组成的表是线性相关的，定义：</p>
<center>

<p>$\mu(A) &#x3D; A$的线性相关的列的最小列数。</p>
</center>

<p>若$A$是一个$m\times n$的矩阵，$m&lt;n$和$\mathrm{rank} &#x3D; r$，那么</p>
<center>

<p>$\mu(A) \leq r+1$</p>
</center>

<h3 id="推论1"><a href="#推论1" class="headerlink" title="推论1"></a>推论1</h3><p>设$C$是域$k$上的一个线性$[n,m]$码，$H$是$C$的一个奇偶校验矩阵，则</p>
<ul>
<li>$d(C) &#x3D; \mu(H)$</li>
<li>$d(C)  \leq m+1$</li>
</ul>
<p><strong>证明：</strong>设$\beta_1,\cdots,\beta_n$是$H$的列向量，由于$H$是$C$的一个奇偶校验矩阵，那么字$y &#x3D; (y_1,\cdots,y_n)\in C$当且仅当$yH^T &#x3D; 0$。而$yH^T &#x3D;0$当且仅当$Hy^T &#x3D;0$，即</p>
<center>

<p>$y_1\beta_1+\cdots y_n\beta_n &#x3D;0$</p>
</center>

<p>设$d(C) &#x3D;d $，取权位$d$的码字$y\in C$，设$y_{i_1},\cdots,y_{i_d}$为$y$的非零坐标。由于$y$是一个非零的码字，所以</p>
<center>

<p>$0 &#x3D; Hy^T &#x3D;y_1\beta_1+\cdots+y_n\beta_n &#x3D;$</p>
</center>

<p>则这个线性组合是线性相关的。那么$\mu(H) \leq d$。另外，我们设存在线性相关表，但长度有$p&lt;d$，则存在不全为零的纯量$z &#x3D; z_{j_1},\cdots,z_{j_p}$，将$z$扩充成一组基，那么就有$Hz^T &#x3D; 0$使得$z\in C$但$d(z) \neq d$矛盾。</p>
<p>证明2：$\mu(H)\leq r+1$，其中$r &#x3D; \mathrm{rank}(H) &#x3D;r$，因此$r &#x3D;m$</p>
<p>若$k$是一个域，其中$f(x)\in k[x]$，$I &#x3D; (f(x))$是由$f(x)$生成的主理想。则$k[x]&#x2F;I$是$k$上的一个向量空间，基为$1,z,\cdots,z^{n-1}$。并且我们可以找到一个与其同构的$n$维线性空间$k^n$。我们记$k^n$中的字为$(a_0,\cdots,a_{n-1})$而不是$(a_1,\cdots,a_n)$。则$(a_0,\cdots,a_{n-1})\to a_0+\cdots+a_{n-1}z^{n-1}$是$k^n\to k[x]&#x2F;I$的一个同构。</p>
<h3 id="定义：循环码"><a href="#定义：循环码" class="headerlink" title="定义：循环码"></a>定义：循环码</h3><p>定义域上长度为$n$的循环码是一个满足以下条件的线性码$C$</p>
<center>

<p>$(a_0,a_1,\cdots,a_{n-1})\in C$可以推出$(a_{n-1},a_0,\cdots,a_{n-2})\in C$</p>
</center>

<h3 id="命题5"><a href="#命题5" class="headerlink" title="命题5"></a>命题5</h3><p>令$k$是有限域，再令$I &#x3D; (x^n-1)$是由$x^n-1$生成，在$k[x]$中的主理想。再令$z&#x3D;x+I$。则$C\subseteq k[x]&#x2F;I$是循环码当且仅当$C$是交换环$k[x]&#x2F;I$中的主理想。更多的，$C &#x3D; (g(z))$，其中$g(x)$是$x^n-1$在$k[x]$中的首一因子</p>
<p><strong>证明：</strong> 令$C$是$k[x]&#x2F;I$中的理想，再令$c &#x3D; a_0+a_1z+\cdots +a_{n-1}z^{n-1}$，则$C$包含$zc &#x3D; a_0z+a_1z^2+\cdots +a_{n-2}z^{n-1} + a_{n-1}z^n$。但$z^n &#x3D;1$。这是因为$z$是$x^n-1$的根。那么$a_{n-1}+a_0z+\cdots a_{n-2}z^{n-1}\in C$，因此$C$是循环的。</p>
<p>反之，我们设$C$是循环码，由于$C$是线性码，$C$对$k$中元素在加法和乘法下封闭。乘$z$相当于是向左移动一步。然后就可以让$a_{n-1}$变成常数项。由于对加法和乘法封闭，那么$0\in I$，取$f(z),g(z)\in k[x]&#x2F;I$，那么$f+g &#x3D; (a_0+b_0)+\cdots + (a_{n-1}+b_{n-1})z^{n-2}\in C$。最后，由于$z$是$x^n-1$的根，那么对于任意的$n$，$z^ng(z)$是关于字$(a_0,\cdots,a_{n-1})$的一个置换，那么依然在$C$中，综上所述。$C$是一个理想</p>
<p>现在，令$\beta:k[x] \to k[x]&#x2F;I$是一个自然映射。且考虑逆像$J &#x3D; \beta^{-1}(C) &#x3D; {f(x)\in k[x]:f(z)\in C}$。现在我们利用下面的习题辅助证明：</p>
<hr>
<p>令$R,S$是交换环，再令$\psi:R\to S$是同态，其中$\ker\psi &#x3D; I$。若$J$是$S$中的理想，证明$\psi^{-1}(J)$是理想且包含$I$</p>
<p>证明：由于$\psi$是同态，$\ker &#x3D;I$，那么有$\psi(0) &#x3D;0$，其次，由于$I$是$S$中的真理想，那么就有$\psi(a+b) &#x3D;\psi(a)+\psi(b) &#x3D;0$成立，其中$a,b\in I$。最后，由于$a\in R,b\in I$使得$\psi(ab) &#x3D; 0$。都在$J$中，一定的，对于$\psi^{-1}(J)$就有$a+b,ab\in\psi^{-1}(J)$中。因此$\psi^{-1}(J)$是包含$I$的理想。</p>
<hr>
<p>那么$J$是一个在$k[x]$中包含$x^n-1$的理想。但$k[x]$中的理想都是主理想。那么就存在一首一多项式$g(x)\in k[x]$使得$J &#x3D; (g(x))$成立。因此$x^n-1\in J$。我们有$x^n-1&#x3D;h(x)g(x)$对某个多项式$h(x)$成立。所以，$g(x)\mid (x^n-1)$。最后，由于$J$是由$g(x)$生成的，它表明$C &#x3D; \beta(J)$是由$\beta(g(x))&#x3D;g(z)$生成的。</p>
<h3 id="定义：生成多项式"><a href="#定义：生成多项式" class="headerlink" title="定义：生成多项式"></a>定义：生成多项式</h3><p>令$C\subseteq k[x]&#x2F;I$是循环码，其中$I &#x3D; (x^n-1)$。若$C &#x3D; (g(z))$，其中$g(x)\in k[x]$。我们说$g(x)$是生成$C$的生成多项式。其中$z &#x3D; x+I$</p>
<p>由上面的命题5，长度为n的一个循环码的生成多项式$g(x)$是$x^n-1$的一个因子。</p>
<h3 id="引理1"><a href="#引理1" class="headerlink" title="引理1"></a>引理1</h3><p>若$C$是域$k$上长度为$n$的循环码，其生成多项式为$g(x)$，则$\dim(C) &#x3D; n-\deg(g)$</p>
<p>证明：由于$g(x)\mid (x^n-1)$，那么就存在一个理想的包含$I&#x3D;(x^n-1)\subseteq (g(x))&#x3D;J$。$k[x]$和其商环也仅仅是作为$k$上的向量空间。那么由$h(x)+I \to h(x)+J$给出的陪集的拓展函数：$\gamma:k[x]&#x2F;I\to k[x]&#x2F;J$是一个满的线性变换。现在，为了计算$\ker\gamma$，我们考虑一个关系：</p>
<center>
    <img style="border-radius: 0.3125em;
                box-shadow: 0 2px 4px 0 rgba(34,36,38,.12), 0 2px 10px 0 rgba(34,36,38,.08);
                border: 10px solid transparent;
                margin-bottom: 20px"
        src="https://i.upmath.me/svg/%5Cbegin%7Btikzpicture%7D%5Bx%3D0.75pt%2Cy%3D0.75pt%2Cyscale%3D-1%2Cxscale%3D1%5D%0A%25uncomment%20if%20require%3A%20%5Cpath%20(0%2C310)%3B%20%25set%20diagram%20left%20start%20at%200%2C%20and%20has%20height%20of%20310%0A%0A%25Straight%20Lines%20%5Bid%3Ada20450973618657287%5D%20%0A%5Cdraw%20%20%20%20(164%2C139)%20--%20(236.82%2C139)%20%3B%0A%5Cdraw%20%5Bshift%3D%7B(238.82%2C139)%7D%2C%20rotate%20%3D%20180%5D%20%5Bcolor%3D%7Brgb%2C%20255%3Ared%2C%200%3B%20green%2C%200%3B%20blue%2C%200%20%7D%20%20%5D%5Bline%20width%3D0.75%5D%20%20%20%20(10.93%2C-3.29)%20..%20controls%20(6.95%2C-1.4)%20and%20(3.31%2C-0.3)%20..%20(0%2C0)%20..%20controls%20(3.31%2C0.3)%20and%20(6.95%2C1.4)%20..%20(10.93%2C3.29)%20%20%20%3B%0A%25Straight%20Lines%20%5Bid%3Ada22328292793349958%5D%20%0A%5Cdraw%20%20%20%20(271%2C169)%20--%20(271%2C229.82)%20%3B%0A%5Cdraw%20%5Bshift%3D%7B(271%2C231.82)%7D%2C%20rotate%20%3D%20270%5D%20%5Bcolor%3D%7Brgb%2C%20255%3Ared%2C%200%3B%20green%2C%200%3B%20blue%2C%200%20%7D%20%20%5D%5Bline%20width%3D0.75%5D%20%20%20%20(10.93%2C-3.29)%20..%20controls%20(6.95%2C-1.4)%20and%20(3.31%2C-0.3)%20..%20(0%2C0)%20..%20controls%20(3.31%2C0.3)%20and%20(6.95%2C1.4)%20..%20(10.93%2C3.29)%20%20%20%3B%0A%25Straight%20Lines%20%5Bid%3Ada2294031727863617%5D%20%0A%5Cdraw%20%20%20%20(143%2C160)%20--%20(238.04%2C243.5)%20%3B%0A%5Cdraw%20%5Bshift%3D%7B(239.55%2C244.82)%7D%2C%20rotate%20%3D%20221.3%5D%20%5Bcolor%3D%7Brgb%2C%20255%3Ared%2C%200%3B%20green%2C%200%3B%20blue%2C%200%20%7D%20%20%5D%5Bline%20width%3D0.75%5D%20%20%20%20(10.93%2C-3.29)%20..%20controls%20(6.95%2C-1.4)%20and%20(3.31%2C-0.3)%20..%20(0%2C0)%20..%20controls%20(3.31%2C0.3)%20and%20(6.95%2C1.4)%20..%20(10.93%2C3.29)%20%20%20%3B%0A%0A%25%20Text%20Node%0A%5Cdraw%20(122%2C129.4)%20node%20%5Banchor%3Dnorth%20west%5D%5Binner%20sep%3D0.75pt%5D%20%20%20%20%7B%24k%5B%20x%5D%24%7D%3B%0A%25%20Text%20Node%0A%5Cdraw%20(249%2C132.4)%20node%20%5Banchor%3Dnorth%20west%5D%5Binner%20sep%3D0.75pt%5D%20%20%20%20%7B%24k%5B%20x%5D%20%2FI%24%7D%3B%0A%25%20Text%20Node%0A%5Cdraw%20(193%2C115.4)%20node%20%5Banchor%3Dnorth%20west%5D%5Binner%20sep%3D0.75pt%5D%20%20%20%20%7B%24%5Calpha%20%24%7D%3B%0A%25%20Text%20Node%0A%5Cdraw%20(248%2C241.4)%20node%20%5Banchor%3Dnorth%20west%5D%5Binner%20sep%3D0.75pt%5D%20%20%20%20%7B%24k%5B%20x%5D%20%2FJ%24%7D%3B%0A%25%20Text%20Node%0A%5Cdraw%20(296%2C185.4)%20node%20%5Banchor%3Dnorth%20west%5D%5Binner%20sep%3D0.75pt%5D%20%20%20%20%7B%24%5Cgamma%20%24%7D%3B%0A%25%20Text%20Node%0A%5Cdraw%20(149%2C203.4)%20node%20%5Banchor%3Dnorth%20west%5D%5Binner%20sep%3D0.75pt%5D%20%20%20%20%7B%24%5Cbeta%20%24%7D%3B%0A%0A%0A%5Cend%7Btikzpicture%7D" 
        width="38%">
</center>

<p>其中$\alpha,\beta$是自然映射，而$\beta &#x3D; \gamma\circ \alpha$。并且$\alpha,\beta,\gamma$是满射。我们引入习题来辅助证明：</p>
<hr>
<p>令$A,B$和$C$是群，且令$\alpha,\beta,\gamma$是同态映射使得$\gamma\circ\alpha &#x3D;\beta$。若$\alpha$是满射，证明$\ker\gamma &#x3D; \alpha(\ker\beta)$</p>
<p align="left">证明：$\gamma\circ\alpha = \beta$，我们设$a\in \ker\beta$，那么$\beta (a) = \gamma\circ\alpha (a)=1$，那么就有$\beta(\ker\beta) = \gamma\circ\alpha(\ker\beta) =1 \Rightarrow \ker\gamma = \alpha(\ker\beta)$</p>


<p>其次，若有$b\in \beta$且属于$\ker\gamma$。由于$\alpha$是满射，那么就存在$\alpha^{-1}$的一个集合：$\alpha^{-1}(\ker\gamma) &#x3D; \alpha^{-1}(\alpha(\ker\beta))&#x3D;\ker\beta$</p>
<hr>
<p>让我们继续证明。那么</p>
<center>

<p>$\ker\gamma &#x3D; \alpha(\ker\beta) &#x3D; \alpha(g(x)) &#x3D; (g(z)) &#x3D; C$</p>
</center>

<p>其中$z&#x3D;x+I$，我们把其看做线性空间。那么由第一同构定理，$(k[x]&#x2F;I)&#x2F;C\cong k[x]&#x2F;J$，因此</p>
<center>

<p>$\dim(k[x]&#x2F;I) - \dim(C) &#x3D; \dim(k[x]&#x2F;J)$</p>
</center>

<p>但$\dim(k[x]&#x2F;I) &#x3D; \deg(x^n-1) &#x3D;n$和$\dim(k[x]&#x2F;J) &#x3D; \dim(k[x]&#x2F;g(x))&#x3D;\deg(g)$，因此$\dim(C) &#x3D; n-\deg(g)$</p>
<h3 id="引理2"><a href="#引理2" class="headerlink" title="引理2"></a>引理2</h3><p>若$C$是长度为$n$的循环码，其生成多项式$g(x) &#x3D;g_0+g_1x+\cdots+g_sx^s$，则$C$的生成矩阵是$(n-s)\times n$矩阵</p>
<center>

<p>$<br>\begin{bmatrix}<br>    g_0&amp;		g_1&amp;		g_2&amp;		\cdots&amp;		g_s&amp;		0&amp;		0&amp;		\cdots&amp;		0\<br>    0&amp;		g_0&amp;		g_1&amp;		g_2&amp;		\cdots&amp;		g_s&amp;		0&amp;		\cdots&amp;		0\<br>    0&amp;		0&amp;		g_0&amp;		g_1&amp;		g_2&amp;		\cdots&amp;		g_s&amp;		\cdots&amp;		0\<br>&amp; &amp; \vdots &amp; &amp;\vdots &amp;\<br>    0&amp;		0&amp;		\cdots&amp;		0&amp;		g_0&amp;		g_1&amp;		g_2&amp;		\cdots&amp;		g_s\<br>\end{bmatrix}<br>$</p>
</center>

<p>证明：由于$C$是理想，那么$g(x),xg(x),x^2g(x)\cdots x^{n-s}g(x)$都是码字，而且这些码字对应于$G$的行。记$G &#x3D; [T\mid B]$，其中$T$是$(n-s)\times(n-s)$的子阵，由$G$的前$n-s$列组成。而$T$是一个上三角矩阵，它的对角线的元素都是$g_0$，那么$\det(T) &#x3D;g_0^s$。现在$g_0$是$g(x)$所有乘积的根。但$g(x)$的根是单位根。因为$g(x)\mid (x^n-1)$，所以$g_0\neq 0$。所以$\det(T)\neq 0$。那么前$n-s$行是线性无关的。所以$\dim(C) &#x3D;n-s$。那么这$n-s$行构成一个$C$的基，所以$G$是$C$的生成矩阵。</p>
<p>###命题6</p>
<p>有限域$F_q$存在$q$个元素，设$n$是正整数，则$F_q$的某个扩域存在一个$n$次单位根在当且仅当$(n,q)&#x3D;1$</p>
<p>**Proof:**我们设$(n,q)&#x3D;1$和$E&#x2F;F_q$是$f(x)&#x3D;x^n-x$在$F_q$上的分裂域。现在，导数$f’(x) &#x3D; nx^{n-1}-1\neq 0$，那么$(f,f’)&#x3D;1$，我们知道$f(x)$是无重根的。若$K$是所有根的集合，由于$f(x)$的根都是$n$次单位根，则$K$是阶为$n$的乘法群。但$K$是循环群，则$K$的生成元一定是$n$次单位根</p>
<p>反之，我们设存在一个$n$次单位根，现在$q &#x3D; p^s$对某个素数$p$成立。若$(n,q)\neq 1$，则$p\mid n$，那么$n &#x3D;pu$对某个整数$u$成立。则$x^n-1 &#x3D; x^{pu}-1 &#x3D; (x^u-1)^p$，那么我们发现所有$n$次单位根组成的集合元素个数少于$n$，那就不存在$n$次单位根了。</p>
<p>定理介绍的足够多了，我们来构造一些能纠很多错的码。</p>
<h3 id="定理1-Bose-Chaudhuri-Hoequenghem"><a href="#定理1-Bose-Chaudhuri-Hoequenghem" class="headerlink" title="定理1 Bose-Chaudhuri-Hoequenghem"></a>定理1 Bose-Chaudhuri-Hoequenghem</h3><p>令$F_q$是具有$q$个元素的域，再设$n$是正整数使得$(n,q)&#x3D;1$，并且$C$是由$g(x)$生成的循环码。若$\zeta$是$n$次单位根，且它连续的幂次$\zeta^u,\zeta^{u+1},\cdots,\zeta^{u+l}$是$g(x)$的根，其中$u+l&lt; n$，则$d &#x3D; d(C) \geq l+2$</p>
<p><strong>证明：</strong>码字$c &#x3D; (c_0,c_1,\cdots,c_{n-1})\in (F_q)^n$确定一个多项式$c_0+c_1x+\cdots+c_{n-1}x^{n-1}\in F_q[x]$，它的权$\mathrm{wt}(c)$是系数中不为零的数量。利用命题2，我们开始只需要证明每个非零码字有至少$l+2$个非零系数。我们用反证法，设存在权$\mathrm{wt}(c)&lt; l+2$的码字$c$。那么$c(x) &#x3D; c_{i_1}x^{i_1}+\cdots+c_{i_{l+1}}x^{i_{l+1}}$，其中$i_1 &lt; \cdots &lt;\cdots &lt;i_{l+1}$。若$\alpha\in F_q$，那么$c(\alpha)$可以写为</p>
<center>

<p>$c(\alpha)&#x3D;[c_{i_{1}}c_{i_{2}}\ldots c_{i_{\ell+1}}][1~\alpha^{i_{1}}\alpha^{i_{2}}\ldots\alpha^{i_{\ell+1}}]^{T}.$</p>
</center>

<p>现在我们构造一个$(l+1)\times(l+1)$矩阵$W$，其第$j$列由$\zeta^{n+j}$得到，其中$0\leq j\leq l$。</p>
<center>

<p>$W&#x3D;\begin{bmatrix}\zeta^{ui_1}&amp;\zeta^{ui_2}&amp;\cdots&amp;\zeta^{ui_{\ell+1}}\\zeta^{(u+1)i_1}&amp;\zeta^{(u+1)i_2}&amp;\cdots&amp;\zeta^{(u+1)i_{\ell+1}}\&amp;\vdots&amp;\vdots&amp;\\zeta^{(u+\ell)i_1}&amp;\zeta^{(u+\ell)i_2}&amp;\cdots&amp;\zeta^{(u+\ell)i_{\ell+1}}\end{bmatrix}.$</p>
</center>


<p>若$c_* &#x3D; [c_{i_1}~\cdots ~c_{i_{l+1}}]$，那么由题设，$\zeta^u$的连续幂次是一个$c[x]$的根，则</p>
<center>

<p>$Wc_*^T&#x3D;[c(\zeta^u)c(\zeta^{u+1})\ldots c(\zeta^{u+\ell})]^T&#x3D;0$</p>
</center>

<p>把$W$变一下，我们有发现每一列都是第一个元素的幂次，只需要用第一行去除剩下的行就得到简化的$(l+1)\times (l+1)$矩阵$V$：</p>
<center>

<p>$V &#x3D; \begin{bmatrix}1&amp;1&amp;\dots&amp;1\\zeta^{i_1}&amp;\zeta^{i_2}&amp;\dots&amp;\zeta^{i_{\ell+1}}\\xi^{2i_1}&amp;\xi^{2i_2}&amp;\dots&amp;\xi^{2i_{\ell+1}}\\vdots&amp;\vdots&amp;\vdots&amp;\\zeta^{\ell i_1}&amp;\zeta^{\ell i_2}&amp;\dots&amp;\zeta^{\ell i_\ell}\end{bmatrix}.$</p>
</center>


<p>这是一个行列式为范德蒙行列式的矩阵，那么其行列式的值</p>
<center>

<p>$\det(W) &#x3D; \zeta^{ui_{1}}\cdots \zeta^{ui_t}\det(V) &#x3D; \zeta^{ui_{1}}\cdots \zeta^{ui_l} \prod_{j &lt; k} (\zeta^{i_k}-\zeta^{i_j})$</p>
</center>

<p>若$\zeta^{i_j}$不是互异的，那么行列式的值是0。这和我们一开始声称的一系列n次单位根矛盾。所以$\det(W)\neq 0$。其次，由于$c^T_*\neq 0$，$Wc^T_*&#x3D;0$，这是一个矛盾，因为$W$是非退化的，但由$c^T_* \neq 0$推出$W &#x3D; 0$。因此权$&lt;l+2$的码字不存在，$d(C)\geq l+2$</p>
<h3 id="定义：BCH-code"><a href="#定义：BCH-code" class="headerlink" title="定义：BCH-code"></a>定义：BCH-code</h3><p>域$k$上的线性码是长度为$n$的<strong>BCH</strong>码，我们说他是一个具有最小可能次数的生成多项式$g(x)$的循环码，且$g(x)$的根中存在连续方幂$\zeta^{u},\zeta^{u+1},\ldots,\zeta^{u+\ell}$，其中$\zeta$是$n$次单位根且$0\leq u\leq u+l &lt; n$</p>
<h3 id="引理3"><a href="#引理3" class="headerlink" title="引理3"></a>引理3</h3><p>设$C$是一个长度为$n$的$BCH$码，其生成多项式是$g(x)$，若连续方幂$\zeta^u,\zeta^{u+1},\cdots,\zeta^{u+l}$出现在$g(x)$的根中，其中$l &#x3D;2t$或者$l&#x3D;2t+1$且$u+l &lt; n$，则$C$可以纠t个错</p>
<p><strong>Proof：</strong>利用定理1，我们知道$d(C) \geq l+2 \geq 2t+1$，所以$C$能纠t个错</p>
<h3 id="引理4"><a href="#引理4" class="headerlink" title="引理4"></a>引理4</h3><p>对每个素数$p$和任意正整数$t$，则存在$F_p$上的$BCH$码$C$可以纠$t$个错。</p>
<p><strong>Proof：</strong> 我们令$k &#x3D; F_q$，其中$q$是$p$的幂次<a href="%E6%88%91%E4%BB%AC%E8%BF%99%E6%A0%B7%E5%AD%90%E5%AE%9A%E4%B9%89%E6%98%AF%E5%8F%AF%E4%BB%A5%E7%9A%84%EF%BC%8C%E5%88%A9%E7%94%A8%E8%BF%A6%E7%BD%97%E7%93%A6%E5%AE%9A%E7%90%86%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E6%89%BE%E5%88%B0$F_p$%E7%9A%84%E4%B8%80%E4%B8%AA%E6%89%A9%E5%9F%9F%E8%AE%A9%E5%AE%83%E5%8C%85%E5%90%AB$F_p$.">^1</a>且$2t+1 \leq q-1$。那么$F_q$是一个$q-1$阶的乘法群。它的生成元$\zeta$是$q-1$次的本元单位根。因此$\zeta,\cdots,\zeta^{2t+1}$是互异的元素，对每个$j$，我们可以利用根构造不可约多项式$h_j(x)\in k[x]$使得其以$\zeta^j$作为根，最后，定义</p>
<center>


<p>$g(x) &#x3D;\mathrm{lcm}({h_1(x),\cdots,h_{2t+1}(x)})$</p>
</center>

<p>并定义$C$是由$g(x)$生成的$BCH$码，利用定理$1$我们知道$d(C)\geq 2t+1$，然后再利用引理3即可证明完毕。</p>
<h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><p>我们来讨论$F_8$，它是一个元素非零阶为7的乘法群，那么他有一个$7$次本原单位根$\zeta$，也是生成元。那么就有一些不可约多项式$g(x)\in F_2[x]$将$\zeta$作为其根。那么$\deg(m) &#x3D; 3 &#x3D; \dim_{F_2}(F_8)$。事实上，这些多项式是$x^3+x+1$和$x^3+x^2+1$。他们在$F_2[x]$中是不可约的。那么，我们首先来选择一个根$\zeta$作为第一个多项式的根，它是</p>
<center>

<p>$\zeta^3 + 2\zeta+2&#x3D; 0+ \zeta+1 \Rightarrow \zeta+1$</p>
</center>

<p>由于$1 +1 \equiv 2 &#x3D;0$，那么$F_8$作为$F_2$上的扩张域特征为$2$。其次，由于加法交换，那么其加法表是一个对称矩阵，我们只需要计算其上三角部分即可</p>
<center>

<p>$\begin{array}{|c|c|c|c|c|c|c|c|c|c|}\hline+&amp;1&amp;\zeta&amp;\zeta^2&amp;\zeta^3&amp;\zeta^4&amp;\zeta^5&amp;\zeta^6\\hline1&amp;0&amp;\zeta^3&amp;\zeta^6&amp;\zeta&amp;\zeta^5&amp;\zeta^4&amp;\zeta^2\\hline\zeta&amp;&amp;0&amp;\zeta^4&amp;1&amp;\zeta^3&amp;\zeta^6&amp;\zeta^5\\hline\zeta^2&amp;&amp;&amp;0&amp;\zeta^5&amp;\zeta&amp;\zeta^3&amp;1\\hline\zeta^3&amp;&amp;&amp;&amp;0&amp;\zeta^6&amp;\xi^2&amp;\zeta^4\\hline\zeta^4&amp;&amp;&amp;&amp;&amp;0&amp;1&amp;\xi^3\\hline\zeta^5&amp;&amp;&amp;&amp;&amp;&amp;0&amp;\zeta\\hline\zeta^6&amp;&amp;&amp;&amp;&amp;&amp;&amp;0\\hline\end{array}$</p>
</center>

<p>利用这个表，我们可以清楚的看到根和根之间的联系</p>
<center>

<p>$\zeta^2 +1 &#x3D; (\zeta+1)^2 &#x3D; (\zeta^3)^2 &#x3D; \zeta^6$</p>
</center>
<center>
$\zeta^4+1 =(\zeta^2+1)^2= (\zeta^6)^2 = \zeta^{12} = \zeta^5$ 

</center>

<p>以此类推可以得到其他元素。</p>
<h3 id="定义：里德-所罗门码"><a href="#定义：里德-所罗门码" class="headerlink" title="定义：里德-所罗门码"></a>定义：里德-所罗门码</h3><p>一个域$F_q$上的里德-所罗门码是由生成多项式</p>
<center>

<p>$g(x) &#x3D;(x-\zeta)(x-\zeta^2)\cdots(x-\zeta^{d-1})$</p>
</center>

<p>生成的$\mathrm{BCH}$码，其中$1&lt;d &lt; q-1 $，且$\zeta$是$F_q$中$q-1$次本原单位根。</p>
<h3 id="推论2"><a href="#推论2" class="headerlink" title="推论2"></a>推论2</h3><p>由上面的定义，这里存在一个可纠$t$个错，在$F_{2^{2t+1}}$上的$\mathrm{BCH}$码，且信息率是$1-[2t&#x2F;(2^{2t+1}-1)]$</p>
<p><strong>证明：</strong>设$\zeta$是$F_q$中的本原元素，其中$q &#x3D; 2^{2t+1}$，那么由$\mathrm{BCH}$码的定义，其长度为$q-1$，现在我们定义$g(x)$是</p>
<center>

<p>$g(x)&#x3D;(x-\zeta)(x-\zeta^{2})\cdots(x-\zeta^{2t})\in\mathbb{F}_{q}[x]. $</p>
</center>

<p>则由定理1，$g(x)\geq 2t+1$。那么现在，$\dim(g)&#x3D;2t$，$C$的长度为$q-1$，现在，我们只需要求出$C$的秩就可以得到信息率了。</p>
<p>由于$\deg(g)&#x3D;2t$，而$\dim(C) &#x3D; q-1-2t$，所以$\dim(C) &#x3D; 2^{2t+1}-1$。$C$是特别的线性码，他的生成矩阵$[I\mid B]$中$I$是满秩的，因此$\dim(C)$就是原码的长度，而码长$q-1$，因此信息率就是$m&#x2F;n &#x3D; \frac{q-1-2t}{q-1} &#x3D; 1-[2t&#x2F;(2^{2t+1}-1)]$</p>
<p>利用引理2和里德-所罗门码，我们构造一些例子</p>
<h3 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h3><p>在$F_7$中，$[3]$是一个$6$次本原单位根，用多项式</p>
<center>

<p>$g(x) &#x3D; (x-3)(x-3^2)(x-3^3)(x-3^4) &#x3D;4+2x+3x^2+6x^3+x^4$</p>
</center>

<p>为生成多项式的码$C$是$F_7$上可纠2个错的里德-所罗门码，那么$C$的一个生成矩阵是</p>
<center>

<p>$G&#x3D;\begin{bmatrix}4&amp;2&amp;3&amp;6&amp;1&amp;0\0&amp;4&amp;2&amp;3&amp;6&amp;1\end{bmatrix}.$</p>
</center>

<p>那么$C$就是行空间$\mathrm{Row}(G)$</p>
<center>

<p>$C &#x3D; {4a,2a+4b,3a+2b,6a+3b,a+6b,b}:a,b\in F_7$</p>
</center>


<h1 id="译码"><a href="#译码" class="headerlink" title="译码"></a>译码</h1><p>到目前为止，我们考虑了线性码及其编码函数，为了解码，我们必须考虑由传输功能引起的错误，因此解码功能必须能够覆盖这一错误。</p>
<h3 id="定义：错误向量"><a href="#定义：错误向量" class="headerlink" title="定义：错误向量"></a>定义：错误向量</h3><p>令$C\subseteq k^n$是一线性码，若$y\in k^n$且$c\in C$。错误向量指的是：</p>
<center>

<p>$\epsilon &#x3D; \epsilon(y,c) &#x3D; y-c$</p>
</center>

<p>当然，$\mathrm{wt}(\epsilon)$就是$y$和$c$中不相同的非零坐标个数。</p>
<p>向量空间$F^n_q$是一个加法交换群，$C$是一个子群，给定$y$，则所有错误向量$y-c$的总体就是陪集$y+C$，$c\in C$。在这层意思上谈论最近码字的时候就是在谈错误向量$\epsilon(y,c) &#x3D; y-c$在$y+C$中权最小的那个。也就是考虑形如$y-c$中$\delta(y,c) &#x3D; \mathrm{wt}(y-c)$。</p>
<h3 id="定义：陪集的头字"><a href="#定义：陪集的头字" class="headerlink" title="定义：陪集的头字"></a>定义：陪集的头字</h3><p>若$C\subseteq F^n_q$是线性$[n,m]$码，而$y+C$是$F^n_q$中的一个陪集，则陪集的头字指的是一个权最小的向量$e\in y+C$</p>
<h3 id="定义：和声"><a href="#定义：和声" class="headerlink" title="定义：和声"></a>定义：和声</h3><p>设$H$是一个线性$[n,m]$码$C\subseteq F^n_q$的检验矩阵，若$y\in F^n_q$，则它的和声指的是$S(y) &#x3D; yH^T$</p>
<p>$C$的检验矩阵$H$不必是唯一的，但和声$yH^T$却依赖$H$的选取，为对一个收到的字$y$进行译码，首先计算它的和声$S(y) &#x3D; yH^T$，接着计算陪集的头字$e_j$的合身$S(y) &#x3D; yH^T$，直到$S(e_j) &#x3D; S(y)$成立。但只有一个这样的陪集$e_j+C$成立，因为若$S(e_j)&#x3D;S(e_k)$，我们就有$S(e_j-e_k) &#x3D;0$,$e_j-e_k\in C$，从而得到$e_j+C &#x3D; e_k+C$。若$c &#x3D; y-e_j$是与$y$最接近的码字，则$y$译成$c$。但这种方法还是不太实用，因为$C$是$F_q$上的一个$[n,m]$分组码，则$C$存在$q^{n-m}$个陪集。</p>
<p>注：一般来说，我们在考虑向量$y &#x3D; (y_0,\cdots,y_{q-2})\in F_q^{q-1}$看做是多项式$y(x) &#x3D; y_0+y_1x+\cdots+y_{q-2}x^{q-2}\in F_q[x]$。</p>
<h3 id="命题7："><a href="#命题7：" class="headerlink" title="命题7："></a>命题7：</h3><p>设$\zeta$是$F_q$的本原元素，$C\subseteq F^{q-1}_q$是$F_q$上的一个纠$t$个错的里德-所罗门码，其生成多项式$g(x) &#x3D; (x-\zeta)(x-\zeta^2)\cdots(x-\zeta^{2t})$，定义$2t\times (q-1)$的矩阵</p>
<center>

<p>$\left.U&#x3D;\left[\begin{array}{ccccc}{1}&amp;{\xi}&amp;{\xi^{2}}&amp;{\cdots}&amp;{\xi^{q-2}}\{1}&amp;{\xi^{2}}&amp;{\xi^{4}}&amp;{\cdots}&amp;{\xi^{2(q-2)}}\{\vdots}&amp;{\vdots}&amp;{\vdots}&amp;{\vdots}&amp;{\vdots}\{1}&amp;{\xi^{2t}}&amp;{\xi^{4t}}&amp;{\cdots}&amp;{\xi^{2t(q-2)}}\end{array}\right.\right]$</p>
</center>

<ul>
<li>若$y &#x3D; (y_0,\cdots,y_{q-2})\in F^{q-1}_q$，则</li>
</ul>
<center>

<p>$yU^T &#x3D; (y(\zeta),y(\zeta^2_),\cdots,y(\zeta^{2t}))$</p>
</center>

<p>其中$y(\zeta^i) &#x3D; y_0+y_1\zeta^i+\cdots+y_{q-2}\zeta^{i(q-2)}$</p>
<ul>
<li>设$f(x) &#x3D; f_0+f_1x+\cdots + f_rx^r\in F_q[x]$，其中$r\leq t$，若我们记$f &#x3D; (f_0,\cdots,f_r,0,\cdots,0)\in F^{2t}_q$，则</li>
</ul>
<center>

<p>$fU &#x3D; (f(1),\zeta f(\zeta),\cdots,\zeta^{q-2}f(\zeta^{q-2})$</p>
</center>

<ul>
<li>U是$C$的一个检验矩阵</li>
<li>若$e &#x3D; y-c$是一个错误向量，则$e$和$y$有相同的和声</li>
</ul>
<center>

<p>$S(e) &#x3D; eU^T &#x3D; yU^T &#x3D; S(y)$</p>
</center>

<p>因此对所有的$j\leq 2t$，$e(\zeta^i) &#x3D; y(\zeta^i)$</p>
<p><strong>证明：</strong>注意到$U$上$F_q$上的一个矩阵，这是因为$\zeta\in F_q$，而$yU^T$的$ij$位元素是点积</p>
<center>

<p>$y\cdot \mathrm{ROW}<em>U(i) &#x3D; y_0+y_1\zeta^i+\cdots+y</em>{q-2}\zeta^{i(q-2)} &#x3D; y(\zeta^i)$</p>
</center>

<p>因此</p>
<center>

<p>$yU^T &#x3D; (y(\zeta),y(\zeta^2),\cdots,y(\zeta^{2t}))$</p>
</center>

<p><strong>证明2：</strong> $fU$的$ij$位元素是点积</p>
<center>

<p>$\begin{aligned}(f_{0},\cdots,f_{r},0,\cdots,0)\cdot\mathrm{COL}<em>{v}(j)&amp;&#x3D;(f</em>{0},\cdots,f_{r},0,\cdots,0)\cdot(\xi^{\prime},\xi^{\prime},\cdots,\xi^{2p})\&amp;&#x3D;f_{0}\xi^{i}+f_{1}\xi^{2j}+\cdots+f,\xi^{2p}\&amp;&#x3D;\xi^{i}(f_{0}+f_{1}\xi^{i}+\cdots+f_{r}\xi^{ir})\&amp;&#x3D;\xi^{i}f(\xi^{i}).\end{aligned}$</p>
</center>

<p><strong>证明3：</strong> 若$C\subseteq F_q^{q-1}$是一个以$g(x)$为生成多项式的循环码，那么$y &#x3D; (y_0,y_1,\cdots,y_{q-2})\in F_q^{q-1}$落在$C$中当且仅当$y(\eta) &#x3D; 0$，不难证明，$g(x)$生成$C$，$C$是一个主理想，是$k[x]&#x2F;I$中由$g(x)+I$生成的主理想，$I &#x3D; x^n-1$，$y\in C$则$y &#x3D; (g)$，存在$f(x)\in k[x]$满足$y(x)+I &#x3D; f(x)g(x)+I$，因此$y-fg\in I $。那有</p>
<center>

<p>$y(x) &#x3D; f(x)g(x)+(x^n-1)$</p>
</center>

<p>由于$\eta$是$g$的根，由命题5，$g(x)\mid (x^n-1)$，因此$\eta^n &#x3D;1$我们有$y(\eta) &#x3D; 0$</p>
<p>其中$\eta$是$g(x)$的根。因此，若$U$是检验矩阵，就有$yU^T &#x3D; 0$，事实上也确实如此。所以$U$是检验矩阵。</p>
<p><strong>证明4：</strong>最后，$eU^T &#x3D; (y-c)U^T &#x3D; yU^T-cU^T &#x3D; yU^T$。</p>
<p>设$C$是$F_q$上的一个纠t个错的里德-所罗门码，$U$是上述命题中的检验矩阵，通过求错误向量$e &#x3D; y-c$来译接收到的字$y$，其中最困难的一步是确定$e$的非零坐标的位置。反正，若$C$是二进制码，则$e$的非零坐标实际上决定了e</p>
<p>若$A&#x3D;[a_{ij}],B&#x3D;[b_{ij}]$是域$k$上的$m\times n$矩阵，则他们的阿马达积是$A\circ B &#x3D; [a_{ij}b_{ij}]$，特别的，$1\times n$向量的阿达马积被定义为</p>
<center>

<p>$[a_1,\cdots,a_n]\circ [b_1,\cdots,b_n] &#x3D; [a_1b_1,\cdots,a_nb_n]$</p>
</center>

<h3 id="定义：错误定位向量"><a href="#定义：错误定位向量" class="headerlink" title="定义：错误定位向量"></a>定义：错误定位向量</h3><p>若$e$是错误向量，则$e\circ u &#x3D; 0$的非零向量称为错误定位向量。</p>
<h3 id="引理5"><a href="#引理5" class="headerlink" title="引理5"></a>引理5</h3><p>若$e&#x3D; (e_0,\cdots,e_{q-2})$和$u&#x3D;(u_0,\cdots,u_{q-2})$都在$F^{q-1}_q$中，则$e\circ u &#x3D; (0,\cdots,0)$可推出</p>
<center>

<p>${j:e_j\neq 0} &#x3D; \mathrm{Supp}(e) \subseteq Z(u) &#x3D; {j:u_j &#x3D;0}$</p>
</center>

<p><strong>证明：</strong>设$e\circ u&#x3D; 0$对所有$j$都得到$e_ju_j&#x3D;0$，若$j\in \mathrm{Supp}(e)$，则$e_j \neq 0$，但$e_ju_j &#x3D;0$，其中元素在域中，那么就有$u_j &#x3D; 0$，所以$j\in Z(u)$</p>
<h3 id="定义：错误定位多项式"><a href="#定义：错误定位多项式" class="headerlink" title="定义：错误定位多项式"></a>定义：错误定位多项式</h3><p>设$C$是$F_q$上的一个可纠$t$个错的里德-所罗门码，设$y$是接收到的字，设$e &#x3D; y-c &#x3D; (e_0,\cdots,e_{q-2})$是错误向量，若$\mathrm{wt}\leq t$且$\mathrm{Supp}(e) \leq t$，且$\mathrm{Supp(e)} &#x3D; {j_1,\cdots,j_r}$，其中$r\leq t$，则 <strong>错误多项式</strong>指的是</p>
<center>

<p>$f(x) &#x3D; (x-\zeta^{i_1})(x-\zeta^{i_2})\cdots(x-\zeta^{i_r} ) &#x3D; f_0+f_1x+\cdots+f_{r-1}x^{r-1}+f_rx^r$</p>
</center>

<p>我们记$f_r &#x3D; 1$，把多项式变成$f &#x3D; (f_0,f_1,\cdots,r_{r-1},1,0,\cdots,0) \in F_q^{2t}$。（因此我们就可以定义$fU$了，其中U是检验矩阵）</p>
<h3 id="引理6"><a href="#引理6" class="headerlink" title="引理6"></a>引理6</h3><p>设$C$是$F_q$上一个纠$t$个错的里德-所罗门码，设$U$是命题7中的检验矩阵，如果$y$是一个接收到的字，$e &#x3D; y-c &#x3D; (e_0,\cdots,e_{q-2})$是一个满足$\mathrm{wt}(e)\leq t$的错误向量，若$fU &#x3D; (f(1),\zeta f(\zeta),\cdots,\zeta^{q-2} f(\zeta^{q-2}))$，其中$f &#x3D; (f_0,f_1,\cdots,f_{r-1},1,0,\cdots,0)\in F^{2t}_q$是错误定位多项式，则$U$是一个错误定位向量且</p>
<center>

<p>$\mathrm{Supp}(e) &#x3D; Z(u)$</p>
</center>

<p><strong>证明：</strong>设$\mathrm{Supp}(e) &#x3D; {j_1,\cdots,j_r}$，其中$r\leq t$，设$f(x) &#x3D; \sum^r_{i&#x3D;1}f_ix^i$是错误定位多项式，为了证明$U$是错误定位向量，我们断言有$e\circ u &#x3D; 0$，若$j_v\in \mathrm{Supp}(e)$，则由引理5，有$f(\zeta^{j_v}) &#x3D;0$，进而有$e_{j_v} u_{j_v} &#x3D; 0$，若$j_v\not\in\mathrm{Supp}(e)$，则$e_j &#x3D;0$，所以$e\circ u &#x3D; 0$。我们有$u$是错误定位向量。由引理5可知$\mathrm{Supp}(e) \subseteq Z(u)$。</p>
<p>若$u_j&#x3D; 0$，但对某个$j\not\in {j_1,\cdots,j_r}$得到$\zeta^j f(\zeta^j) &#x3D; 0$，进一步有$f(\zeta^j)&#x3D;0$，我们就发现了另一个根，但多项式的次数$r\leq t$，这是一个矛盾，我们得到了r+1个根，所以这不可能是一个真包含的关系，有$\mathrm{Supp}(e) &#x3D;  Z(u)$</p>
<h3 id="定义：和声矩阵"><a href="#定义：和声矩阵" class="headerlink" title="定义：和声矩阵"></a>定义：和声矩阵</h3><p>设$C$是$F_q$上一个能纠$t$个错的里德-所罗门码，设$\zeta$是一个$F_q$的本原根，$y &#x3D; (y_0,\cdots,y_{q-2})\in F^{q-1}_q$，$e&#x3D;y-c$是一个满足$\mathrm{wt}(e) &#x3D; r\leq t$的错误向量，则和声矩阵指的是$r\times r$矩阵</p>
<center>

<p>$\sum(y)&#x3D;\begin{bmatrix}y(\xi)&amp;y(\xi^2)&amp;\cdots&amp;y(\xi^r)\y(\xi^2)&amp;y(\xi^3)&amp;\cdots&amp;y(\xi^{r+1})\\vdots&amp;\vdots&amp;\cdots&amp;\vdots\y(\xi^r)&amp;y(\xi^{r+1})&amp;\cdots&amp;y(\xi^{2r-1})\end{bmatrix}$</p>
</center>

<h3 id="命题8"><a href="#命题8" class="headerlink" title="命题8"></a>命题8</h3><p>设$C$是$F_q$上一个纠$t$个错的里德-所罗门码，$y &#x3D; (y_0,y_1,\cdots,y_{q-2})\in F_q^{q-1}$，$e &#x3D; y-c$是一个满足$\mathrm{wt}(e) &#x3D; r\leq t$的错误向量，那么</p>
<ul>
<li><p>$e$和$y$具有相同的和声矩阵，$\sum(e) &#x3D; \sum(y)$</p>
</li>
<li><p>若$f(x) &#x3D; f_0+f_1x+\cdots+f_{r-1}x^{r-1} +x^r$是错误多项式，则</p>
</li>
</ul>
<center>

<p>$f  &#x3D; (f_0,f_1,\cdots,f_{r-1})\in F_q^r$</p>
</center>

<p>是线性方程组</p>
<center>

<p>$\sum(y)f^T &#x3D; h^T$</p>
</center>

<p>的一个解，其中$h&#x3D;[-y(\xi^{r+1}),-y(\xi^{r+2}),\cdots,-y(\xi^{2r})]$</p>
<ul>
<li><p>和声矩阵$\sum(y)$是非奇异的</p>
<p><strong>证明</strong> 利用命题7的三，我们知道$e$和$y$的和声是一样的，再由二，对所有$j&lt; 2t$，有$e(\zeta^j) &#x3D; y(\zeta^i)$，因此$\sum(e) &#x3D; \sum(y)$</p>
<p><strong>证明2：</strong> 对$v &#x3D; 1,2,\cdots,r$，每一个$\zeta^{ij_v}$是错误多项式$f(x)$的一个根，则$f(\zeta^{ij_v}) &#x3D; 0$是一定的，现在，对每个$i &#x3D; 1,2,\cdots,r $，我们用$\zeta^{ij_v}$乘在方程中，展开则有</p>
<center>

<p>$f_0\zeta^{ij_v}+f_1\zeta^{(i+1)j_v}+\cdots+\zeta^{(i+r)j_v} &#x3D; 0$</p>
</center>

<p>其次，我们回忆$e(x) &#x3D; e_{j_1}x^{j_1} + \cdots + e_{j_r}x^{j_r}$，我们将$v &#x3D; 1,2,\cdots,r$的方程连加，就得到</p>
</li>
</ul>
<center>

<p>  $f_{0}e(\xi^{i})+f_1e(\xi^{i+1})+\cdots+f_{r-1}e(\xi^{i+r-1})+\xi^{i+r}&#x3D;0.$</p>
</center>

<p>现在，这是$i&#x3D;1,2,\cdots,r$中的一条方程，只需要吧这r条方程联立起来，那么他就是我们要求的方程，而这$r$个方程构成一个非奇次$r\times r$的线性方程组</p>
<center>

<p>$\sum(e)f^T &#x3D; h^T$</p>
</center>

<p>其中$h &#x3D; [-y(\zeta^{r+1}),\cdots,-y(\zeta^{2r})]^T$。由命题1，有$\sum(e) &#x3D; \sum(y)$，那么命题得证。</p>
<hr>
<p>最后，命题8可以求出错误向量$e$的错误位置$j_1,\cdots,j_r$，而通过解线性方程组$\sum(y)f^T &#x3D;h^T$可以求出错误定位多项式$f(x)$，其唯一性由和声矩阵的非奇异性保证。$f &#x3D; (f_0,f_1,\cdots,f_{r-1})$，那么$f(x)&#x3D;f_0+f_1x+\cdots+f_{r-1}x^{r-1}+x^r$。首一多项式$f(x)$确定错误定位向量$u &#x3D; fU$，其中$U$是命题7的检验矩阵。而${j_1,\cdots,j_r} \mathrm{Supp}(e)&#x3D;Z(u)$。要译码$y$，只需要去掉元素$y_{j_1},\cdots,y_{j_r}$，将这些错误元素替换为真实值即可。现在我们给出一个例子，他可以译里德-所罗门码，还可以推广到所有$BCH$码上。</p>
<h3 id="定理1"><a href="#定理1" class="headerlink" title="定理1"></a>定理1</h3><p>设$C$是$F_q$上一个可纠$t$个错的里德-所罗门码，$y$是一个字，存在一个满足$\mathrm{wt}(e)\leq t$的错误向量$e$，则$y$可以被有效译码。</p>
<p><strong>证明：</strong>这很简单，只要错误的地方少于我们给出修正的地方，那么我们就能修正，利用命题8，我们求出错误向量$e$不为零的位置$j_1,\cdots,j_r$，由于$\mathrm{Supp}(e) &#x3D; Z(fU)$，其中$U$是检验矩阵。</p>
<p>我们设$r &#x3D; t$，设$U^*$是去除$j_1,\cdots,j_r$行外的其他行得到的矩阵。</p>
<p>现在引入如下命题：</p>
<hr>
<p>设$Ax &#x3D; b$是域$k$上的一个$m\times n$的矩阵，试证明存在一个满足$x_{j_1} &#x3D; 0 &#x3D; x_{j_2} &#x3D; \cdots &#x3D; x_{j_s}$的解$x &#x3D; (x_1,\cdots,x_n)$当且仅当$m\times (n-s)$方程组$A^*x^* &#x3D; b$有解，其中$s\leq n$，$A^*$是从$A$中删掉第$j_1,j_2,\cdots,j_s$列后得到的矩阵。</p>
<hr>
<p>回到证明上来，我们可以通过解$U^*e^* &#x3D; Uy^T$求出$e$的非零坐标。我们约定一下符号：$e^*$表示$1\times t$向量$(e_{j_1},\cdots,e_{j_t})$。由上引入的习题，我们知道更小的非奇次线性方程是可解的，只需要用高斯消元法。现在若$\mathrm{rank}(U^*)&#x3D; t$，那么$U$的任意$t$行就构成一个非奇异的$t\times t$的范德蒙矩阵。而且其行是不同的，所以$U$的任意$t$行构成一线性无关的表，那么只要有$e^*$，我们就能得到$e$。注意，求出来的是非零值，其他地方补上0即可。那么我们就能以此得到一个码字$c &#x3D; y-e$，并且$c$是唯一的，我们吧$y$译为$E^{-1}(c)$，其中$E$是编码函数。</p>
<h3 id="例子-4"><a href="#例子-4" class="headerlink" title="例子"></a>例子</h3><p>我们设$C$是$F_7$上一个纠2个错的里德-所罗门码。$3$是其中$6$次本原单位根：</p>
<center>

<p>$3^2 &#x3D; 9 \equiv 2$，$3^3 &#x3D; 27\equiv 6$，$3^4 &#x3D; 81\equiv 4$，$3^5&#x3D;243\equiv 5$，$3^6\equiv 1$</p>
</center>

<p>那么$t &#x3D; 2,q&#x3D;7$，它的检验性矩阵是下列的$4\times 7$矩阵</p>
<center>

<p>$U&#x3D;\begin{bmatrix}1&amp;3&amp;2&amp;6&amp;4&amp;5\1&amp;2&amp;4&amp;1&amp;2&amp;4\1&amp;6&amp;1&amp;6&amp;1&amp;6\1&amp;4&amp;2&amp;1&amp;4&amp;2\end{bmatrix}.$</p>
</center>

<p>设存在一个满足$\mathrm{wt}(e)\leq 2$的错误向量$e$，我们来译字$y &#x3D; (4,0,5,1,0,1)$</p>
<ul>
<li>和声$S(y) &#x3D; yU^T &#x3D; (4,1,0,3)$</li>
<li>和声矩阵是$2\times 2$矩阵，它的元素由$y\cdot U^T &#x3D; (y(\zeta),y(\zeta^2),\cdots,y(\zeta^{2t}))$</li>
</ul>
<p>现在，$t&#x3D;2$，我们只需要计算$y(\zeta),y(\zeta^2),y(\zeta^3)$，即可，那么和声矩阵就是</p>
<center>

<p>$\sum(y) &#x3D; \left( \begin{matrix}<br>    4<em>1+5</em>2+6+5&amp;		4<em>1+5</em>4+1+4\<br>    4<em>1+5</em>4+1+4&amp;		4<em>1+5</em>1+6+6\<br>\end{matrix} \right) \ &#x3D;\ \left( \begin{matrix}<br>    4&amp;		1\<br>    1&amp;		0\<br>\end{matrix} \right) $</p>
</center>

<ul>
<li>现在，解$\sum(y)f^T - h^T$，$h^T &#x3D; (0,4)^T$，就有$f &#x3D; (4,5)$，错误多项式为$f(x) &#x3D; 4+5x+x^2$</li>
</ul>
<p>然后计算$u &#x3D; fU &#x3D; (3,0,1,0,6,4)$，那么$Z(u) &#x3D; {1,3}$，所以$\mathrm{Supp}(e) &#x3D; {1,3}$，即错误向量的非零位置在1和3，现在我们求这两个数字</p>
<p>解$U^*e^* &#x3D; Uy^T$</p>
<center>

<p>$\begin{bmatrix}3&amp;6\[0.3em]2&amp;1\[0.3em]6&amp;6\[0.3em]4&amp;1\end{bmatrix}\begin{bmatrix}e_1\[0.3em]e_2\end{bmatrix}&#x3D;\begin{bmatrix}4\1\[0.3em]0\3\end{bmatrix}.$</p>
</center>

<p>那么$e^* &#x3D; (1,6)$，错误向量就是$e&#x3D;(0,1,0,6,0,0)$，最后$y$就是</p>
<center>

<p>$\begin{aligned}<br>\text{C}&amp; &#x3D;y-e  \<br>&amp;\text{&#x3D;} &#x3D;(4,0,5,1,0,1)-(0,1,0,6,0,0)  \<br>&amp;&#x3D;(4,-6,5,2,0,1) \<br>&amp;&#x3D;(4,1,5,2,0,1)<br>\end{aligned}$</p>
</center>

<p>被译为$E^{-1}(c)$，$E$是编码函数。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://monstergeo.github.io/btest/2024/01/29/Code/" data-id="cmlgrfven00026whxa81d4kys" data-title="Code" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/math/" rel="tag">math</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-ocr" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/11/26/ocr/" class="article-date">
  <time class="dt-published" datetime="2023-11-26T06:17:15.000Z" itemprop="datePublished">2023-11-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/11/26/ocr/">ocr</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>这节我们来讲OCR识别是怎么实现的并附带一个例子</p>
<p>#基础知识</p>
<p>实现简单的OCR算法只需要简单的一些东西：</p>
<ul>
<li>良好的线性代数基础</li>
<li>良好的概率论基础</li>
<li>opencv库的函数使用</li>
<li>tesseract的使用</li>
</ul>
<p>##环境安装</p>
<p>我们的代码是用python实现的，为此需要安装一些东西，首先是opencv库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install opencv-python</span><br></pre></td></tr></table></figure>

<p>安装完后在解释器中输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import cv2</span><br></pre></td></tr></table></figure>

<p>如果没有报错就是成功安装了。我们安装opencv库的主要原因是要对图形做处理。</p>
<p>其次是tesseract的安装。在<a target="_blank" rel="noopener" href="https://tesseract-ocr.github.io/tessdoc/Installation.html">官网</a>按照引导下载即可。记得安装完配置环境变量。然后安装对应的python包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pytesseract</span><br></pre></td></tr></table></figure>

<p>现在，准备工作做好之后，就让我们开始下一步。</p>
<p>这次用的是别人的代码和图片，首先我们准备这么一张图</p>
<img src ="https://www.z4a.net/images/2023/11/26/155f6bc15a358eb0e.png" width = 400 height = 650>

<p>现在，为了识别小票的内容，我们需要做几件事情，第一步，检测小票的位置并识别其边缘在哪里，第二步，找出到底我们要检测的边缘在哪。第三步，把小票变换位置到能直接检测。</p>
<p>###边缘检测</p>
<ul>
<li>第一步，我们先读取图像。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import cv2 as cv</span><br><span class="line">#读取输入</span><br><span class="line">img = cv.imread(&#x27;picture/pic.png&#x27;)</span><br><span class="line">定义一个比率</span><br><span class="line">ratio = img.shape[0] / 400.0</span><br><span class="line">orig = img.copy() #复制一个未处理的图像</span><br></pre></td></tr></table></figure>

<ul>
<li>第二步，处理图像</li>
</ul>
<p>我们来对图像进行预处理工作，为了更好的识别，图片的原尺寸是2448 x 3264的大小，我们对其进行缩小以便做边缘检测。所以，我们要做如下的步骤</p>
<ul>
<li>用函数resize()用来计算输出宽度和高度</li>
<li>对图像进行灰度处理，我们运用cvtColor函数</li>
<li>对图像进行滤波作用去除噪点。</li>
</ul>
<p>首先是第一步，比例缩放，为了缩小，我们用到INTER_AREA()来缩小图像。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def resize(image, width = None, height = None, inter=cv.INTER_AREA):</span><br><span class="line">   dim = None</span><br><span class="line">   (h,w) = image.shape[:2]</span><br><span class="line">   if width is None and height is None:</span><br><span class="line">      return image</span><br><span class="line">   if width is None:</span><br><span class="line">      r = height / float(h)</span><br><span class="line">      dim = (width,int(h*r))</span><br><span class="line">   else:</span><br><span class="line">      r = width / fload(w)</span><br><span class="line">      dim = (width, int(h*r))</span><br><span class="line">   resized = cv.resize(image,dim, interpolation = inter)</span><br><span class="line">   return resized</span><br></pre></td></tr></table></figure>
<p>然后我们只需要轻轻的调用一下就行了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image = resize(orig, height=500)</span><br></pre></td></tr></table></figure>

<p>接下来我们进行灰度处理，这是识别最常用的方法，利用cvtColor函数，我们可以把图像映射到灰度空间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gray = cv.cvtColor(image, cv.COLOR_BGR2GRAY)</span><br></pre></td></tr></table></figure>

<p>然后是使用高斯滤波去除噪音</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bimg = cv.GaussianBlur(gray, (5,5), 0)</span><br></pre></td></tr></table></figure>
<p>其中(5,5)指的是卷积核大小。这里我们实现的是高斯滤波的一种方法，离散化窗口滑窗卷积，另外一种是傅里叶变换。</p>
<p>我们假设读者有一般的概率论基础（知道方差，标准差，期望和概率分布等等知识及其意义。）</p>
<p>高斯滤波的主要原理是，通过高斯函数进行函数的平滑化处理。</p>
<p>当我们要对一个图像模糊的时候，首先注意的是什么是模糊？一个图像可以表示为一个矩阵$A$，矩阵的元素是一些取值不大于255的值，所谓的模糊就是对矩阵进行分块，得到一系列的分块矩阵$A &#x3D; \bigcup A_i$，再取分块的中心分别计算周遭的平均值再替换。这样子的好处是把图像变得更平滑。但这会导致一个问题，既然每个点都是取周遭的平均值，那么该怎么取呢。为此我们引入权重的概念。对于正态分布，有一个比较关注的点就是标准差，我们都知道正态分布的中心点正负三个标准差已经包含了几乎全部的信息。对高斯模糊，我们的重点也是离“中心点”越近的点取值就越高，反之越小。</p>
<p>现在，我们给定一组一维的像素值</p>
<table>
<thead>
<tr>
<th align="left">相对坐标</th>
<th align="center">-1</th>
<th align="center">0</th>
<th align="center">1</th>
</tr>
</thead>
<tbody><tr>
<td align="left">具体像素值</td>
<td align="center">120</td>
<td align="center">230</td>
<td align="center">124</td>
</tr>
</tbody></table>
<p>为了计算它们的权重，现在引入高斯函数（一维）</p>
<center>

<p>$f(x) &#x3D;\frac{1}{\sigma\sqrt{2\pi}}e^{\frac{-x^2}{2\sigma^2}} $</p>
</center>

<p>给定一个方差$\sigma &#x3D; 1.5$，我们现在开始计算权重，带入$-1,0,1$到$f(x)$中分别得到$0.212965， 0.265962，0.212965$三个不同的值。然后加起来得到$0.691892$。为了得到权重，我们需要用得到的三个不同值去除以它们的和。就可以得到</p>
<table>
<thead>
<tr>
<th align="left">相对坐标</th>
<th align="center">-1</th>
<th align="center">0</th>
<th align="center">1</th>
</tr>
</thead>
<tbody><tr>
<td align="left">权重</td>
<td align="center">0.307801</td>
<td align="center">0.384398</td>
<td align="center">0.307801</td>
</tr>
</tbody></table>
<p>然后我们就可以计算中心点的平均值了，利用权重有</p>
<center>

<p>平均值 &#x3D; $120<em>0.307801 + 230</em>0.384398+ 124*0.307801 &#x3D; 163.514984$</p>
</center>

<p>处理过后的像素值就接近了左右两边的值，这就是我们说的平滑化。</p>
<p>现在我们拓展到二维的情况，它的函数如下</p>
<center>

<p>$G(x,y) &#x3D; \frac{1}{2\pi\sigma^2}e^{-\frac{x^2+y^2}{2\sigma^2}}$</p>
</center>

<p>它有一个非常好的性质，即：</p>
<center>

<p>$\begin{aligned}<br>    G(x,y) &#x3D;&amp; \frac{1}{2\pi\sigma^2}e^{-\frac{x^2+y^2}{2\sigma^2}}\<br>    &#x3D;&amp;\frac{1}{2\pi\sigma^2}e^{-\frac{x^2}{-2\sigma^2} - \frac{y^2}{2\sigma^2}}\<br>    &#x3D;&amp;G(x) \times G(y)<br>\end{aligned}$</p>
</center>

<p>这说明在使用高斯模糊的时候，我们可以把一个二维矩阵做降维处理。</p>
<hr>
<p>接下来让我们继续代码，使用Canny函数进行轮廓检测。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edged = cv.Canny(bimg, 75, 200)</span><br></pre></td></tr></table></figure>
<p>这是在说，对像素值高于200和低于75的值做双向检测。然后我们就可以得到输出有：</p>
<p><img src="https://www.z4a.net/images/2023/11/26/imagecbb46e699ab25281.png" alt="im2"></p>
<p>那么第一步就到此结束了。</p>
<p>由于图形不是平铺在平面上的，需要做点变换，那么如何变呢？一个问题是计算机如何识别边界。当识别到边界之后，我们才可以把这种歪歪斜斜的要识别的地方给摆正。才能做识别。所以，第二步，轮廓检测</p>
<p>###轮廓检测</p>
<p>为了找出轮廓，我们从图中看到的东西有：有很多小圈圈，一个最大的矩形。而我们要找的轮廓就是哪个最大的矩形。</p>
<p>思路如下：我们遍历每个轮廓的面积，做排序，然后选出面积大小排前五的。首先，为了找出轮廓，我们用到 findContours函数，我们做如下解释：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">findContours(image, mode ,method)</span><br><span class="line"></span><br><span class="line">第一个参数是输入图像，第二个是轮廓的模式，第三个是近似轮廓的方法</span><br><span class="line"></span><br><span class="line">mode有4种不同的模式，我们主要用到两种，一是cv2.RETR_LIST，用它检测的轮廓不具备等级关系，且</span><br><span class="line">返回全部的轮廓而另一种cv2.RETR_CCOMP是建立两个等级的轮廓，类似的说，就是把轮廓分为内外两个</span><br><span class="line">表示。但这里不需要用到，我们另外在做解释。</span><br><span class="line"></span><br><span class="line">method参数决定了我们如何表达轮廓，我们对下述两种参数做描述。</span><br><span class="line"></span><br><span class="line">+ cv2.CHAIN_APPROX_NONE: 储存所有点，相邻两个点位置不超过1，</span><br><span class="line">即 abx(xi-xj) &lt; max(abs(xs -xt))</span><br><span class="line"></span><br><span class="line">+ cv2.CHAIN_APPROX_SIMPLE：压缩水平、垂直、对角线方向的元素并保留该方向的终点坐标，即只留下</span><br><span class="line">特征信息（矩形保留四个顶点）来储存轮廓信息。</span><br></pre></td></tr></table></figure>
<p>所以，我们先来做轮廓检测，我们使用RETR_LIST和SIMPLE参数，代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cts = cv.findContours(edged.copy(), cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE)[1]</span><br></pre></td></tr></table></figure>

<p>然后我们对面积的大小排序并取出前五个储存备用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcts = sorted(cts, key = cv.contoursArea, reverse =True)[:5]</span><br></pre></td></tr></table></figure>
<p>现在我们编写一个遍历轮廓的循环</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">for c in cts:</span><br><span class="line">   peri = cv.arcLength(c,True) #获取轮廓长度</span><br><span class="line">   approx = cv.approxPolyDP(c, 0.02*peri, True) #计算轮廓的近似</span><br><span class="line"></span><br><span class="line">   if len(approx)  == 4:</span><br><span class="line">      screenCts = approx</span><br><span class="line">      break</span><br><span class="line">   #由于取的是矩形，当点的数量是4的时候取出即可。</span><br><span class="line"></span><br><span class="line">   cv.DrawContouts(img,[screenCts], -1 ,(0,0,255), 2 )</span><br><span class="line">   # -1表示取出全部点，然后是线的颜色，最后是线的宽度</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p><img src="https://www.z4a.net/images/2023/11/27/imageecc24d714ebde607.png" alt="image"></p>
<p>###投影变换</p>
<p>接下来的解释我希望读者有一些线性代数的基础以便我讲解。</p>
<p>提到线性代数的时候我们应该立马就想到线性空间$V$，$V$上的一个矩阵可以通过一些操作变成另一个矩阵，这种方法我们称为线性变换。</p>
<p>一个线性变换$A$指的是对任意$V$中的元素$\alpha,\beta$和数域$P$上的任意$k$满足</p>
<ul>
<li>$A(\alpha+\beta) &#x3D; A\alpha+A\beta$</li>
<li>$A(k\alpha) &#x3D; kA(\alpha)$</li>
</ul>
<p>它带有一些性质：</p>
<ul>
<li>$A(0) &#x3D; 0, A(-\alpha) &#x3D; -A(\alpha)$</li>
</ul>
<p>线性变换和矩阵的关系很近，当我们确定空间中的一组基时，我们可以通过一组基去确定一个$V$中的向量$\alpha$。在同一个空间中，你可以通过变换把$\alpha$从一个位置移到另一个位置得到向量$\beta$，这说明向量$\alpha$的每个分量$a_i$都会改变，而这种改变和原来的$\alpha$有一定关系，这种关系可以表示为一个变换$A$作用在$\alpha$得到向量$\beta$，而$A$可以看作是一个矩阵乘在$\alpha$上起了作用。</p>
<p>举几个简单的例子，取两个向量$\alpha &#x3D; (0,1)’$和$\beta &#x3D; (1,0)’$围起来则得到一个在第一象限的正方形，现在我们给出一些线性变换。来看看作用在两个向量上会得到什么。</p>
<p>我们把$\alpha$和$\beta$分别乘矩阵，得到新的向量，它在平面上表示为下面的样子：</p>
<p><img src="https://www.z4a.net/images/2023/11/27/diagram-20231127.png" alt="2"></p>
<p>看，我们就把原来的矩阵给翻转到下面了。所以，这也是为什么我们研究线性变换的目的，我们可以把原来歪歪扭扭的小票给识别出来，然后通过线性变换给放大、缩小、调整位置到软件容易识别。但用什么样的矩阵可以做到我们想要的结果。</p>
<p>为了完成变换的操作，我们需要四个输入的坐标和四个输出坐标，我们需要选择图像中四个我们需要的点（顶点）。我们应该确保选择的点是定义良好的，原始图像和目标图像有明确的对应关系，然后通过高度和宽度计算出小票在图像上的四个控制点。</p>
<p>另一个问题是矩阵的问题，我们知道一个变换可以通过一个矩阵的实现，那么我们如何寻找这种矩阵呢？opencv给我们提供了一个函数cv2.getPerspectiveTransform来得到这个变换矩阵。现在我们看看如何实现代码。</p>
<p>定义一些函数来获取座标</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def order_points(pts):</span><br><span class="line">   rect = np.zeros((4,2),dtype = &quot;float32&quot;)</span><br><span class="line">   #定义一个4x2的矩阵用来存储元素，类型为float32</span><br><span class="line"></span><br><span class="line">   s = pts.sum(axis = 1)</span><br><span class="line">   #把矩阵的每行加起来得到新的向量</span><br><span class="line"></span><br><span class="line">   #开始找顶点，利用argmax和argminx函数找出列中最小元素</span><br><span class="line">   #计算左上和右下的顶点</span><br><span class="line">   rect[0] = pts[np.argmin(s)]</span><br><span class="line">   rect[2] = pts[np.argmax(s)]</span><br><span class="line"></span><br><span class="line">   #计算右上和左下的顶点</span><br><span class="line"></span><br><span class="line">   diff = np.diff(pts,axis =1)</span><br><span class="line">   rect[1] = pts[np.argmin(diff)]</span><br><span class="line">   rect[3] = pts[np.argmax(diff)]</span><br><span class="line"></span><br><span class="line">   return rect</span><br></pre></td></tr></table></figure>

<p>然后我们定义一个变换函数计算变换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">def transform(image, pts):</span><br><span class="line">   rect = order_point(pts)</span><br><span class="line">   (tl,tr,br,bl) = rect #把4个2维向量赋值给四元组。</span><br><span class="line"></span><br><span class="line">   #计算距离</span><br><span class="line">    widthA = np.sqrt(((br[0]-bl[0]) ** 2) + ((br[1]-bl[1]) ** 2))</span><br><span class="line">    widthB = np.sqrt(((tr[0]-tl[0]) ** 2) + ((tr[1]-tl[1]) ** 2))</span><br><span class="line">    maxwidth = max(int(widthA),int(widthB))</span><br><span class="line"></span><br><span class="line">    heightA = np.sqrt(((tr[0]-br[0]) ** 2) + ((tr[1]-br[1]) ** 2))</span><br><span class="line">    heightB = np.sqrt(((tl[0]-bl[0]) ** 2) + ((tl[1]-bl[1]) ** 2))</span><br><span class="line"></span><br><span class="line">    maxHeight = max(int(heightA),int(heightB))</span><br><span class="line"></span><br><span class="line">    #定义变换后想要的坐标</span><br><span class="line">    dst = np.array([</span><br><span class="line">      [0,0],</span><br><span class="line">      [maxwidth -1 ,0]</span><br><span class="line">      [maxwidth -1, maxHeight -1],</span><br><span class="line">      [0,maxHeight -1],]dtype=&quot;float32&quot;</span><br><span class="line">    )</span><br><span class="line">    #有了两个向量，现在我们可以来计算矩阵，利用函数</span><br><span class="line">    M = cv.getPerspectiveTransform(rect,dst)</span><br><span class="line"></span><br><span class="line">    #进行图片的变换操作</span><br><span class="line">    warped = cv.warpPerspective(image,M, (maxwidth, maxHeight))</span><br><span class="line"></span><br><span class="line">    return warped</span><br></pre></td></tr></table></figure>

<p>接着我们就可以做变换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">warped = transform(orig, screenCts.reshape(4,2) * ratio)</span><br><span class="line">#变回原比例。</span><br><span class="line"></span><br><span class="line">#二值化</span><br><span class="line"></span><br><span class="line">warped = cv.cvtColor(warped, cv.COLOR_BGR2GRAY)</span><br><span class="line">ref = cv.threshold(warped, 100,255, cv.THRESH_BINARY)[1]</span><br><span class="line">cv.imwrite(&#x27;scan.jpg&#x27;,ref)</span><br><span class="line"></span><br><span class="line">#输出</span><br><span class="line">cv.imshow(&quot;put&quot;,resize(ref,height = 650))</span><br></pre></td></tr></table></figure>

<p>结果就是<br><img src="https://www.z4a.net/images/2023/11/27/image75ea604c1295cfc1.png" alt="imag"></p>
<p>接下来就是识别的代码编写了，我们的前期任务已完成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line">import pytesseract</span><br><span class="line">import cv2 as cv</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">#读取图片</span><br><span class="line">image = cv.imread(&#x27;scan.jpg的图片路径&#x27;)</span><br><span class="line"></span><br><span class="line">#灰度&amp;二值化处理</span><br><span class="line"></span><br><span class="line">gray = cv.cvtColor(image,cv.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line">gray = cv.threshold(gray,0,255,cv.THRESH_BINARY | cv.THRESH_OTSU)[1]</span><br><span class="line"></span><br><span class="line">fn = &quot;&#123;&#125;.png&quot;.format(os.getpid())</span><br><span class="line"></span><br><span class="line">cv.imwrite(fn, gray)</span><br><span class="line"></span><br><span class="line">#识别和提取字符</span><br><span class="line"></span><br><span class="line">text = pytesseract.image_to_string(Image.open(fn))</span><br><span class="line">print(text)</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">x * KK K KK K K K KK OK</span><br><span class="line"></span><br><span class="line">WHOLE.</span><br><span class="line">FOODS</span><br><span class="line">TM AR KE T)</span><br><span class="line"></span><br><span class="line">WHOLE FOODS MARKET - WESTPORT, CT 06880</span><br><span class="line">399 POST RD WEST - (203) 227-6858</span><br><span class="line"></span><br><span class="line">BEEF GRND</span><br><span class="line"></span><br><span class="line">36%</span><br><span class="line">365</span><br><span class="line">365</span><br><span class="line">365</span><br><span class="line"></span><br><span class="line">BACON LS</span><br><span class="line">BACON LS</span><br><span class="line">BACON LS</span><br><span class="line">BACUN LS</span><br><span class="line"></span><br><span class="line">BROTH CHIC</span><br><span class="line">FLOUR ALMUND</span><br><span class="line">CHKN BRST BNLSS SK</span><br><span class="line">HEAVY CREAM</span><br><span class="line">BALSMC REDUCT</span><br><span class="line"></span><br><span class="line">85/15</span><br><span class="line"></span><br><span class="line">JUICE COF CASHEW ©</span><br><span class="line">DOCS PINT ORGANIC</span><br><span class="line">HNY ALMOND BUTTER</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://monstergeo.github.io/btest/2023/11/26/ocr/" data-id="cmlgrfvff000m6whxfczxa7ur" data-title="ocr" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/computer/" rel="tag">computer</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-A-star-Search" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/07/28/A-star-Search/" class="article-date">
  <time class="dt-published" datetime="2023-07-28T13:49:00.000Z" itemprop="datePublished">2023-07-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/computer/">computer</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/07/28/A-star-Search/">A-star_Search</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="A-寻路算法的基本思想和基本代码实现："><a href="#A-寻路算法的基本思想和基本代码实现：" class="headerlink" title="A*寻路算法的基本思想和基本代码实现："></a>A*寻路算法的基本思想和基本代码实现：</h1><p>关于寻路算法有许多不同的答案，像广度搜索，深度搜索、跳点搜索算法、弗洛伊德等等算法，但今天我们主要讲一个常用的算法A*(A-star)算法。</p>
<p>A*算法是建立在曼哈顿度量（又名出租车度量或者出租车几何）他有个非常好的性质，相比欧几里得度量来说，出租车度量更适合现实的空间。所以，我们首先来介绍一下曼哈顿度量</p>
<p>#度量空间和曼哈顿距离</p>
<p>一个度量空间$(X,d)$指的是具备距离$d(x,y)$的集合$X$，它的元素是点。而其中距离也叫距离函数，在接下来的代码里面我们会给出一个简单的空间例子，但最主要的还是关注这个度量空间的距离函数。</p>
<p>度量具备四个良好性质</p>
<ul>
<li>非负性</li>
<li>三角不等式</li>
<li>对称性</li>
<li>对于任意的$x\in X$都有$d(x,x)&#x3D;0$</li>
</ul>
<p>在算法中我们一般会想无视障碍物获取与终点的最短路径，这个时候就考虑使用欧几里得度量（或者欧几里得距离）</p>
<p>##欧几里得距离（$l^2$距离）</p>
<p>定义：$d_{l^2}$距离被定义为映射$d_{l^2}:R^n\times R^n\to R$，它由函数：</p>
<center>

<p>$<br>\begin{aligned}<br>    d_{l^2}((x_1,\cdots,x_n),(y_1,\cdots,y_n)) &#x3D;&amp; \sqrt{(x_1-y_1)^2+\cdots+(x_n-y_n)^2}\<br>    &#x3D;&amp; \left(\sum^n_{i&#x3D;1}(x_i-y_i)^2 \right)^{1&#x2F;2}<br>\end{aligned}<br>$</p>
</center>

<p>定义，实际上就是我们一般说的向量的点积。</p>
<p>而现在我们定义出租车度量($l^1$度量)由函数</p>
<center>

<p>$<br>\begin{aligned}<br>    d_{l^1} &#x3D; ((x_1,\cdots,x_n),(y_1,\cdots,y_n)) &#x3D;&amp; \mid x_1-y_1\mid +\cdots+\mid x_n-y_n\mid\<br>    &#x3D;&amp;\sum^n_{i&#x3D;1}\mid x_i-y_i\mid<br>\end{aligned}<br>$</p>
</center>

<p>定义的。</p>
<p>我们如此定义这个函数，是因为当出租车从一点驶向另一点的时候，如果只能沿着坐标方向（北、南、东、西）而不允许走对角线，那么出租车驶过的距离就可以用曼哈顿距离计算。</p>
<h1 id="算法的简单介绍"><a href="#算法的简单介绍" class="headerlink" title="算法的简单介绍"></a>算法的简单介绍</h1><h2 id="广度优先搜索算法"><a href="#广度优先搜索算法" class="headerlink" title="广度优先搜索算法"></a>广度优先搜索算法</h2><p>广度优先搜索算法（Breadth-first search，缩写为BFS） BFS是从根节点开始，沿着树的宽度遍历树的结点，当我们遍历完树的全部节点或者遍历到我们想要的节点，则算法终止。</p>
<p>举个例子，我们假设有一个迷宫，迷宫由一个起点和一些格子，格子上有的标记为障碍物。当我们走到岔路口的时候，会放弃继续进入岔路口，而是回头继续探索别的路直到碰到岔路口，然后重复这个过程直到遍历到终点，这个算法的好处就是他找到的第一条路就是最短路径。但是耗费的时间会很多。</p>
<h2 id="A-star算法的简单描述和场景设置"><a href="#A-star算法的简单描述和场景设置" class="headerlink" title="A-star算法的简单描述和场景设置"></a>A-star算法的简单描述和场景设置</h2><p>为了算法的实现，我们首先把空间抽象成一个由二维格子组成的二维平面，为了描述我们要做的东西，</p>
<p>#估价函数</p>
<p>为了不像广度搜索算法一样盲目乱走，如何选择格子去走就成了第一个问题，这也就是为什么要对格子进行估价的原因，那么我们定义一个比较简单的东西。</p>
<p>我们给每个格子都定义一些代价，即从起点到格子的之间格子的数量，记为$g(n)$，再定义<br>格子到终点之间隔了多少个格子的数量，记为$h(n)$</p>
<p>那么定义估价函数为</p>
<center>

<p>$<br>f(n) &#x3D; g(n)+h(n)<br>$</p>
</center>

<p>现在看个例子：</p>
<center>

<img src='/Btest/2023/07/28/A-star-Search/1.png'>

</center>

<ul>
<li><p>橙色格子要移动到1号格子，那么它只需移动一步，因此$g(1)&#x3D;1$，但1号格子它离红色格子的<strong>直线距离</strong>为 $d_{l^2} (2,6) &#x3D; \sqrt{2^2+6^2} &#x3D; \sqrt{40}$个格子</p>
</li>
<li><p>进一步的，对于2，3格子，格子的估阶函数是$g(2) &#x3D; 1, g(3) &#x3D; \sqrt{2}$，$h(2) &#x3D; \sqrt{26} ,h(3) &#x3D; \sqrt{17}$则</p>
</li>
</ul>
<center>

<p>$<br>f(2) &#x3D; 1+\sqrt{26} \approx 6 &gt; f(3) &#x3D; \sqrt{2} + \sqrt{17} \approx 5.53<br>$</p>
</center>

<p>+对于4号格子，我们可以得到$f(4) &#x3D; g(4)+h(4) &#x3D; 2+5&#x3D;7$</p>
<p>因此，根据估阶函数给出的值我们大概知道 $f(3)&lt;f(2)&lt;f(4)&lt;f(1)$</p>
<p>所以我们优先考虑格子3。现在我们发现两个问题</p>
<ul>
<li>计算的过程中伴随开方和根号运算，需要使用浮点数。</li>
<li>实际的过程我们并不能平滑的移动到红色格子，需要水平+对角移动相结合，例如格子3到终点的距离实际上是：$h(3) &#x3D; \sqrt{8}+2$，因为要翻跃障碍物。</li>
</ul>
<p>所以，这就是为什么我一开始就侧重讲曼哈顿度量的原因，它更符合我们的想法。</p>
<p>因此，曼哈顿度量是小于等于欧拉度量的。</p>
<h3 id="h-n-对选择的影响"><a href="#h-n-对选择的影响" class="headerlink" title="$h(n)$对选择的影响"></a>$h(n)$对选择的影响</h3><p>我们假设有一个$6\times 4$棋盘，设起点为$A(0,0)$，终点为$B(6,4)$代表第4行的第六个格子。再任取两个格子$C(1,3)$和$D(3,1)$。</p>
<p>障碍物为如下四个格子：$\alpha(4,2), \beta(4,3),\gamma(3,3),\omega(2,3)$</p>
<p>不妨计算一下它们的估阶函数，$g(D) &#x3D;g(C) &#x3D; 2$，因为是朝上边和右边走两格就到了。然后我们计算$h(n)$的曼哈顿度量。$h(D) &#x3D; 6 &#x3D; h(C)$，这出现了一个问题，我们不知道如何选择最优路径。因为它们的估阶函数一样。现在，让我们计算它们的对角线距离</p>
<center>

<p>$<br>\begin{aligned}<br>    h(D) &#x3D;&amp; \sqrt{(6-3)^2+(4-1)^2} &#x3D; 3\sqrt{2} \approx 4.24\<br>    h(C) &#x3D;&amp; \sqrt{(6-1)^2+(4-3)^2} &#x3D; \sqrt{26} \approx 5<br>\end{aligned}<br>$</p>
</center>

<p>所以，我们更应该选择格子$D$为最优路径，实际上这也确实是对的。因为格子D的实际距离为$1+\sqrt{2}+1+\sqrt{2} &#x3D; 2+2\sqrt{2} \approx 4.8$稍微比对角线距离大点。所以我们得到</p>
<center>

<p>曼哈顿距离&gt;实际距离&gt;对角线距离</p>
</center>

<p>现在该总结一下了</p>
<ul>
<li>若$h(n) \leq $到终点的实际距离，那么A*可以找到最短路径，但随着搜索的点越多，范围就越大效率也越低</li>
<li>若$h(n)&gt;$到终点的实际距离，则搜索的点少，搜索范围小，效率高，但不一定是最优解。</li>
<li>$h(n) \sim $实际距离，那么$A^*$算法越完美。</li>
<li>若$h(n)&#x3D;0$，这说明$f(n)&#x3D;g(n)$，那么会发生一种情况，算法会毫无目的的在四周搜索。</li>
<li>若$h(n) &gt; g(n)$，那么$f(n)$的大头主要看$h(n)$，这就变成了广度优先算法。</li>
</ul>
<p>##具体的寻路过程</p>
<p>还是那个例子：</p>
<center>

<img src='/Btest/2023/07/28/A-star-Search/2.png'>
</center>

<p>它们的估阶函数如下：</p>
<ul>
<li>1：$f(1) &#x3D; 6.4, g(1)&#x3D;1,h(1)&#x3D;5.4$</li>
<li>2：$f(2) &#x3D; 5.8, g(2) &#x3D; 1.4,h(2)&#x3D;4.4$</li>
<li>3：$f(3) &#x3D; 5,g(3) &#x3D; 1,h(3) &#x3D; 4$</li>
<li>4：$f(4) &#x3D; 5.8,g(4)&#x3D;1.4,h(4)&#x3D;4.4$</li>
<li>5：$f(5) &#x3D; 6.4,,g(5) &#x3D; 1,h(5)&#x3D;5.4$</li>
</ul>
<p>若在$f$相同的时候，我们考虑$g$的值。根据$f$，那么实际上我们选择格子$3$，然后我们进行下一步，</p>
<p>第二步：我们走到第三个格子后，又产生了新的路径选择，如下图所示：</p>
<center>

<img src='/Btest/2023/07/28/A-star-Search/3.png'>
</center>

<p>于是，我们再次计算格子的估阶函数，这次注意的是，$4,5$ 是障碍，所以不需要考虑这两个格子。格子$8$实际上就是起点，所以也不需要考虑，我们只需要考虑$2,3,6$三个格子就行了，它们的估阶函数为：</p>
<ul>
<li>$f(2) &#x3D; 5.8,g &#x3D; 1.4,h &#x3D;4.4$</li>
<li>$f(3) &#x3D; 5.8,g&#x3D;2.4,h&#x3D;3.4$</li>
<li>$f(6) &#x3D; 5.8,g&#x3D;1.4,h&#x3D;4.4$</li>
</ul>
<p>正如我们刚才所说，我们计算的$g$是起点到格子的距离，$h$是终点的，但现在情况不一样，我们已经走了一格，所以到起点的路也必须经过我们走过的格子，所以，实际上$f(2)$应该在$g$上加$1$,$6$也是一样的道理，但$3$不用，因为它本身就包含了走过的格子的距离，那么更新后的为<br>$f(2) &#x3D; 6.8&#x3D;f(6)$。所以我们这次选择$3$号格子。</p>
<p>然后我们不断的重复这个步骤直到遍历到终点。</p>
<center>

<img src='/Btest/2023/07/28/A-star-Search/4.png'>

</center>

<p>然后只需要根据格子$n$一路前进即可得到最优路线。当然，如果使用曼哈顿距离，我们可以得到更简单的表达方法。但是不能走斜线。</p>
<p>##代码编写环节</p>
<p>##初始化</p>
<p>我们先初始化一些参数，定义一个类<strong>Node</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Node:</span><br><span class="line">    def __init__(self,x,y):</span><br><span class="line">        self.x = x #纵坐标</span><br><span class="line">        self.y=y #横坐标</span><br><span class="line">        self.g =0 #代价g</span><br><span class="line">        self.h=0 #代价h</span><br><span class="line">        self.parent = None #初始化父节点</span><br></pre></td></tr></table></figure>

<p>然后我们定义一个估阶函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def f(self):</span><br><span class="line">    return self.g+self.h</span><br></pre></td></tr></table></figure>

<p>并使用曼哈顿度量作为标准度量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def heuristic(node,goal): </span><br><span class="line">#node 是当前节点的坐标信息</span><br><span class="line">#goal 指的是目标节点的坐标信息</span><br><span class="line"> return abs(node.x - goal.x) + abs(node.y - goal.y)</span><br><span class="line">#它返回目标和当前节点的距离</span><br></pre></td></tr></table></figure>
<p>最后我们定义估阶函数的对比函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def __lt__(self, other):</span><br><span class="line">    # 实现节点的比较方法，使用 f() 函数值进行比较</span><br><span class="line">    return self.f() &lt; other.f()</span><br></pre></td></tr></table></figure>


<p>初始化到这里就差不多了，接下来让我们进入到下一个部分</p>
<p>##准备</p>
<p>我们需要判断当前节点的临近节点状态，看看是否有超过地图的，那么定义函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def get_neighbors(node,grid):</span><br><span class="line">    neighbors = []</span><br><span class="line">    for dx,dy in [(1,0),(-1,0),(0,1),(0,-1)]:</span><br><span class="line">        x,y = node.x+dx, node.y+dy</span><br><span class="line">        if 0&lt;= x &lt;len(grid) and 0 &lt;= len(grid[0]) and not grid[x][y]:</span><br><span class="line">            neighbors.append(Node(x, y))</span><br><span class="line">    return neighbors</span><br></pre></td></tr></table></figure>
<p>这里重点解释一下这个if语句，前面两个是检测是否超过边界，而我们的重点在最后一个条件。由于我们是用一个二维矩阵（二维数组）表示的地图，而每个点$(x,y)$表示数组上的一个数字（1表示障碍物，0表示通道）因此在这里我们用not 符号检测点是否为障碍物，若为1，not后是0（等价于布尔值的 false，不满足条件，因此不会计入neighbors组中）</p>
<p>如果我们已经遍历完成且找到终点了呢？那么现在我们定义回溯函数，它被用来从终点找到返回起点的最短路径。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def reconstruct_path(node);</span><br><span class="line">    path = []</span><br><span class="line">    while node:</span><br><span class="line">        path.append((node.x, node.y))</span><br><span class="line">        node = node.parent</span><br><span class="line">    return path[::-1]</span><br></pre></td></tr></table></figure>
<p>它被设定用来接收每一个路径上的节点并反向的打印。</p>
<p>##A-star 搜索实现</p>
<p>最后，我们来定义搜索函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">def a_star_search(grid,start,goal): #把地图，起点，终点当成参数</span><br><span class="line">    open_list = [] #储存待探索的节点</span><br><span class="line">    closed_list = []#储存已探索的节点</span><br><span class="line"></span><br><span class="line">    start_node = Node(start[0],start[1]) #start是一个包含两个元素的一维数组，这里是传入第一个和第二个元素作为点的坐标 </span><br><span class="line">    goal_node = Node(goal[0],goal[1])</span><br><span class="line">    heapq.heappush(open_list, (start_node.f(), start_node))  # 将起始节点加入 open_list</span><br><span class="line"></span><br><span class="line">    while open_list:</span><br><span class="line">        _, current_node = heapq.heappop(open_list)</span><br><span class="line">        if(current_node.x,current_node.y) == (goal_node.x,goal_node.y) #判断是否为终点</span><br><span class="line">            return reconstruct_path(current_node)</span><br><span class="line">         closed_set.add((current_node.x, current_node.y))  # 将当前节点加入已探索集合</span><br><span class="line">        for neighbor in get_neighbors(current_node, grid):</span><br><span class="line">            if (neighbor.x, neighbor.y) in closed_set:</span><br><span class="line">                continue  # 如果邻居节点已探索过，跳过本次循环</span><br><span class="line"></span><br><span class="line">            tentative_g = current_node.g + 1  # 这里假设每一步的代价都是 1</span><br><span class="line"></span><br><span class="line">            if (neighbor.f(), neighbor) in open_list:</span><br><span class="line">                # 如果邻居节点已经在 open_list 中，更新代价和父节点</span><br><span class="line">                if neighbor.g &gt; tentative_g:</span><br><span class="line">                    neighbor.g = tentative_g</span><br><span class="line">                    neighbor.parent = current_node</span><br><span class="line">            else:</span><br><span class="line">                # 否则，将邻居节点加入 open_list，并设置代价和父节点</span><br><span class="line">                neighbor.g = tentative_g</span><br><span class="line">                neighbor.h = heuristic(neighbor, goal_node)</span><br><span class="line">                neighbor.parent = current_node</span><br><span class="line">                heapq.heappush(open_list, (neighbor.f(), neighbor))</span><br><span class="line"></span><br><span class="line">    return None  # 如果 open_list 为空，则无法找到路径，返回 None</span><br></pre></td></tr></table></figure>

<p>最后，我们需要将三个参数传入搜索函数，我们定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">grid = [</span><br><span class="line">    [0, 0, 0, 0, 0],</span><br><span class="line">    [0, 0, 1, 1, 0],</span><br><span class="line">    [0, 0, 1, 0, 0],</span><br><span class="line">    [0, 0, 1, 0, 0],</span><br><span class="line">    [0, 0, 1, 0, 0]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">start = (0, 2)</span><br><span class="line">goal = (4, 1)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第一个是地图，第二个是起点，第三个是终点。<br>最后调用函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path = a_star_search(grid, start, goal)</span><br><span class="line">print(path) </span><br></pre></td></tr></table></figure>
<p>那么理论上它输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[(0, 2), (0, 1), (1, 1), (2, 1), (3, 1), (4, 1)]</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://monstergeo.github.io/btest/2023/07/28/A-star-Search/" data-id="cmlgrfveg00016whxd9bi11pi" data-title="A-star_Search" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/MATLAB/">MATLAB</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/analyze/">analyze</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/computer/">computer</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Stm32/" rel="tag">Stm32</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/algorithms/" rel="tag">algorithms</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/complex-analysis/" rel="tag">complex_analysis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/computer/" rel="tag">computer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/math/" rel="tag">math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/matlab/" rel="tag">matlab</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tech/" rel="tag">tech</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" rel="tag">图形学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/" rel="tag">密码学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/" rel="tag">计算机原理</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Stm32/" style="font-size: 12.5px;">Stm32</a> <a href="/tags/algorithms/" style="font-size: 15px;">algorithms</a> <a href="/tags/complex-analysis/" style="font-size: 20px;">complex_analysis</a> <a href="/tags/computer/" style="font-size: 10px;">computer</a> <a href="/tags/math/" style="font-size: 12.5px;">math</a> <a href="/tags/matlab/" style="font-size: 10px;">matlab</a> <a href="/tags/tech/" style="font-size: 10px;">tech</a> <a href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" style="font-size: 10px;">图形学</a> <a href="/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/" style="font-size: 17.5px;">密码学</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/" style="font-size: 12.5px;">计算机原理</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2026/02/">February 2026</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/09/">September 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/08/">August 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/07/">July 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">June 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">March 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/02/">February 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/12/">December 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">November 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2026/02/10/liner_algebra/">利用MATLAB计算矩阵</a>
          </li>
        
          <li>
            <a href="/2026/02/10/bqj/">海涅-博雷尔定理</a>
          </li>
        
          <li>
            <a href="/2026/02/10/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2025/09/10/%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/">合作式调度器</a>
          </li>
        
          <li>
            <a href="/2025/08/31/ocrs/">边缘识别</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2026 Marcus<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>